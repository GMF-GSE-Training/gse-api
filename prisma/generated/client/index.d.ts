
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * *
 *  * Model untuk pengguna sistem.
 *  * @description Menyimpan informasi pengguna seperti email, nama, dan kredensial autentikasi.
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * *
 *  * Model untuk peran pengguna.
 *  * @description Menyimpan informasi peran seperti admin atau user.
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model OAuthState
 * *
 *  * Model untuk menyimpan state OAuth.
 *  * @description Digunakan untuk melacak sesi OAuth sementara.
 */
export type OAuthState = $Result.DefaultSelection<Prisma.$OAuthStatePayload>
/**
 * Model AppConfig
 * *
 *  * Model untuk konfigurasi aplikasi.
 *  * @description Menyimpan URL frontend dan backend.
 */
export type AppConfig = $Result.DefaultSelection<Prisma.$AppConfigPayload>
/**
 * Model FileMetadata
 * *
 *  * Model untuk metadata file.
 *  * @description Menyimpan informasi file seperti path, tipe, ukuran, dan sensitivitas.
 */
export type FileMetadata = $Result.DefaultSelection<Prisma.$FileMetadataPayload>
/**
 * Model Participant
 * *
 *  * Model untuk peserta pelatihan.
 *  * @description Menyimpan data peserta seperti NIK, email, dan dokumen terkait.
 */
export type Participant = $Result.DefaultSelection<Prisma.$ParticipantPayload>
/**
 * Model Capability
 * *
 *  * Model untuk kemampuan pelatihan.
 *  * @description Menyimpan informasi tentang kode pelatihan dan durasi.
 */
export type Capability = $Result.DefaultSelection<Prisma.$CapabilityPayload>
/**
 * Model CurriculumSyllabus
 * *
 *  * Model untuk silabus kurikulum.
 *  * @description Menyimpan detail silabus seperti durasi teori dan praktik.
 */
export type CurriculumSyllabus = $Result.DefaultSelection<Prisma.$CurriculumSyllabusPayload>
/**
 * Model COT
 * *
 *  * Model untuk pelatihan (COT).
 *  * @description Menyimpan informasi pelatihan seperti tanggal dan lokasi.
 */
export type COT = $Result.DefaultSelection<Prisma.$COTPayload>
/**
 * Model CapabilityCOT
 * *
 *  * Model untuk menghubungkan kemampuan dengan pelatihan.
 *  * @description Relasi antara Capability dan COT.
 */
export type CapabilityCOT = $Result.DefaultSelection<Prisma.$CapabilityCOTPayload>
/**
 * Model ParticipantsCOT
 * *
 *  * Model untuk menghubungkan peserta dengan pelatihan.
 *  * @description Relasi antara Participant dan COT.
 */
export type ParticipantsCOT = $Result.DefaultSelection<Prisma.$ParticipantsCOTPayload>
/**
 * Model Signature
 * *
 *  * Model untuk tanda tangan digital.
 *  * @description Menyimpan informasi tanda tangan elektronik.
 */
export type Signature = $Result.DefaultSelection<Prisma.$SignaturePayload>
/**
 * Model Certificate
 * *
 *  * Model untuk sertifikat pelatihan.
 *  * @description Menyimpan informasi sertifikat yang diterbitkan.
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model RefreshToken
 * *
 *  * Model untuk token refresh.
 *  * @description Menyimpan token refresh untuk autentikasi sesi.
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model BlacklistedToken
 * *
 *  * Model untuk token yang diblacklist.
 *  * @description Menyimpan token yang tidak valid lagi.
 */
export type BlacklistedToken = $Result.DefaultSelection<Prisma.$BlacklistedTokenPayload>
/**
 * Model AuditLog
 * *
 *  * Model untuk log audit.
 *  * @description Mencatat aktivitas pengguna untuk pelacakan keamanan.
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OAuthProvider: {
  GOOGLE: 'GOOGLE',
  MICROSOFT: 'MICROSOFT'
};

export type OAuthProvider = (typeof OAuthProvider)[keyof typeof OAuthProvider]


export const SignatureType: {
  SIGNATURE1: 'SIGNATURE1',
  SIGNATURE2: 'SIGNATURE2'
};

export type SignatureType = (typeof SignatureType)[keyof typeof SignatureType]

}

export type OAuthProvider = $Enums.OAuthProvider

export const OAuthProvider: typeof $Enums.OAuthProvider

export type SignatureType = $Enums.SignatureType

export const SignatureType: typeof $Enums.SignatureType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oAuthState`: Exposes CRUD operations for the **OAuthState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthStates
    * const oAuthStates = await prisma.oAuthState.findMany()
    * ```
    */
  get oAuthState(): Prisma.OAuthStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appConfig`: Exposes CRUD operations for the **AppConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppConfigs
    * const appConfigs = await prisma.appConfig.findMany()
    * ```
    */
  get appConfig(): Prisma.AppConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileMetadata`: Exposes CRUD operations for the **FileMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileMetadata
    * const fileMetadata = await prisma.fileMetadata.findMany()
    * ```
    */
  get fileMetadata(): Prisma.FileMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.participant`: Exposes CRUD operations for the **Participant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Participants
    * const participants = await prisma.participant.findMany()
    * ```
    */
  get participant(): Prisma.ParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capability`: Exposes CRUD operations for the **Capability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capabilities
    * const capabilities = await prisma.capability.findMany()
    * ```
    */
  get capability(): Prisma.CapabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.curriculumSyllabus`: Exposes CRUD operations for the **CurriculumSyllabus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurriculumSyllabi
    * const curriculumSyllabi = await prisma.curriculumSyllabus.findMany()
    * ```
    */
  get curriculumSyllabus(): Prisma.CurriculumSyllabusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cOT`: Exposes CRUD operations for the **COT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more COTS
    * const cOTS = await prisma.cOT.findMany()
    * ```
    */
  get cOT(): Prisma.COTDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capabilityCOT`: Exposes CRUD operations for the **CapabilityCOT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CapabilityCOTS
    * const capabilityCOTS = await prisma.capabilityCOT.findMany()
    * ```
    */
  get capabilityCOT(): Prisma.CapabilityCOTDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.participantsCOT`: Exposes CRUD operations for the **ParticipantsCOT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParticipantsCOTS
    * const participantsCOTS = await prisma.participantsCOT.findMany()
    * ```
    */
  get participantsCOT(): Prisma.ParticipantsCOTDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signature`: Exposes CRUD operations for the **Signature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signatures
    * const signatures = await prisma.signature.findMany()
    * ```
    */
  get signature(): Prisma.SignatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blacklistedToken`: Exposes CRUD operations for the **BlacklistedToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlacklistedTokens
    * const blacklistedTokens = await prisma.blacklistedToken.findMany()
    * ```
    */
  get blacklistedToken(): Prisma.BlacklistedTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    OAuthState: 'OAuthState',
    AppConfig: 'AppConfig',
    FileMetadata: 'FileMetadata',
    Participant: 'Participant',
    Capability: 'Capability',
    CurriculumSyllabus: 'CurriculumSyllabus',
    COT: 'COT',
    CapabilityCOT: 'CapabilityCOT',
    ParticipantsCOT: 'ParticipantsCOT',
    Signature: 'Signature',
    Certificate: 'Certificate',
    RefreshToken: 'RefreshToken',
    BlacklistedToken: 'BlacklistedToken',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "oAuthState" | "appConfig" | "fileMetadata" | "participant" | "capability" | "curriculumSyllabus" | "cOT" | "capabilityCOT" | "participantsCOT" | "signature" | "certificate" | "refreshToken" | "blacklistedToken" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      OAuthState: {
        payload: Prisma.$OAuthStatePayload<ExtArgs>
        fields: Prisma.OAuthStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          findFirst: {
            args: Prisma.OAuthStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          findMany: {
            args: Prisma.OAuthStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>[]
          }
          create: {
            args: Prisma.OAuthStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          createMany: {
            args: Prisma.OAuthStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>[]
          }
          delete: {
            args: Prisma.OAuthStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          update: {
            args: Prisma.OAuthStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          deleteMany: {
            args: Prisma.OAuthStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OAuthStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>[]
          }
          upsert: {
            args: Prisma.OAuthStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthStatePayload>
          }
          aggregate: {
            args: Prisma.OAuthStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthState>
          }
          groupBy: {
            args: Prisma.OAuthStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthStateCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthStateCountAggregateOutputType> | number
          }
        }
      }
      AppConfig: {
        payload: Prisma.$AppConfigPayload<ExtArgs>
        fields: Prisma.AppConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findFirst: {
            args: Prisma.AppConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findMany: {
            args: Prisma.AppConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          create: {
            args: Prisma.AppConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          createMany: {
            args: Prisma.AppConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          delete: {
            args: Prisma.AppConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          update: {
            args: Prisma.AppConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          deleteMany: {
            args: Prisma.AppConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          upsert: {
            args: Prisma.AppConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          aggregate: {
            args: Prisma.AppConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppConfig>
          }
          groupBy: {
            args: Prisma.AppConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AppConfigCountAggregateOutputType> | number
          }
        }
      }
      FileMetadata: {
        payload: Prisma.$FileMetadataPayload<ExtArgs>
        fields: Prisma.FileMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          findFirst: {
            args: Prisma.FileMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          findMany: {
            args: Prisma.FileMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>[]
          }
          create: {
            args: Prisma.FileMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          createMany: {
            args: Prisma.FileMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>[]
          }
          delete: {
            args: Prisma.FileMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          update: {
            args: Prisma.FileMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          deleteMany: {
            args: Prisma.FileMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>[]
          }
          upsert: {
            args: Prisma.FileMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          aggregate: {
            args: Prisma.FileMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileMetadata>
          }
          groupBy: {
            args: Prisma.FileMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<FileMetadataCountAggregateOutputType> | number
          }
        }
      }
      Participant: {
        payload: Prisma.$ParticipantPayload<ExtArgs>
        fields: Prisma.ParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findFirst: {
            args: Prisma.ParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findMany: {
            args: Prisma.ParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          create: {
            args: Prisma.ParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          createMany: {
            args: Prisma.ParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          delete: {
            args: Prisma.ParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          update: {
            args: Prisma.ParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          aggregate: {
            args: Prisma.ParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParticipant>
          }
          groupBy: {
            args: Prisma.ParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ParticipantCountAggregateOutputType> | number
          }
        }
      }
      Capability: {
        payload: Prisma.$CapabilityPayload<ExtArgs>
        fields: Prisma.CapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          findFirst: {
            args: Prisma.CapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          findMany: {
            args: Prisma.CapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>[]
          }
          create: {
            args: Prisma.CapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          createMany: {
            args: Prisma.CapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CapabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>[]
          }
          delete: {
            args: Prisma.CapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          update: {
            args: Prisma.CapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          deleteMany: {
            args: Prisma.CapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CapabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>[]
          }
          upsert: {
            args: Prisma.CapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityPayload>
          }
          aggregate: {
            args: Prisma.CapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapability>
          }
          groupBy: {
            args: Prisma.CapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<CapabilityCountAggregateOutputType> | number
          }
        }
      }
      CurriculumSyllabus: {
        payload: Prisma.$CurriculumSyllabusPayload<ExtArgs>
        fields: Prisma.CurriculumSyllabusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurriculumSyllabusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurriculumSyllabusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>
          }
          findFirst: {
            args: Prisma.CurriculumSyllabusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurriculumSyllabusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>
          }
          findMany: {
            args: Prisma.CurriculumSyllabusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>[]
          }
          create: {
            args: Prisma.CurriculumSyllabusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>
          }
          createMany: {
            args: Prisma.CurriculumSyllabusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurriculumSyllabusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>[]
          }
          delete: {
            args: Prisma.CurriculumSyllabusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>
          }
          update: {
            args: Prisma.CurriculumSyllabusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>
          }
          deleteMany: {
            args: Prisma.CurriculumSyllabusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurriculumSyllabusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurriculumSyllabusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>[]
          }
          upsert: {
            args: Prisma.CurriculumSyllabusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumSyllabusPayload>
          }
          aggregate: {
            args: Prisma.CurriculumSyllabusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurriculumSyllabus>
          }
          groupBy: {
            args: Prisma.CurriculumSyllabusGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurriculumSyllabusGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurriculumSyllabusCountArgs<ExtArgs>
            result: $Utils.Optional<CurriculumSyllabusCountAggregateOutputType> | number
          }
        }
      }
      COT: {
        payload: Prisma.$COTPayload<ExtArgs>
        fields: Prisma.COTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.COTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.COTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>
          }
          findFirst: {
            args: Prisma.COTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.COTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>
          }
          findMany: {
            args: Prisma.COTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>[]
          }
          create: {
            args: Prisma.COTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>
          }
          createMany: {
            args: Prisma.COTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.COTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>[]
          }
          delete: {
            args: Prisma.COTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>
          }
          update: {
            args: Prisma.COTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>
          }
          deleteMany: {
            args: Prisma.COTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.COTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.COTUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>[]
          }
          upsert: {
            args: Prisma.COTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COTPayload>
          }
          aggregate: {
            args: Prisma.COTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCOT>
          }
          groupBy: {
            args: Prisma.COTGroupByArgs<ExtArgs>
            result: $Utils.Optional<COTGroupByOutputType>[]
          }
          count: {
            args: Prisma.COTCountArgs<ExtArgs>
            result: $Utils.Optional<COTCountAggregateOutputType> | number
          }
        }
      }
      CapabilityCOT: {
        payload: Prisma.$CapabilityCOTPayload<ExtArgs>
        fields: Prisma.CapabilityCOTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapabilityCOTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapabilityCOTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>
          }
          findFirst: {
            args: Prisma.CapabilityCOTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapabilityCOTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>
          }
          findMany: {
            args: Prisma.CapabilityCOTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>[]
          }
          create: {
            args: Prisma.CapabilityCOTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>
          }
          createMany: {
            args: Prisma.CapabilityCOTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CapabilityCOTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>[]
          }
          delete: {
            args: Prisma.CapabilityCOTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>
          }
          update: {
            args: Prisma.CapabilityCOTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>
          }
          deleteMany: {
            args: Prisma.CapabilityCOTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapabilityCOTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CapabilityCOTUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>[]
          }
          upsert: {
            args: Prisma.CapabilityCOTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityCOTPayload>
          }
          aggregate: {
            args: Prisma.CapabilityCOTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapabilityCOT>
          }
          groupBy: {
            args: Prisma.CapabilityCOTGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapabilityCOTGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapabilityCOTCountArgs<ExtArgs>
            result: $Utils.Optional<CapabilityCOTCountAggregateOutputType> | number
          }
        }
      }
      ParticipantsCOT: {
        payload: Prisma.$ParticipantsCOTPayload<ExtArgs>
        fields: Prisma.ParticipantsCOTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParticipantsCOTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParticipantsCOTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>
          }
          findFirst: {
            args: Prisma.ParticipantsCOTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParticipantsCOTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>
          }
          findMany: {
            args: Prisma.ParticipantsCOTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>[]
          }
          create: {
            args: Prisma.ParticipantsCOTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>
          }
          createMany: {
            args: Prisma.ParticipantsCOTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParticipantsCOTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>[]
          }
          delete: {
            args: Prisma.ParticipantsCOTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>
          }
          update: {
            args: Prisma.ParticipantsCOTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>
          }
          deleteMany: {
            args: Prisma.ParticipantsCOTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParticipantsCOTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParticipantsCOTUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>[]
          }
          upsert: {
            args: Prisma.ParticipantsCOTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantsCOTPayload>
          }
          aggregate: {
            args: Prisma.ParticipantsCOTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParticipantsCOT>
          }
          groupBy: {
            args: Prisma.ParticipantsCOTGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParticipantsCOTGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParticipantsCOTCountArgs<ExtArgs>
            result: $Utils.Optional<ParticipantsCOTCountAggregateOutputType> | number
          }
        }
      }
      Signature: {
        payload: Prisma.$SignaturePayload<ExtArgs>
        fields: Prisma.SignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findFirst: {
            args: Prisma.SignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findMany: {
            args: Prisma.SignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          create: {
            args: Prisma.SignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          createMany: {
            args: Prisma.SignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          delete: {
            args: Prisma.SignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          update: {
            args: Prisma.SignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          deleteMany: {
            args: Prisma.SignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SignatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          upsert: {
            args: Prisma.SignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          aggregate: {
            args: Prisma.SignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignature>
          }
          groupBy: {
            args: Prisma.SignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignatureCountArgs<ExtArgs>
            result: $Utils.Optional<SignatureCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      BlacklistedToken: {
        payload: Prisma.$BlacklistedTokenPayload<ExtArgs>
        fields: Prisma.BlacklistedTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlacklistedTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          findFirst: {
            args: Prisma.BlacklistedTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlacklistedTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          findMany: {
            args: Prisma.BlacklistedTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>[]
          }
          create: {
            args: Prisma.BlacklistedTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          createMany: {
            args: Prisma.BlacklistedTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlacklistedTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>[]
          }
          delete: {
            args: Prisma.BlacklistedTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          update: {
            args: Prisma.BlacklistedTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          deleteMany: {
            args: Prisma.BlacklistedTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlacklistedTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlacklistedTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>[]
          }
          upsert: {
            args: Prisma.BlacklistedTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          aggregate: {
            args: Prisma.BlacklistedTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlacklistedToken>
          }
          groupBy: {
            args: Prisma.BlacklistedTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlacklistedTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlacklistedTokenCountArgs<ExtArgs>
            result: $Utils.Optional<BlacklistedTokenCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    oAuthState?: OAuthStateOmit
    appConfig?: AppConfigOmit
    fileMetadata?: FileMetadataOmit
    participant?: ParticipantOmit
    capability?: CapabilityOmit
    curriculumSyllabus?: CurriculumSyllabusOmit
    cOT?: COTOmit
    capabilityCOT?: CapabilityCOTOmit
    participantsCOT?: ParticipantsCOTOmit
    signature?: SignatureOmit
    certificate?: CertificateOmit
    refreshToken?: RefreshTokenOmit
    blacklistedToken?: BlacklistedTokenOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    auditLogs: number
    blacklistedTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    blacklistedTokens?: boolean | UserCountOutputTypeCountBlacklistedTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlacklistedTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistedTokenWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ParticipantCountOutputType
   */

  export type ParticipantCountOutputType = {
    simA: number
    simB: number
    ktp: number
    foto: number
    suratSehatButaWarna: number
    suratBebasNarkoba: number
    qrCode: number
    participantsCots: number
    certificates: number
  }

  export type ParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simA?: boolean | ParticipantCountOutputTypeCountSimAArgs
    simB?: boolean | ParticipantCountOutputTypeCountSimBArgs
    ktp?: boolean | ParticipantCountOutputTypeCountKtpArgs
    foto?: boolean | ParticipantCountOutputTypeCountFotoArgs
    suratSehatButaWarna?: boolean | ParticipantCountOutputTypeCountSuratSehatButaWarnaArgs
    suratBebasNarkoba?: boolean | ParticipantCountOutputTypeCountSuratBebasNarkobaArgs
    qrCode?: boolean | ParticipantCountOutputTypeCountQrCodeArgs
    participantsCots?: boolean | ParticipantCountOutputTypeCountParticipantsCotsArgs
    certificates?: boolean | ParticipantCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantCountOutputType
     */
    select?: ParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountSimAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountSimBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountKtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountFotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountSuratSehatButaWarnaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountSuratBebasNarkobaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountQrCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountParticipantsCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantsCOTWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type CapabilityCountOutputType
   */

  export type CapabilityCountOutputType = {
    curriculumSyllabus: number
    capabilityCots: number
  }

  export type CapabilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculumSyllabus?: boolean | CapabilityCountOutputTypeCountCurriculumSyllabusArgs
    capabilityCots?: boolean | CapabilityCountOutputTypeCountCapabilityCotsArgs
  }

  // Custom InputTypes
  /**
   * CapabilityCountOutputType without action
   */
  export type CapabilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCountOutputType
     */
    select?: CapabilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CapabilityCountOutputType without action
   */
  export type CapabilityCountOutputTypeCountCurriculumSyllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurriculumSyllabusWhereInput
  }

  /**
   * CapabilityCountOutputType without action
   */
  export type CapabilityCountOutputTypeCountCapabilityCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapabilityCOTWhereInput
  }


  /**
   * Count Type COTCountOutputType
   */

  export type COTCountOutputType = {
    capabilityCots: number
    participantsCots: number
    certificates: number
  }

  export type COTCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capabilityCots?: boolean | COTCountOutputTypeCountCapabilityCotsArgs
    participantsCots?: boolean | COTCountOutputTypeCountParticipantsCotsArgs
    certificates?: boolean | COTCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * COTCountOutputType without action
   */
  export type COTCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COTCountOutputType
     */
    select?: COTCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * COTCountOutputType without action
   */
  export type COTCountOutputTypeCountCapabilityCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapabilityCOTWhereInput
  }

  /**
   * COTCountOutputType without action
   */
  export type COTCountOutputTypeCountParticipantsCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantsCOTWhereInput
  }

  /**
   * COTCountOutputType without action
   */
  export type COTCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type SignatureCountOutputType
   */

  export type SignatureCountOutputType = {
    certificates: number
  }

  export type SignatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | SignatureCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * SignatureCountOutputType without action
   */
  export type SignatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureCountOutputType
     */
    select?: SignatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SignatureCountOutputType without action
   */
  export type SignatureCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    loginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    loginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    idNumber: string | null
    name: string | null
    nik: string | null
    dinas: string | null
    password: string | null
    photo: string | null
    hashAlgorithm: string | null
    roleId: string | null
    participantId: string | null
    verifiedAccount: boolean | null
    accountVerificationToken: string | null
    verificationSentAt: Date | null
    passwordResetToken: string | null
    updateEmailToken: string | null
    loginAttempts: number | null
    lockUntil: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    oauthProvider: $Enums.OAuthProvider | null
    oauthId: string | null
    oauthRefreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    idNumber: string | null
    name: string | null
    nik: string | null
    dinas: string | null
    password: string | null
    photo: string | null
    hashAlgorithm: string | null
    roleId: string | null
    participantId: string | null
    verifiedAccount: boolean | null
    accountVerificationToken: string | null
    verificationSentAt: Date | null
    passwordResetToken: string | null
    updateEmailToken: string | null
    loginAttempts: number | null
    lockUntil: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    oauthProvider: $Enums.OAuthProvider | null
    oauthId: string | null
    oauthRefreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    idNumber: number
    name: number
    nik: number
    dinas: number
    password: number
    photo: number
    hashAlgorithm: number
    roleId: number
    participantId: number
    verifiedAccount: number
    accountVerificationToken: number
    verificationSentAt: number
    passwordResetToken: number
    updateEmailToken: number
    loginAttempts: number
    lockUntil: number
    twoFactorEnabled: number
    twoFactorSecret: number
    oauthProvider: number
    oauthId: number
    oauthRefreshToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    loginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    loginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    idNumber?: true
    name?: true
    nik?: true
    dinas?: true
    password?: true
    photo?: true
    hashAlgorithm?: true
    roleId?: true
    participantId?: true
    verifiedAccount?: true
    accountVerificationToken?: true
    verificationSentAt?: true
    passwordResetToken?: true
    updateEmailToken?: true
    loginAttempts?: true
    lockUntil?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    oauthProvider?: true
    oauthId?: true
    oauthRefreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    idNumber?: true
    name?: true
    nik?: true
    dinas?: true
    password?: true
    photo?: true
    hashAlgorithm?: true
    roleId?: true
    participantId?: true
    verifiedAccount?: true
    accountVerificationToken?: true
    verificationSentAt?: true
    passwordResetToken?: true
    updateEmailToken?: true
    loginAttempts?: true
    lockUntil?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    oauthProvider?: true
    oauthId?: true
    oauthRefreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    idNumber?: true
    name?: true
    nik?: true
    dinas?: true
    password?: true
    photo?: true
    hashAlgorithm?: true
    roleId?: true
    participantId?: true
    verifiedAccount?: true
    accountVerificationToken?: true
    verificationSentAt?: true
    passwordResetToken?: true
    updateEmailToken?: true
    loginAttempts?: true
    lockUntil?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    oauthProvider?: true
    oauthId?: true
    oauthRefreshToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    idNumber: string | null
    name: string
    nik: string | null
    dinas: string | null
    password: string | null
    photo: string | null
    hashAlgorithm: string
    roleId: string
    participantId: string | null
    verifiedAccount: boolean
    accountVerificationToken: string | null
    verificationSentAt: Date | null
    passwordResetToken: string | null
    updateEmailToken: string | null
    loginAttempts: number
    lockUntil: Date | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    oauthProvider: $Enums.OAuthProvider | null
    oauthId: string | null
    oauthRefreshToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    password?: boolean
    photo?: boolean
    hashAlgorithm?: boolean
    roleId?: boolean
    participantId?: boolean
    verifiedAccount?: boolean
    accountVerificationToken?: boolean
    verificationSentAt?: boolean
    passwordResetToken?: boolean
    updateEmailToken?: boolean
    loginAttempts?: boolean
    lockUntil?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    oauthRefreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    blacklistedTokens?: boolean | User$blacklistedTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    password?: boolean
    photo?: boolean
    hashAlgorithm?: boolean
    roleId?: boolean
    participantId?: boolean
    verifiedAccount?: boolean
    accountVerificationToken?: boolean
    verificationSentAt?: boolean
    passwordResetToken?: boolean
    updateEmailToken?: boolean
    loginAttempts?: boolean
    lockUntil?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    oauthRefreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    password?: boolean
    photo?: boolean
    hashAlgorithm?: boolean
    roleId?: boolean
    participantId?: boolean
    verifiedAccount?: boolean
    accountVerificationToken?: boolean
    verificationSentAt?: boolean
    passwordResetToken?: boolean
    updateEmailToken?: boolean
    loginAttempts?: boolean
    lockUntil?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    oauthRefreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    password?: boolean
    photo?: boolean
    hashAlgorithm?: boolean
    roleId?: boolean
    participantId?: boolean
    verifiedAccount?: boolean
    accountVerificationToken?: boolean
    verificationSentAt?: boolean
    passwordResetToken?: boolean
    updateEmailToken?: boolean
    loginAttempts?: boolean
    lockUntil?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    oauthRefreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "idNumber" | "name" | "nik" | "dinas" | "password" | "photo" | "hashAlgorithm" | "roleId" | "participantId" | "verifiedAccount" | "accountVerificationToken" | "verificationSentAt" | "passwordResetToken" | "updateEmailToken" | "loginAttempts" | "lockUntil" | "twoFactorEnabled" | "twoFactorSecret" | "oauthProvider" | "oauthId" | "oauthRefreshToken" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    blacklistedTokens?: boolean | User$blacklistedTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      blacklistedTokens: Prisma.$BlacklistedTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      idNumber: string | null
      name: string
      nik: string | null
      dinas: string | null
      password: string | null
      photo: string | null
      hashAlgorithm: string
      roleId: string
      participantId: string | null
      verifiedAccount: boolean
      accountVerificationToken: string | null
      verificationSentAt: Date | null
      passwordResetToken: string | null
      updateEmailToken: string | null
      loginAttempts: number
      lockUntil: Date | null
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      oauthProvider: $Enums.OAuthProvider | null
      oauthId: string | null
      oauthRefreshToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends User$participantArgs<ExtArgs> = {}>(args?: Subset<T, User$participantArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blacklistedTokens<T extends User$blacklistedTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$blacklistedTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly idNumber: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly nik: FieldRef<"User", 'String'>
    readonly dinas: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly hashAlgorithm: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly participantId: FieldRef<"User", 'String'>
    readonly verifiedAccount: FieldRef<"User", 'Boolean'>
    readonly accountVerificationToken: FieldRef<"User", 'String'>
    readonly verificationSentAt: FieldRef<"User", 'DateTime'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly updateEmailToken: FieldRef<"User", 'String'>
    readonly loginAttempts: FieldRef<"User", 'Int'>
    readonly lockUntil: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly oauthProvider: FieldRef<"User", 'OAuthProvider'>
    readonly oauthId: FieldRef<"User", 'String'>
    readonly oauthRefreshToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.participant
   */
  export type User$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.blacklistedTokens
   */
  export type User$blacklistedTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    where?: BlacklistedTokenWhereInput
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    cursor?: BlacklistedTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model OAuthState
   */

  export type AggregateOAuthState = {
    _count: OAuthStateCountAggregateOutputType | null
    _min: OAuthStateMinAggregateOutputType | null
    _max: OAuthStateMaxAggregateOutputType | null
  }

  export type OAuthStateMinAggregateOutputType = {
    id: string | null
    state: string | null
    createdAt: Date | null
    expiresAt: Date | null
    provider: string | null
  }

  export type OAuthStateMaxAggregateOutputType = {
    id: string | null
    state: string | null
    createdAt: Date | null
    expiresAt: Date | null
    provider: string | null
  }

  export type OAuthStateCountAggregateOutputType = {
    id: number
    state: number
    createdAt: number
    expiresAt: number
    provider: number
    _all: number
  }


  export type OAuthStateMinAggregateInputType = {
    id?: true
    state?: true
    createdAt?: true
    expiresAt?: true
    provider?: true
  }

  export type OAuthStateMaxAggregateInputType = {
    id?: true
    state?: true
    createdAt?: true
    expiresAt?: true
    provider?: true
  }

  export type OAuthStateCountAggregateInputType = {
    id?: true
    state?: true
    createdAt?: true
    expiresAt?: true
    provider?: true
    _all?: true
  }

  export type OAuthStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthState to aggregate.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthStates
    **/
    _count?: true | OAuthStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthStateMaxAggregateInputType
  }

  export type GetOAuthStateAggregateType<T extends OAuthStateAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthState[P]>
      : GetScalarType<T[P], AggregateOAuthState[P]>
  }




  export type OAuthStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthStateWhereInput
    orderBy?: OAuthStateOrderByWithAggregationInput | OAuthStateOrderByWithAggregationInput[]
    by: OAuthStateScalarFieldEnum[] | OAuthStateScalarFieldEnum
    having?: OAuthStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthStateCountAggregateInputType | true
    _min?: OAuthStateMinAggregateInputType
    _max?: OAuthStateMaxAggregateInputType
  }

  export type OAuthStateGroupByOutputType = {
    id: string
    state: string
    createdAt: Date
    expiresAt: Date
    provider: string
    _count: OAuthStateCountAggregateOutputType | null
    _min: OAuthStateMinAggregateOutputType | null
    _max: OAuthStateMaxAggregateOutputType | null
  }

  type GetOAuthStateGroupByPayload<T extends OAuthStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthStateGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthStateGroupByOutputType[P]>
        }
      >
    >


  export type OAuthStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    provider?: boolean
  }, ExtArgs["result"]["oAuthState"]>

  export type OAuthStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    provider?: boolean
  }, ExtArgs["result"]["oAuthState"]>

  export type OAuthStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    state?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    provider?: boolean
  }, ExtArgs["result"]["oAuthState"]>

  export type OAuthStateSelectScalar = {
    id?: boolean
    state?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    provider?: boolean
  }

  export type OAuthStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "state" | "createdAt" | "expiresAt" | "provider", ExtArgs["result"]["oAuthState"]>

  export type $OAuthStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      state: string
      createdAt: Date
      expiresAt: Date
      provider: string
    }, ExtArgs["result"]["oAuthState"]>
    composites: {}
  }

  type OAuthStateGetPayload<S extends boolean | null | undefined | OAuthStateDefaultArgs> = $Result.GetResult<Prisma.$OAuthStatePayload, S>

  type OAuthStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OAuthStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OAuthStateCountAggregateInputType | true
    }

  export interface OAuthStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthState'], meta: { name: 'OAuthState' } }
    /**
     * Find zero or one OAuthState that matches the filter.
     * @param {OAuthStateFindUniqueArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthStateFindUniqueArgs>(args: SelectSubset<T, OAuthStateFindUniqueArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OAuthState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OAuthStateFindUniqueOrThrowArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthStateFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateFindFirstArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthStateFindFirstArgs>(args?: SelectSubset<T, OAuthStateFindFirstArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OAuthState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateFindFirstOrThrowArgs} args - Arguments to find a OAuthState
     * @example
     * // Get one OAuthState
     * const oAuthState = await prisma.oAuthState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthStateFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OAuthStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthStates
     * const oAuthStates = await prisma.oAuthState.findMany()
     * 
     * // Get first 10 OAuthStates
     * const oAuthStates = await prisma.oAuthState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthStateWithIdOnly = await prisma.oAuthState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthStateFindManyArgs>(args?: SelectSubset<T, OAuthStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OAuthState.
     * @param {OAuthStateCreateArgs} args - Arguments to create a OAuthState.
     * @example
     * // Create one OAuthState
     * const OAuthState = await prisma.oAuthState.create({
     *   data: {
     *     // ... data to create a OAuthState
     *   }
     * })
     * 
     */
    create<T extends OAuthStateCreateArgs>(args: SelectSubset<T, OAuthStateCreateArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OAuthStates.
     * @param {OAuthStateCreateManyArgs} args - Arguments to create many OAuthStates.
     * @example
     * // Create many OAuthStates
     * const oAuthState = await prisma.oAuthState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthStateCreateManyArgs>(args?: SelectSubset<T, OAuthStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthStates and returns the data saved in the database.
     * @param {OAuthStateCreateManyAndReturnArgs} args - Arguments to create many OAuthStates.
     * @example
     * // Create many OAuthStates
     * const oAuthState = await prisma.oAuthState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthStates and only return the `id`
     * const oAuthStateWithIdOnly = await prisma.oAuthState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthStateCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OAuthState.
     * @param {OAuthStateDeleteArgs} args - Arguments to delete one OAuthState.
     * @example
     * // Delete one OAuthState
     * const OAuthState = await prisma.oAuthState.delete({
     *   where: {
     *     // ... filter to delete one OAuthState
     *   }
     * })
     * 
     */
    delete<T extends OAuthStateDeleteArgs>(args: SelectSubset<T, OAuthStateDeleteArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OAuthState.
     * @param {OAuthStateUpdateArgs} args - Arguments to update one OAuthState.
     * @example
     * // Update one OAuthState
     * const oAuthState = await prisma.oAuthState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthStateUpdateArgs>(args: SelectSubset<T, OAuthStateUpdateArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OAuthStates.
     * @param {OAuthStateDeleteManyArgs} args - Arguments to filter OAuthStates to delete.
     * @example
     * // Delete a few OAuthStates
     * const { count } = await prisma.oAuthState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthStateDeleteManyArgs>(args?: SelectSubset<T, OAuthStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthStates
     * const oAuthState = await prisma.oAuthState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthStateUpdateManyArgs>(args: SelectSubset<T, OAuthStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthStates and returns the data updated in the database.
     * @param {OAuthStateUpdateManyAndReturnArgs} args - Arguments to update many OAuthStates.
     * @example
     * // Update many OAuthStates
     * const oAuthState = await prisma.oAuthState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OAuthStates and only return the `id`
     * const oAuthStateWithIdOnly = await prisma.oAuthState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OAuthStateUpdateManyAndReturnArgs>(args: SelectSubset<T, OAuthStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OAuthState.
     * @param {OAuthStateUpsertArgs} args - Arguments to update or create a OAuthState.
     * @example
     * // Update or create a OAuthState
     * const oAuthState = await prisma.oAuthState.upsert({
     *   create: {
     *     // ... data to create a OAuthState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthState we want to update
     *   }
     * })
     */
    upsert<T extends OAuthStateUpsertArgs>(args: SelectSubset<T, OAuthStateUpsertArgs<ExtArgs>>): Prisma__OAuthStateClient<$Result.GetResult<Prisma.$OAuthStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OAuthStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateCountArgs} args - Arguments to filter OAuthStates to count.
     * @example
     * // Count the number of OAuthStates
     * const count = await prisma.oAuthState.count({
     *   where: {
     *     // ... the filter for the OAuthStates we want to count
     *   }
     * })
    **/
    count<T extends OAuthStateCountArgs>(
      args?: Subset<T, OAuthStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthStateAggregateArgs>(args: Subset<T, OAuthStateAggregateArgs>): Prisma.PrismaPromise<GetOAuthStateAggregateType<T>>

    /**
     * Group by OAuthState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthStateGroupByArgs['orderBy'] }
        : { orderBy?: OAuthStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthState model
   */
  readonly fields: OAuthStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthState model
   */
  interface OAuthStateFieldRefs {
    readonly id: FieldRef<"OAuthState", 'String'>
    readonly state: FieldRef<"OAuthState", 'String'>
    readonly createdAt: FieldRef<"OAuthState", 'DateTime'>
    readonly expiresAt: FieldRef<"OAuthState", 'DateTime'>
    readonly provider: FieldRef<"OAuthState", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OAuthState findUnique
   */
  export type OAuthStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState findUniqueOrThrow
   */
  export type OAuthStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState findFirst
   */
  export type OAuthStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthStates.
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthStates.
     */
    distinct?: OAuthStateScalarFieldEnum | OAuthStateScalarFieldEnum[]
  }

  /**
   * OAuthState findFirstOrThrow
   */
  export type OAuthStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthState to fetch.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthStates.
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthStates.
     */
    distinct?: OAuthStateScalarFieldEnum | OAuthStateScalarFieldEnum[]
  }

  /**
   * OAuthState findMany
   */
  export type OAuthStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter, which OAuthStates to fetch.
     */
    where?: OAuthStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthStates to fetch.
     */
    orderBy?: OAuthStateOrderByWithRelationInput | OAuthStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthStates.
     */
    cursor?: OAuthStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthStates.
     */
    skip?: number
    distinct?: OAuthStateScalarFieldEnum | OAuthStateScalarFieldEnum[]
  }

  /**
   * OAuthState create
   */
  export type OAuthStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data needed to create a OAuthState.
     */
    data: XOR<OAuthStateCreateInput, OAuthStateUncheckedCreateInput>
  }

  /**
   * OAuthState createMany
   */
  export type OAuthStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthStates.
     */
    data: OAuthStateCreateManyInput | OAuthStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthState createManyAndReturn
   */
  export type OAuthStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data used to create many OAuthStates.
     */
    data: OAuthStateCreateManyInput | OAuthStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthState update
   */
  export type OAuthStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data needed to update a OAuthState.
     */
    data: XOR<OAuthStateUpdateInput, OAuthStateUncheckedUpdateInput>
    /**
     * Choose, which OAuthState to update.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState updateMany
   */
  export type OAuthStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthStates.
     */
    data: XOR<OAuthStateUpdateManyMutationInput, OAuthStateUncheckedUpdateManyInput>
    /**
     * Filter which OAuthStates to update
     */
    where?: OAuthStateWhereInput
    /**
     * Limit how many OAuthStates to update.
     */
    limit?: number
  }

  /**
   * OAuthState updateManyAndReturn
   */
  export type OAuthStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The data used to update OAuthStates.
     */
    data: XOR<OAuthStateUpdateManyMutationInput, OAuthStateUncheckedUpdateManyInput>
    /**
     * Filter which OAuthStates to update
     */
    where?: OAuthStateWhereInput
    /**
     * Limit how many OAuthStates to update.
     */
    limit?: number
  }

  /**
   * OAuthState upsert
   */
  export type OAuthStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * The filter to search for the OAuthState to update in case it exists.
     */
    where: OAuthStateWhereUniqueInput
    /**
     * In case the OAuthState found by the `where` argument doesn't exist, create a new OAuthState with this data.
     */
    create: XOR<OAuthStateCreateInput, OAuthStateUncheckedCreateInput>
    /**
     * In case the OAuthState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthStateUpdateInput, OAuthStateUncheckedUpdateInput>
  }

  /**
   * OAuthState delete
   */
  export type OAuthStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
    /**
     * Filter which OAuthState to delete.
     */
    where: OAuthStateWhereUniqueInput
  }

  /**
   * OAuthState deleteMany
   */
  export type OAuthStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthStates to delete
     */
    where?: OAuthStateWhereInput
    /**
     * Limit how many OAuthStates to delete.
     */
    limit?: number
  }

  /**
   * OAuthState without action
   */
  export type OAuthStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthState
     */
    select?: OAuthStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OAuthState
     */
    omit?: OAuthStateOmit<ExtArgs> | null
  }


  /**
   * Model AppConfig
   */

  export type AggregateAppConfig = {
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  export type AppConfigMinAggregateOutputType = {
    id: string | null
    frontendUrl: string | null
    backendUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppConfigMaxAggregateOutputType = {
    id: string | null
    frontendUrl: string | null
    backendUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppConfigCountAggregateOutputType = {
    id: number
    frontendUrl: number
    backendUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppConfigMinAggregateInputType = {
    id?: true
    frontendUrl?: true
    backendUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppConfigMaxAggregateInputType = {
    id?: true
    frontendUrl?: true
    backendUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppConfigCountAggregateInputType = {
    id?: true
    frontendUrl?: true
    backendUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfig to aggregate.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppConfigs
    **/
    _count?: true | AppConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppConfigMaxAggregateInputType
  }

  export type GetAppConfigAggregateType<T extends AppConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAppConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppConfig[P]>
      : GetScalarType<T[P], AggregateAppConfig[P]>
  }




  export type AppConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppConfigWhereInput
    orderBy?: AppConfigOrderByWithAggregationInput | AppConfigOrderByWithAggregationInput[]
    by: AppConfigScalarFieldEnum[] | AppConfigScalarFieldEnum
    having?: AppConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppConfigCountAggregateInputType | true
    _min?: AppConfigMinAggregateInputType
    _max?: AppConfigMaxAggregateInputType
  }

  export type AppConfigGroupByOutputType = {
    id: string
    frontendUrl: string
    backendUrl: string
    createdAt: Date
    updatedAt: Date
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  type GetAppConfigGroupByPayload<T extends AppConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
        }
      >
    >


  export type AppConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frontendUrl?: boolean
    backendUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frontendUrl?: boolean
    backendUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frontendUrl?: boolean
    backendUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectScalar = {
    id?: boolean
    frontendUrl?: boolean
    backendUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "frontendUrl" | "backendUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["appConfig"]>

  export type $AppConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      frontendUrl: string
      backendUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appConfig"]>
    composites: {}
  }

  type AppConfigGetPayload<S extends boolean | null | undefined | AppConfigDefaultArgs> = $Result.GetResult<Prisma.$AppConfigPayload, S>

  type AppConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppConfigCountAggregateInputType | true
    }

  export interface AppConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppConfig'], meta: { name: 'AppConfig' } }
    /**
     * Find zero or one AppConfig that matches the filter.
     * @param {AppConfigFindUniqueArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppConfigFindUniqueArgs>(args: SelectSubset<T, AppConfigFindUniqueArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppConfigFindUniqueOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AppConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppConfigFindFirstArgs>(args?: SelectSubset<T, AppConfigFindFirstArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AppConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppConfigs
     * const appConfigs = await prisma.appConfig.findMany()
     * 
     * // Get first 10 AppConfigs
     * const appConfigs = await prisma.appConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppConfigFindManyArgs>(args?: SelectSubset<T, AppConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppConfig.
     * @param {AppConfigCreateArgs} args - Arguments to create a AppConfig.
     * @example
     * // Create one AppConfig
     * const AppConfig = await prisma.appConfig.create({
     *   data: {
     *     // ... data to create a AppConfig
     *   }
     * })
     * 
     */
    create<T extends AppConfigCreateArgs>(args: SelectSubset<T, AppConfigCreateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppConfigs.
     * @param {AppConfigCreateManyArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppConfigCreateManyArgs>(args?: SelectSubset<T, AppConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppConfigs and returns the data saved in the database.
     * @param {AppConfigCreateManyAndReturnArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppConfigs and only return the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AppConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppConfig.
     * @param {AppConfigDeleteArgs} args - Arguments to delete one AppConfig.
     * @example
     * // Delete one AppConfig
     * const AppConfig = await prisma.appConfig.delete({
     *   where: {
     *     // ... filter to delete one AppConfig
     *   }
     * })
     * 
     */
    delete<T extends AppConfigDeleteArgs>(args: SelectSubset<T, AppConfigDeleteArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppConfig.
     * @param {AppConfigUpdateArgs} args - Arguments to update one AppConfig.
     * @example
     * // Update one AppConfig
     * const appConfig = await prisma.appConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppConfigUpdateArgs>(args: SelectSubset<T, AppConfigUpdateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppConfigs.
     * @param {AppConfigDeleteManyArgs} args - Arguments to filter AppConfigs to delete.
     * @example
     * // Delete a few AppConfigs
     * const { count } = await prisma.appConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppConfigDeleteManyArgs>(args?: SelectSubset<T, AppConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppConfigUpdateManyArgs>(args: SelectSubset<T, AppConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs and returns the data updated in the database.
     * @param {AppConfigUpdateManyAndReturnArgs} args - Arguments to update many AppConfigs.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppConfigs and only return the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AppConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppConfig.
     * @param {AppConfigUpsertArgs} args - Arguments to update or create a AppConfig.
     * @example
     * // Update or create a AppConfig
     * const appConfig = await prisma.appConfig.upsert({
     *   create: {
     *     // ... data to create a AppConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppConfig we want to update
     *   }
     * })
     */
    upsert<T extends AppConfigUpsertArgs>(args: SelectSubset<T, AppConfigUpsertArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigCountArgs} args - Arguments to filter AppConfigs to count.
     * @example
     * // Count the number of AppConfigs
     * const count = await prisma.appConfig.count({
     *   where: {
     *     // ... the filter for the AppConfigs we want to count
     *   }
     * })
    **/
    count<T extends AppConfigCountArgs>(
      args?: Subset<T, AppConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppConfigAggregateArgs>(args: Subset<T, AppConfigAggregateArgs>): Prisma.PrismaPromise<GetAppConfigAggregateType<T>>

    /**
     * Group by AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppConfigGroupByArgs['orderBy'] }
        : { orderBy?: AppConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppConfig model
   */
  readonly fields: AppConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppConfig model
   */
  interface AppConfigFieldRefs {
    readonly id: FieldRef<"AppConfig", 'String'>
    readonly frontendUrl: FieldRef<"AppConfig", 'String'>
    readonly backendUrl: FieldRef<"AppConfig", 'String'>
    readonly createdAt: FieldRef<"AppConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"AppConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppConfig findUnique
   */
  export type AppConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findUniqueOrThrow
   */
  export type AppConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findFirst
   */
  export type AppConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findFirstOrThrow
   */
  export type AppConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findMany
   */
  export type AppConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter, which AppConfigs to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig create
   */
  export type AppConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a AppConfig.
     */
    data: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
  }

  /**
   * AppConfig createMany
   */
  export type AppConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig createManyAndReturn
   */
  export type AppConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig update
   */
  export type AppConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a AppConfig.
     */
    data: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
    /**
     * Choose, which AppConfig to update.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig updateMany
   */
  export type AppConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to update.
     */
    limit?: number
  }

  /**
   * AppConfig updateManyAndReturn
   */
  export type AppConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to update.
     */
    limit?: number
  }

  /**
   * AppConfig upsert
   */
  export type AppConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the AppConfig to update in case it exists.
     */
    where: AppConfigWhereUniqueInput
    /**
     * In case the AppConfig found by the `where` argument doesn't exist, create a new AppConfig with this data.
     */
    create: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
    /**
     * In case the AppConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
  }

  /**
   * AppConfig delete
   */
  export type AppConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Filter which AppConfig to delete.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig deleteMany
   */
  export type AppConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfigs to delete
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to delete.
     */
    limit?: number
  }

  /**
   * AppConfig without action
   */
  export type AppConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
  }


  /**
   * Model FileMetadata
   */

  export type AggregateFileMetadata = {
    _count: FileMetadataCountAggregateOutputType | null
    _avg: FileMetadataAvgAggregateOutputType | null
    _sum: FileMetadataSumAggregateOutputType | null
    _min: FileMetadataMinAggregateOutputType | null
    _max: FileMetadataMaxAggregateOutputType | null
  }

  export type FileMetadataAvgAggregateOutputType = {
    id: number | null
    fileSize: number | null
  }

  export type FileMetadataSumAggregateOutputType = {
    id: number | null
    fileSize: number | null
  }

  export type FileMetadataMinAggregateOutputType = {
    id: number | null
    path: string | null
    fileName: string | null
    mimeType: string | null
    fileSize: number | null
    storageType: string | null
    iv: string | null
    isSensitive: boolean | null
    createdAt: Date | null
    participantSimAId: string | null
    participantSimBId: string | null
    participantKtpId: string | null
    participantFotoId: string | null
    participantSuratSehatButaWarnaId: string | null
    participantSuratBebasNarkobaId: string | null
    participantQrCodeId: string | null
  }

  export type FileMetadataMaxAggregateOutputType = {
    id: number | null
    path: string | null
    fileName: string | null
    mimeType: string | null
    fileSize: number | null
    storageType: string | null
    iv: string | null
    isSensitive: boolean | null
    createdAt: Date | null
    participantSimAId: string | null
    participantSimBId: string | null
    participantKtpId: string | null
    participantFotoId: string | null
    participantSuratSehatButaWarnaId: string | null
    participantSuratBebasNarkobaId: string | null
    participantQrCodeId: string | null
  }

  export type FileMetadataCountAggregateOutputType = {
    id: number
    path: number
    fileName: number
    mimeType: number
    fileSize: number
    storageType: number
    iv: number
    isSensitive: number
    createdAt: number
    participantSimAId: number
    participantSimBId: number
    participantKtpId: number
    participantFotoId: number
    participantSuratSehatButaWarnaId: number
    participantSuratBebasNarkobaId: number
    participantQrCodeId: number
    _all: number
  }


  export type FileMetadataAvgAggregateInputType = {
    id?: true
    fileSize?: true
  }

  export type FileMetadataSumAggregateInputType = {
    id?: true
    fileSize?: true
  }

  export type FileMetadataMinAggregateInputType = {
    id?: true
    path?: true
    fileName?: true
    mimeType?: true
    fileSize?: true
    storageType?: true
    iv?: true
    isSensitive?: true
    createdAt?: true
    participantSimAId?: true
    participantSimBId?: true
    participantKtpId?: true
    participantFotoId?: true
    participantSuratSehatButaWarnaId?: true
    participantSuratBebasNarkobaId?: true
    participantQrCodeId?: true
  }

  export type FileMetadataMaxAggregateInputType = {
    id?: true
    path?: true
    fileName?: true
    mimeType?: true
    fileSize?: true
    storageType?: true
    iv?: true
    isSensitive?: true
    createdAt?: true
    participantSimAId?: true
    participantSimBId?: true
    participantKtpId?: true
    participantFotoId?: true
    participantSuratSehatButaWarnaId?: true
    participantSuratBebasNarkobaId?: true
    participantQrCodeId?: true
  }

  export type FileMetadataCountAggregateInputType = {
    id?: true
    path?: true
    fileName?: true
    mimeType?: true
    fileSize?: true
    storageType?: true
    iv?: true
    isSensitive?: true
    createdAt?: true
    participantSimAId?: true
    participantSimBId?: true
    participantKtpId?: true
    participantFotoId?: true
    participantSuratSehatButaWarnaId?: true
    participantSuratBebasNarkobaId?: true
    participantQrCodeId?: true
    _all?: true
  }

  export type FileMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileMetadata to aggregate.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileMetadata
    **/
    _count?: true | FileMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMetadataMaxAggregateInputType
  }

  export type GetFileMetadataAggregateType<T extends FileMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateFileMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileMetadata[P]>
      : GetScalarType<T[P], AggregateFileMetadata[P]>
  }




  export type FileMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithAggregationInput | FileMetadataOrderByWithAggregationInput[]
    by: FileMetadataScalarFieldEnum[] | FileMetadataScalarFieldEnum
    having?: FileMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileMetadataCountAggregateInputType | true
    _avg?: FileMetadataAvgAggregateInputType
    _sum?: FileMetadataSumAggregateInputType
    _min?: FileMetadataMinAggregateInputType
    _max?: FileMetadataMaxAggregateInputType
  }

  export type FileMetadataGroupByOutputType = {
    id: number
    path: string
    fileName: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv: string | null
    isSensitive: boolean
    createdAt: Date
    participantSimAId: string | null
    participantSimBId: string | null
    participantKtpId: string | null
    participantFotoId: string | null
    participantSuratSehatButaWarnaId: string | null
    participantSuratBebasNarkobaId: string | null
    participantQrCodeId: string | null
    _count: FileMetadataCountAggregateOutputType | null
    _avg: FileMetadataAvgAggregateOutputType | null
    _sum: FileMetadataSumAggregateOutputType | null
    _min: FileMetadataMinAggregateOutputType | null
    _max: FileMetadataMaxAggregateOutputType | null
  }

  type GetFileMetadataGroupByPayload<T extends FileMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], FileMetadataGroupByOutputType[P]>
        }
      >
    >


  export type FileMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    fileName?: boolean
    mimeType?: boolean
    fileSize?: boolean
    storageType?: boolean
    iv?: boolean
    isSensitive?: boolean
    createdAt?: boolean
    participantSimAId?: boolean
    participantSimBId?: boolean
    participantKtpId?: boolean
    participantFotoId?: boolean
    participantSuratSehatButaWarnaId?: boolean
    participantSuratBebasNarkobaId?: boolean
    participantQrCodeId?: boolean
    participantSimA?: boolean | FileMetadata$participantSimAArgs<ExtArgs>
    participantSimB?: boolean | FileMetadata$participantSimBArgs<ExtArgs>
    participantKtp?: boolean | FileMetadata$participantKtpArgs<ExtArgs>
    participantFoto?: boolean | FileMetadata$participantFotoArgs<ExtArgs>
    participantSuratSehatButaWarna?: boolean | FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs>
    participantSuratBebasNarkoba?: boolean | FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs>
    participantQrCode?: boolean | FileMetadata$participantQrCodeArgs<ExtArgs>
    signatureESign?: boolean | FileMetadata$signatureESignArgs<ExtArgs>
  }, ExtArgs["result"]["fileMetadata"]>

  export type FileMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    fileName?: boolean
    mimeType?: boolean
    fileSize?: boolean
    storageType?: boolean
    iv?: boolean
    isSensitive?: boolean
    createdAt?: boolean
    participantSimAId?: boolean
    participantSimBId?: boolean
    participantKtpId?: boolean
    participantFotoId?: boolean
    participantSuratSehatButaWarnaId?: boolean
    participantSuratBebasNarkobaId?: boolean
    participantQrCodeId?: boolean
    participantSimA?: boolean | FileMetadata$participantSimAArgs<ExtArgs>
    participantSimB?: boolean | FileMetadata$participantSimBArgs<ExtArgs>
    participantKtp?: boolean | FileMetadata$participantKtpArgs<ExtArgs>
    participantFoto?: boolean | FileMetadata$participantFotoArgs<ExtArgs>
    participantSuratSehatButaWarna?: boolean | FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs>
    participantSuratBebasNarkoba?: boolean | FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs>
    participantQrCode?: boolean | FileMetadata$participantQrCodeArgs<ExtArgs>
  }, ExtArgs["result"]["fileMetadata"]>

  export type FileMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    fileName?: boolean
    mimeType?: boolean
    fileSize?: boolean
    storageType?: boolean
    iv?: boolean
    isSensitive?: boolean
    createdAt?: boolean
    participantSimAId?: boolean
    participantSimBId?: boolean
    participantKtpId?: boolean
    participantFotoId?: boolean
    participantSuratSehatButaWarnaId?: boolean
    participantSuratBebasNarkobaId?: boolean
    participantQrCodeId?: boolean
    participantSimA?: boolean | FileMetadata$participantSimAArgs<ExtArgs>
    participantSimB?: boolean | FileMetadata$participantSimBArgs<ExtArgs>
    participantKtp?: boolean | FileMetadata$participantKtpArgs<ExtArgs>
    participantFoto?: boolean | FileMetadata$participantFotoArgs<ExtArgs>
    participantSuratSehatButaWarna?: boolean | FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs>
    participantSuratBebasNarkoba?: boolean | FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs>
    participantQrCode?: boolean | FileMetadata$participantQrCodeArgs<ExtArgs>
  }, ExtArgs["result"]["fileMetadata"]>

  export type FileMetadataSelectScalar = {
    id?: boolean
    path?: boolean
    fileName?: boolean
    mimeType?: boolean
    fileSize?: boolean
    storageType?: boolean
    iv?: boolean
    isSensitive?: boolean
    createdAt?: boolean
    participantSimAId?: boolean
    participantSimBId?: boolean
    participantKtpId?: boolean
    participantFotoId?: boolean
    participantSuratSehatButaWarnaId?: boolean
    participantSuratBebasNarkobaId?: boolean
    participantQrCodeId?: boolean
  }

  export type FileMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "path" | "fileName" | "mimeType" | "fileSize" | "storageType" | "iv" | "isSensitive" | "createdAt" | "participantSimAId" | "participantSimBId" | "participantKtpId" | "participantFotoId" | "participantSuratSehatButaWarnaId" | "participantSuratBebasNarkobaId" | "participantQrCodeId", ExtArgs["result"]["fileMetadata"]>
  export type FileMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participantSimA?: boolean | FileMetadata$participantSimAArgs<ExtArgs>
    participantSimB?: boolean | FileMetadata$participantSimBArgs<ExtArgs>
    participantKtp?: boolean | FileMetadata$participantKtpArgs<ExtArgs>
    participantFoto?: boolean | FileMetadata$participantFotoArgs<ExtArgs>
    participantSuratSehatButaWarna?: boolean | FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs>
    participantSuratBebasNarkoba?: boolean | FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs>
    participantQrCode?: boolean | FileMetadata$participantQrCodeArgs<ExtArgs>
    signatureESign?: boolean | FileMetadata$signatureESignArgs<ExtArgs>
  }
  export type FileMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participantSimA?: boolean | FileMetadata$participantSimAArgs<ExtArgs>
    participantSimB?: boolean | FileMetadata$participantSimBArgs<ExtArgs>
    participantKtp?: boolean | FileMetadata$participantKtpArgs<ExtArgs>
    participantFoto?: boolean | FileMetadata$participantFotoArgs<ExtArgs>
    participantSuratSehatButaWarna?: boolean | FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs>
    participantSuratBebasNarkoba?: boolean | FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs>
    participantQrCode?: boolean | FileMetadata$participantQrCodeArgs<ExtArgs>
  }
  export type FileMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participantSimA?: boolean | FileMetadata$participantSimAArgs<ExtArgs>
    participantSimB?: boolean | FileMetadata$participantSimBArgs<ExtArgs>
    participantKtp?: boolean | FileMetadata$participantKtpArgs<ExtArgs>
    participantFoto?: boolean | FileMetadata$participantFotoArgs<ExtArgs>
    participantSuratSehatButaWarna?: boolean | FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs>
    participantSuratBebasNarkoba?: boolean | FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs>
    participantQrCode?: boolean | FileMetadata$participantQrCodeArgs<ExtArgs>
  }

  export type $FileMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileMetadata"
    objects: {
      participantSimA: Prisma.$ParticipantPayload<ExtArgs> | null
      participantSimB: Prisma.$ParticipantPayload<ExtArgs> | null
      participantKtp: Prisma.$ParticipantPayload<ExtArgs> | null
      participantFoto: Prisma.$ParticipantPayload<ExtArgs> | null
      participantSuratSehatButaWarna: Prisma.$ParticipantPayload<ExtArgs> | null
      participantSuratBebasNarkoba: Prisma.$ParticipantPayload<ExtArgs> | null
      participantQrCode: Prisma.$ParticipantPayload<ExtArgs> | null
      signatureESign: Prisma.$SignaturePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      path: string
      fileName: string | null
      mimeType: string
      fileSize: number
      storageType: string
      iv: string | null
      isSensitive: boolean
      createdAt: Date
      participantSimAId: string | null
      participantSimBId: string | null
      participantKtpId: string | null
      participantFotoId: string | null
      participantSuratSehatButaWarnaId: string | null
      participantSuratBebasNarkobaId: string | null
      participantQrCodeId: string | null
    }, ExtArgs["result"]["fileMetadata"]>
    composites: {}
  }

  type FileMetadataGetPayload<S extends boolean | null | undefined | FileMetadataDefaultArgs> = $Result.GetResult<Prisma.$FileMetadataPayload, S>

  type FileMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileMetadataCountAggregateInputType | true
    }

  export interface FileMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileMetadata'], meta: { name: 'FileMetadata' } }
    /**
     * Find zero or one FileMetadata that matches the filter.
     * @param {FileMetadataFindUniqueArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileMetadataFindUniqueArgs>(args: SelectSubset<T, FileMetadataFindUniqueArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileMetadataFindUniqueOrThrowArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, FileMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataFindFirstArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileMetadataFindFirstArgs>(args?: SelectSubset<T, FileMetadataFindFirstArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataFindFirstOrThrowArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, FileMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findMany()
     * 
     * // Get first 10 FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileMetadataWithIdOnly = await prisma.fileMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileMetadataFindManyArgs>(args?: SelectSubset<T, FileMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileMetadata.
     * @param {FileMetadataCreateArgs} args - Arguments to create a FileMetadata.
     * @example
     * // Create one FileMetadata
     * const FileMetadata = await prisma.fileMetadata.create({
     *   data: {
     *     // ... data to create a FileMetadata
     *   }
     * })
     * 
     */
    create<T extends FileMetadataCreateArgs>(args: SelectSubset<T, FileMetadataCreateArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileMetadata.
     * @param {FileMetadataCreateManyArgs} args - Arguments to create many FileMetadata.
     * @example
     * // Create many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileMetadataCreateManyArgs>(args?: SelectSubset<T, FileMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileMetadata and returns the data saved in the database.
     * @param {FileMetadataCreateManyAndReturnArgs} args - Arguments to create many FileMetadata.
     * @example
     * // Create many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileMetadata and only return the `id`
     * const fileMetadataWithIdOnly = await prisma.fileMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, FileMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileMetadata.
     * @param {FileMetadataDeleteArgs} args - Arguments to delete one FileMetadata.
     * @example
     * // Delete one FileMetadata
     * const FileMetadata = await prisma.fileMetadata.delete({
     *   where: {
     *     // ... filter to delete one FileMetadata
     *   }
     * })
     * 
     */
    delete<T extends FileMetadataDeleteArgs>(args: SelectSubset<T, FileMetadataDeleteArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileMetadata.
     * @param {FileMetadataUpdateArgs} args - Arguments to update one FileMetadata.
     * @example
     * // Update one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileMetadataUpdateArgs>(args: SelectSubset<T, FileMetadataUpdateArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileMetadata.
     * @param {FileMetadataDeleteManyArgs} args - Arguments to filter FileMetadata to delete.
     * @example
     * // Delete a few FileMetadata
     * const { count } = await prisma.fileMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileMetadataDeleteManyArgs>(args?: SelectSubset<T, FileMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileMetadataUpdateManyArgs>(args: SelectSubset<T, FileMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileMetadata and returns the data updated in the database.
     * @param {FileMetadataUpdateManyAndReturnArgs} args - Arguments to update many FileMetadata.
     * @example
     * // Update many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileMetadata and only return the `id`
     * const fileMetadataWithIdOnly = await prisma.fileMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, FileMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileMetadata.
     * @param {FileMetadataUpsertArgs} args - Arguments to update or create a FileMetadata.
     * @example
     * // Update or create a FileMetadata
     * const fileMetadata = await prisma.fileMetadata.upsert({
     *   create: {
     *     // ... data to create a FileMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileMetadata we want to update
     *   }
     * })
     */
    upsert<T extends FileMetadataUpsertArgs>(args: SelectSubset<T, FileMetadataUpsertArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataCountArgs} args - Arguments to filter FileMetadata to count.
     * @example
     * // Count the number of FileMetadata
     * const count = await prisma.fileMetadata.count({
     *   where: {
     *     // ... the filter for the FileMetadata we want to count
     *   }
     * })
    **/
    count<T extends FileMetadataCountArgs>(
      args?: Subset<T, FileMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileMetadataAggregateArgs>(args: Subset<T, FileMetadataAggregateArgs>): Prisma.PrismaPromise<GetFileMetadataAggregateType<T>>

    /**
     * Group by FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileMetadataGroupByArgs['orderBy'] }
        : { orderBy?: FileMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileMetadata model
   */
  readonly fields: FileMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participantSimA<T extends FileMetadata$participantSimAArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$participantSimAArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participantSimB<T extends FileMetadata$participantSimBArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$participantSimBArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participantKtp<T extends FileMetadata$participantKtpArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$participantKtpArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participantFoto<T extends FileMetadata$participantFotoArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$participantFotoArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participantSuratSehatButaWarna<T extends FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participantSuratBebasNarkoba<T extends FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participantQrCode<T extends FileMetadata$participantQrCodeArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$participantQrCodeArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    signatureESign<T extends FileMetadata$signatureESignArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$signatureESignArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileMetadata model
   */
  interface FileMetadataFieldRefs {
    readonly id: FieldRef<"FileMetadata", 'Int'>
    readonly path: FieldRef<"FileMetadata", 'String'>
    readonly fileName: FieldRef<"FileMetadata", 'String'>
    readonly mimeType: FieldRef<"FileMetadata", 'String'>
    readonly fileSize: FieldRef<"FileMetadata", 'Int'>
    readonly storageType: FieldRef<"FileMetadata", 'String'>
    readonly iv: FieldRef<"FileMetadata", 'String'>
    readonly isSensitive: FieldRef<"FileMetadata", 'Boolean'>
    readonly createdAt: FieldRef<"FileMetadata", 'DateTime'>
    readonly participantSimAId: FieldRef<"FileMetadata", 'String'>
    readonly participantSimBId: FieldRef<"FileMetadata", 'String'>
    readonly participantKtpId: FieldRef<"FileMetadata", 'String'>
    readonly participantFotoId: FieldRef<"FileMetadata", 'String'>
    readonly participantSuratSehatButaWarnaId: FieldRef<"FileMetadata", 'String'>
    readonly participantSuratBebasNarkobaId: FieldRef<"FileMetadata", 'String'>
    readonly participantQrCodeId: FieldRef<"FileMetadata", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FileMetadata findUnique
   */
  export type FileMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata findUniqueOrThrow
   */
  export type FileMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata findFirst
   */
  export type FileMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileMetadata.
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileMetadata.
     */
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * FileMetadata findFirstOrThrow
   */
  export type FileMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileMetadata.
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileMetadata.
     */
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * FileMetadata findMany
   */
  export type FileMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileMetadata.
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * FileMetadata create
   */
  export type FileMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a FileMetadata.
     */
    data: XOR<FileMetadataCreateInput, FileMetadataUncheckedCreateInput>
  }

  /**
   * FileMetadata createMany
   */
  export type FileMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileMetadata.
     */
    data: FileMetadataCreateManyInput | FileMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileMetadata createManyAndReturn
   */
  export type FileMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many FileMetadata.
     */
    data: FileMetadataCreateManyInput | FileMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileMetadata update
   */
  export type FileMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a FileMetadata.
     */
    data: XOR<FileMetadataUpdateInput, FileMetadataUncheckedUpdateInput>
    /**
     * Choose, which FileMetadata to update.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata updateMany
   */
  export type FileMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileMetadata.
     */
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyInput>
    /**
     * Filter which FileMetadata to update
     */
    where?: FileMetadataWhereInput
    /**
     * Limit how many FileMetadata to update.
     */
    limit?: number
  }

  /**
   * FileMetadata updateManyAndReturn
   */
  export type FileMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * The data used to update FileMetadata.
     */
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyInput>
    /**
     * Filter which FileMetadata to update
     */
    where?: FileMetadataWhereInput
    /**
     * Limit how many FileMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileMetadata upsert
   */
  export type FileMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the FileMetadata to update in case it exists.
     */
    where: FileMetadataWhereUniqueInput
    /**
     * In case the FileMetadata found by the `where` argument doesn't exist, create a new FileMetadata with this data.
     */
    create: XOR<FileMetadataCreateInput, FileMetadataUncheckedCreateInput>
    /**
     * In case the FileMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileMetadataUpdateInput, FileMetadataUncheckedUpdateInput>
  }

  /**
   * FileMetadata delete
   */
  export type FileMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter which FileMetadata to delete.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata deleteMany
   */
  export type FileMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileMetadata to delete
     */
    where?: FileMetadataWhereInput
    /**
     * Limit how many FileMetadata to delete.
     */
    limit?: number
  }

  /**
   * FileMetadata.participantSimA
   */
  export type FileMetadata$participantSimAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * FileMetadata.participantSimB
   */
  export type FileMetadata$participantSimBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * FileMetadata.participantKtp
   */
  export type FileMetadata$participantKtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * FileMetadata.participantFoto
   */
  export type FileMetadata$participantFotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * FileMetadata.participantSuratSehatButaWarna
   */
  export type FileMetadata$participantSuratSehatButaWarnaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * FileMetadata.participantSuratBebasNarkoba
   */
  export type FileMetadata$participantSuratBebasNarkobaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * FileMetadata.participantQrCode
   */
  export type FileMetadata$participantQrCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * FileMetadata.signatureESign
   */
  export type FileMetadata$signatureESignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    where?: SignatureWhereInput
  }

  /**
   * FileMetadata without action
   */
  export type FileMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
  }


  /**
   * Model Participant
   */

  export type AggregateParticipant = {
    _count: ParticipantCountAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  export type ParticipantMinAggregateOutputType = {
    id: string | null
    idNumber: string | null
    name: string | null
    nik: string | null
    dinas: string | null
    bidang: string | null
    company: string | null
    email: string | null
    phoneNumber: string | null
    nationality: string | null
    placeOfBirth: string | null
    dateOfBirth: Date | null
    qrCodeLink: string | null
    tglKeluarSuratSehatButaWarna: Date | null
    tglKeluarSuratBebasNarkoba: Date | null
    gmfNonGmf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipantMaxAggregateOutputType = {
    id: string | null
    idNumber: string | null
    name: string | null
    nik: string | null
    dinas: string | null
    bidang: string | null
    company: string | null
    email: string | null
    phoneNumber: string | null
    nationality: string | null
    placeOfBirth: string | null
    dateOfBirth: Date | null
    qrCodeLink: string | null
    tglKeluarSuratSehatButaWarna: Date | null
    tglKeluarSuratBebasNarkoba: Date | null
    gmfNonGmf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipantCountAggregateOutputType = {
    id: number
    idNumber: number
    name: number
    nik: number
    dinas: number
    bidang: number
    company: number
    email: number
    phoneNumber: number
    nationality: number
    placeOfBirth: number
    dateOfBirth: number
    qrCodeLink: number
    tglKeluarSuratSehatButaWarna: number
    tglKeluarSuratBebasNarkoba: number
    gmfNonGmf: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParticipantMinAggregateInputType = {
    id?: true
    idNumber?: true
    name?: true
    nik?: true
    dinas?: true
    bidang?: true
    company?: true
    email?: true
    phoneNumber?: true
    nationality?: true
    placeOfBirth?: true
    dateOfBirth?: true
    qrCodeLink?: true
    tglKeluarSuratSehatButaWarna?: true
    tglKeluarSuratBebasNarkoba?: true
    gmfNonGmf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipantMaxAggregateInputType = {
    id?: true
    idNumber?: true
    name?: true
    nik?: true
    dinas?: true
    bidang?: true
    company?: true
    email?: true
    phoneNumber?: true
    nationality?: true
    placeOfBirth?: true
    dateOfBirth?: true
    qrCodeLink?: true
    tglKeluarSuratSehatButaWarna?: true
    tglKeluarSuratBebasNarkoba?: true
    gmfNonGmf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipantCountAggregateInputType = {
    id?: true
    idNumber?: true
    name?: true
    nik?: true
    dinas?: true
    bidang?: true
    company?: true
    email?: true
    phoneNumber?: true
    nationality?: true
    placeOfBirth?: true
    dateOfBirth?: true
    qrCodeLink?: true
    tglKeluarSuratSehatButaWarna?: true
    tglKeluarSuratBebasNarkoba?: true
    gmfNonGmf?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participant to aggregate.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Participants
    **/
    _count?: true | ParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipantMaxAggregateInputType
  }

  export type GetParticipantAggregateType<T extends ParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipant[P]>
      : GetScalarType<T[P], AggregateParticipant[P]>
  }




  export type ParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantWhereInput
    orderBy?: ParticipantOrderByWithAggregationInput | ParticipantOrderByWithAggregationInput[]
    by: ParticipantScalarFieldEnum[] | ParticipantScalarFieldEnum
    having?: ParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipantCountAggregateInputType | true
    _min?: ParticipantMinAggregateInputType
    _max?: ParticipantMaxAggregateInputType
  }

  export type ParticipantGroupByOutputType = {
    id: string
    idNumber: string | null
    name: string
    nik: string
    dinas: string | null
    bidang: string | null
    company: string | null
    email: string
    phoneNumber: string | null
    nationality: string | null
    placeOfBirth: string | null
    dateOfBirth: Date | null
    qrCodeLink: string | null
    tglKeluarSuratSehatButaWarna: Date | null
    tglKeluarSuratBebasNarkoba: Date | null
    gmfNonGmf: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParticipantCountAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  type GetParticipantGroupByPayload<T extends ParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    bidang?: boolean
    company?: boolean
    email?: boolean
    phoneNumber?: boolean
    nationality?: boolean
    placeOfBirth?: boolean
    dateOfBirth?: boolean
    qrCodeLink?: boolean
    tglKeluarSuratSehatButaWarna?: boolean
    tglKeluarSuratBebasNarkoba?: boolean
    gmfNonGmf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    simA?: boolean | Participant$simAArgs<ExtArgs>
    simB?: boolean | Participant$simBArgs<ExtArgs>
    ktp?: boolean | Participant$ktpArgs<ExtArgs>
    foto?: boolean | Participant$fotoArgs<ExtArgs>
    suratSehatButaWarna?: boolean | Participant$suratSehatButaWarnaArgs<ExtArgs>
    suratBebasNarkoba?: boolean | Participant$suratBebasNarkobaArgs<ExtArgs>
    qrCode?: boolean | Participant$qrCodeArgs<ExtArgs>
    participantsCots?: boolean | Participant$participantsCotsArgs<ExtArgs>
    user?: boolean | Participant$userArgs<ExtArgs>
    certificates?: boolean | Participant$certificatesArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    bidang?: boolean
    company?: boolean
    email?: boolean
    phoneNumber?: boolean
    nationality?: boolean
    placeOfBirth?: boolean
    dateOfBirth?: boolean
    qrCodeLink?: boolean
    tglKeluarSuratSehatButaWarna?: boolean
    tglKeluarSuratBebasNarkoba?: boolean
    gmfNonGmf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    bidang?: boolean
    company?: boolean
    email?: boolean
    phoneNumber?: boolean
    nationality?: boolean
    placeOfBirth?: boolean
    dateOfBirth?: boolean
    qrCodeLink?: boolean
    tglKeluarSuratSehatButaWarna?: boolean
    tglKeluarSuratBebasNarkoba?: boolean
    gmfNonGmf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectScalar = {
    id?: boolean
    idNumber?: boolean
    name?: boolean
    nik?: boolean
    dinas?: boolean
    bidang?: boolean
    company?: boolean
    email?: boolean
    phoneNumber?: boolean
    nationality?: boolean
    placeOfBirth?: boolean
    dateOfBirth?: boolean
    qrCodeLink?: boolean
    tglKeluarSuratSehatButaWarna?: boolean
    tglKeluarSuratBebasNarkoba?: boolean
    gmfNonGmf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idNumber" | "name" | "nik" | "dinas" | "bidang" | "company" | "email" | "phoneNumber" | "nationality" | "placeOfBirth" | "dateOfBirth" | "qrCodeLink" | "tglKeluarSuratSehatButaWarna" | "tglKeluarSuratBebasNarkoba" | "gmfNonGmf" | "createdAt" | "updatedAt", ExtArgs["result"]["participant"]>
  export type ParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simA?: boolean | Participant$simAArgs<ExtArgs>
    simB?: boolean | Participant$simBArgs<ExtArgs>
    ktp?: boolean | Participant$ktpArgs<ExtArgs>
    foto?: boolean | Participant$fotoArgs<ExtArgs>
    suratSehatButaWarna?: boolean | Participant$suratSehatButaWarnaArgs<ExtArgs>
    suratBebasNarkoba?: boolean | Participant$suratBebasNarkobaArgs<ExtArgs>
    qrCode?: boolean | Participant$qrCodeArgs<ExtArgs>
    participantsCots?: boolean | Participant$participantsCotsArgs<ExtArgs>
    user?: boolean | Participant$userArgs<ExtArgs>
    certificates?: boolean | Participant$certificatesArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Participant"
    objects: {
      simA: Prisma.$FileMetadataPayload<ExtArgs>[]
      simB: Prisma.$FileMetadataPayload<ExtArgs>[]
      ktp: Prisma.$FileMetadataPayload<ExtArgs>[]
      foto: Prisma.$FileMetadataPayload<ExtArgs>[]
      suratSehatButaWarna: Prisma.$FileMetadataPayload<ExtArgs>[]
      suratBebasNarkoba: Prisma.$FileMetadataPayload<ExtArgs>[]
      qrCode: Prisma.$FileMetadataPayload<ExtArgs>[]
      participantsCots: Prisma.$ParticipantsCOTPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idNumber: string | null
      name: string
      nik: string
      dinas: string | null
      bidang: string | null
      company: string | null
      email: string
      phoneNumber: string | null
      nationality: string | null
      placeOfBirth: string | null
      dateOfBirth: Date | null
      qrCodeLink: string | null
      tglKeluarSuratSehatButaWarna: Date | null
      tglKeluarSuratBebasNarkoba: Date | null
      gmfNonGmf: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["participant"]>
    composites: {}
  }

  type ParticipantGetPayload<S extends boolean | null | undefined | ParticipantDefaultArgs> = $Result.GetResult<Prisma.$ParticipantPayload, S>

  type ParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParticipantCountAggregateInputType | true
    }

  export interface ParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Participant'], meta: { name: 'Participant' } }
    /**
     * Find zero or one Participant that matches the filter.
     * @param {ParticipantFindUniqueArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParticipantFindUniqueArgs>(args: SelectSubset<T, ParticipantFindUniqueArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Participant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParticipantFindUniqueOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParticipantFindFirstArgs>(args?: SelectSubset<T, ParticipantFindFirstArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participants
     * const participants = await prisma.participant.findMany()
     * 
     * // Get first 10 Participants
     * const participants = await prisma.participant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participantWithIdOnly = await prisma.participant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParticipantFindManyArgs>(args?: SelectSubset<T, ParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Participant.
     * @param {ParticipantCreateArgs} args - Arguments to create a Participant.
     * @example
     * // Create one Participant
     * const Participant = await prisma.participant.create({
     *   data: {
     *     // ... data to create a Participant
     *   }
     * })
     * 
     */
    create<T extends ParticipantCreateArgs>(args: SelectSubset<T, ParticipantCreateArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Participants.
     * @param {ParticipantCreateManyArgs} args - Arguments to create many Participants.
     * @example
     * // Create many Participants
     * const participant = await prisma.participant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParticipantCreateManyArgs>(args?: SelectSubset<T, ParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Participants and returns the data saved in the database.
     * @param {ParticipantCreateManyAndReturnArgs} args - Arguments to create many Participants.
     * @example
     * // Create many Participants
     * const participant = await prisma.participant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Participants and only return the `id`
     * const participantWithIdOnly = await prisma.participant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Participant.
     * @param {ParticipantDeleteArgs} args - Arguments to delete one Participant.
     * @example
     * // Delete one Participant
     * const Participant = await prisma.participant.delete({
     *   where: {
     *     // ... filter to delete one Participant
     *   }
     * })
     * 
     */
    delete<T extends ParticipantDeleteArgs>(args: SelectSubset<T, ParticipantDeleteArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Participant.
     * @param {ParticipantUpdateArgs} args - Arguments to update one Participant.
     * @example
     * // Update one Participant
     * const participant = await prisma.participant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParticipantUpdateArgs>(args: SelectSubset<T, ParticipantUpdateArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Participants.
     * @param {ParticipantDeleteManyArgs} args - Arguments to filter Participants to delete.
     * @example
     * // Delete a few Participants
     * const { count } = await prisma.participant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParticipantDeleteManyArgs>(args?: SelectSubset<T, ParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParticipantUpdateManyArgs>(args: SelectSubset<T, ParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants and returns the data updated in the database.
     * @param {ParticipantUpdateManyAndReturnArgs} args - Arguments to update many Participants.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Participants and only return the `id`
     * const participantWithIdOnly = await prisma.participant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Participant.
     * @param {ParticipantUpsertArgs} args - Arguments to update or create a Participant.
     * @example
     * // Update or create a Participant
     * const participant = await prisma.participant.upsert({
     *   create: {
     *     // ... data to create a Participant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participant we want to update
     *   }
     * })
     */
    upsert<T extends ParticipantUpsertArgs>(args: SelectSubset<T, ParticipantUpsertArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantCountArgs} args - Arguments to filter Participants to count.
     * @example
     * // Count the number of Participants
     * const count = await prisma.participant.count({
     *   where: {
     *     // ... the filter for the Participants we want to count
     *   }
     * })
    **/
    count<T extends ParticipantCountArgs>(
      args?: Subset<T, ParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipantAggregateArgs>(args: Subset<T, ParticipantAggregateArgs>): Prisma.PrismaPromise<GetParticipantAggregateType<T>>

    /**
     * Group by Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Participant model
   */
  readonly fields: ParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Participant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simA<T extends Participant$simAArgs<ExtArgs> = {}>(args?: Subset<T, Participant$simAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    simB<T extends Participant$simBArgs<ExtArgs> = {}>(args?: Subset<T, Participant$simBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ktp<T extends Participant$ktpArgs<ExtArgs> = {}>(args?: Subset<T, Participant$ktpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    foto<T extends Participant$fotoArgs<ExtArgs> = {}>(args?: Subset<T, Participant$fotoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suratSehatButaWarna<T extends Participant$suratSehatButaWarnaArgs<ExtArgs> = {}>(args?: Subset<T, Participant$suratSehatButaWarnaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suratBebasNarkoba<T extends Participant$suratBebasNarkobaArgs<ExtArgs> = {}>(args?: Subset<T, Participant$suratBebasNarkobaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qrCode<T extends Participant$qrCodeArgs<ExtArgs> = {}>(args?: Subset<T, Participant$qrCodeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participantsCots<T extends Participant$participantsCotsArgs<ExtArgs> = {}>(args?: Subset<T, Participant$participantsCotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Participant$userArgs<ExtArgs> = {}>(args?: Subset<T, Participant$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    certificates<T extends Participant$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Participant$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Participant model
   */
  interface ParticipantFieldRefs {
    readonly id: FieldRef<"Participant", 'String'>
    readonly idNumber: FieldRef<"Participant", 'String'>
    readonly name: FieldRef<"Participant", 'String'>
    readonly nik: FieldRef<"Participant", 'String'>
    readonly dinas: FieldRef<"Participant", 'String'>
    readonly bidang: FieldRef<"Participant", 'String'>
    readonly company: FieldRef<"Participant", 'String'>
    readonly email: FieldRef<"Participant", 'String'>
    readonly phoneNumber: FieldRef<"Participant", 'String'>
    readonly nationality: FieldRef<"Participant", 'String'>
    readonly placeOfBirth: FieldRef<"Participant", 'String'>
    readonly dateOfBirth: FieldRef<"Participant", 'DateTime'>
    readonly qrCodeLink: FieldRef<"Participant", 'String'>
    readonly tglKeluarSuratSehatButaWarna: FieldRef<"Participant", 'DateTime'>
    readonly tglKeluarSuratBebasNarkoba: FieldRef<"Participant", 'DateTime'>
    readonly gmfNonGmf: FieldRef<"Participant", 'String'>
    readonly createdAt: FieldRef<"Participant", 'DateTime'>
    readonly updatedAt: FieldRef<"Participant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Participant findUnique
   */
  export type ParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant findUniqueOrThrow
   */
  export type ParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant findFirst
   */
  export type ParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant findFirstOrThrow
   */
  export type ParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant findMany
   */
  export type ParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participants to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant create
   */
  export type ParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a Participant.
     */
    data: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
  }

  /**
   * Participant createMany
   */
  export type ParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Participants.
     */
    data: ParticipantCreateManyInput | ParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Participant createManyAndReturn
   */
  export type ParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many Participants.
     */
    data: ParticipantCreateManyInput | ParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Participant update
   */
  export type ParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a Participant.
     */
    data: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
    /**
     * Choose, which Participant to update.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant updateMany
   */
  export type ParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to update.
     */
    limit?: number
  }

  /**
   * Participant updateManyAndReturn
   */
  export type ParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to update.
     */
    limit?: number
  }

  /**
   * Participant upsert
   */
  export type ParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the Participant to update in case it exists.
     */
    where: ParticipantWhereUniqueInput
    /**
     * In case the Participant found by the `where` argument doesn't exist, create a new Participant with this data.
     */
    create: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
    /**
     * In case the Participant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
  }

  /**
   * Participant delete
   */
  export type ParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter which Participant to delete.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant deleteMany
   */
  export type ParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participants to delete
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to delete.
     */
    limit?: number
  }

  /**
   * Participant.simA
   */
  export type Participant$simAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Participant.simB
   */
  export type Participant$simBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Participant.ktp
   */
  export type Participant$ktpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Participant.foto
   */
  export type Participant$fotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Participant.suratSehatButaWarna
   */
  export type Participant$suratSehatButaWarnaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Participant.suratBebasNarkoba
   */
  export type Participant$suratBebasNarkobaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Participant.qrCode
   */
  export type Participant$qrCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Participant.participantsCots
   */
  export type Participant$participantsCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    where?: ParticipantsCOTWhereInput
    orderBy?: ParticipantsCOTOrderByWithRelationInput | ParticipantsCOTOrderByWithRelationInput[]
    cursor?: ParticipantsCOTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipantsCOTScalarFieldEnum | ParticipantsCOTScalarFieldEnum[]
  }

  /**
   * Participant.user
   */
  export type Participant$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Participant.certificates
   */
  export type Participant$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Participant without action
   */
  export type ParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Capability
   */

  export type AggregateCapability = {
    _count: CapabilityCountAggregateOutputType | null
    _avg: CapabilityAvgAggregateOutputType | null
    _sum: CapabilitySumAggregateOutputType | null
    _min: CapabilityMinAggregateOutputType | null
    _max: CapabilityMaxAggregateOutputType | null
  }

  export type CapabilityAvgAggregateOutputType = {
    totalTheoryDurationRegGse: number | null
    totalPracticeDurationRegGse: number | null
    totalTheoryDurationCompetency: number | null
    totalPracticeDurationCompetency: number | null
    totalDuration: number | null
  }

  export type CapabilitySumAggregateOutputType = {
    totalTheoryDurationRegGse: number | null
    totalPracticeDurationRegGse: number | null
    totalTheoryDurationCompetency: number | null
    totalPracticeDurationCompetency: number | null
    totalDuration: number | null
  }

  export type CapabilityMinAggregateOutputType = {
    id: string | null
    ratingCode: string | null
    trainingCode: string | null
    trainingName: string | null
    totalTheoryDurationRegGse: number | null
    totalPracticeDurationRegGse: number | null
    totalTheoryDurationCompetency: number | null
    totalPracticeDurationCompetency: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapabilityMaxAggregateOutputType = {
    id: string | null
    ratingCode: string | null
    trainingCode: string | null
    trainingName: string | null
    totalTheoryDurationRegGse: number | null
    totalPracticeDurationRegGse: number | null
    totalTheoryDurationCompetency: number | null
    totalPracticeDurationCompetency: number | null
    totalDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapabilityCountAggregateOutputType = {
    id: number
    ratingCode: number
    trainingCode: number
    trainingName: number
    totalTheoryDurationRegGse: number
    totalPracticeDurationRegGse: number
    totalTheoryDurationCompetency: number
    totalPracticeDurationCompetency: number
    totalDuration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CapabilityAvgAggregateInputType = {
    totalTheoryDurationRegGse?: true
    totalPracticeDurationRegGse?: true
    totalTheoryDurationCompetency?: true
    totalPracticeDurationCompetency?: true
    totalDuration?: true
  }

  export type CapabilitySumAggregateInputType = {
    totalTheoryDurationRegGse?: true
    totalPracticeDurationRegGse?: true
    totalTheoryDurationCompetency?: true
    totalPracticeDurationCompetency?: true
    totalDuration?: true
  }

  export type CapabilityMinAggregateInputType = {
    id?: true
    ratingCode?: true
    trainingCode?: true
    trainingName?: true
    totalTheoryDurationRegGse?: true
    totalPracticeDurationRegGse?: true
    totalTheoryDurationCompetency?: true
    totalPracticeDurationCompetency?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapabilityMaxAggregateInputType = {
    id?: true
    ratingCode?: true
    trainingCode?: true
    trainingName?: true
    totalTheoryDurationRegGse?: true
    totalPracticeDurationRegGse?: true
    totalTheoryDurationCompetency?: true
    totalPracticeDurationCompetency?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapabilityCountAggregateInputType = {
    id?: true
    ratingCode?: true
    trainingCode?: true
    trainingName?: true
    totalTheoryDurationRegGse?: true
    totalPracticeDurationRegGse?: true
    totalTheoryDurationCompetency?: true
    totalPracticeDurationCompetency?: true
    totalDuration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Capability to aggregate.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Capabilities
    **/
    _count?: true | CapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapabilityMaxAggregateInputType
  }

  export type GetCapabilityAggregateType<T extends CapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapability[P]>
      : GetScalarType<T[P], AggregateCapability[P]>
  }




  export type CapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapabilityWhereInput
    orderBy?: CapabilityOrderByWithAggregationInput | CapabilityOrderByWithAggregationInput[]
    by: CapabilityScalarFieldEnum[] | CapabilityScalarFieldEnum
    having?: CapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapabilityCountAggregateInputType | true
    _avg?: CapabilityAvgAggregateInputType
    _sum?: CapabilitySumAggregateInputType
    _min?: CapabilityMinAggregateInputType
    _max?: CapabilityMaxAggregateInputType
  }

  export type CapabilityGroupByOutputType = {
    id: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse: number | null
    totalPracticeDurationRegGse: number | null
    totalTheoryDurationCompetency: number | null
    totalPracticeDurationCompetency: number | null
    totalDuration: number | null
    createdAt: Date
    updatedAt: Date
    _count: CapabilityCountAggregateOutputType | null
    _avg: CapabilityAvgAggregateOutputType | null
    _sum: CapabilitySumAggregateOutputType | null
    _min: CapabilityMinAggregateOutputType | null
    _max: CapabilityMaxAggregateOutputType | null
  }

  type GetCapabilityGroupByPayload<T extends CapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], CapabilityGroupByOutputType[P]>
        }
      >
    >


  export type CapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ratingCode?: boolean
    trainingCode?: boolean
    trainingName?: boolean
    totalTheoryDurationRegGse?: boolean
    totalPracticeDurationRegGse?: boolean
    totalTheoryDurationCompetency?: boolean
    totalPracticeDurationCompetency?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    curriculumSyllabus?: boolean | Capability$curriculumSyllabusArgs<ExtArgs>
    capabilityCots?: boolean | Capability$capabilityCotsArgs<ExtArgs>
    _count?: boolean | CapabilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capability"]>

  export type CapabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ratingCode?: boolean
    trainingCode?: boolean
    trainingName?: boolean
    totalTheoryDurationRegGse?: boolean
    totalPracticeDurationRegGse?: boolean
    totalTheoryDurationCompetency?: boolean
    totalPracticeDurationCompetency?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["capability"]>

  export type CapabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ratingCode?: boolean
    trainingCode?: boolean
    trainingName?: boolean
    totalTheoryDurationRegGse?: boolean
    totalPracticeDurationRegGse?: boolean
    totalTheoryDurationCompetency?: boolean
    totalPracticeDurationCompetency?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["capability"]>

  export type CapabilitySelectScalar = {
    id?: boolean
    ratingCode?: boolean
    trainingCode?: boolean
    trainingName?: boolean
    totalTheoryDurationRegGse?: boolean
    totalPracticeDurationRegGse?: boolean
    totalTheoryDurationCompetency?: boolean
    totalPracticeDurationCompetency?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CapabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ratingCode" | "trainingCode" | "trainingName" | "totalTheoryDurationRegGse" | "totalPracticeDurationRegGse" | "totalTheoryDurationCompetency" | "totalPracticeDurationCompetency" | "totalDuration" | "createdAt" | "updatedAt", ExtArgs["result"]["capability"]>
  export type CapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculumSyllabus?: boolean | Capability$curriculumSyllabusArgs<ExtArgs>
    capabilityCots?: boolean | Capability$capabilityCotsArgs<ExtArgs>
    _count?: boolean | CapabilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CapabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CapabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Capability"
    objects: {
      curriculumSyllabus: Prisma.$CurriculumSyllabusPayload<ExtArgs>[]
      capabilityCots: Prisma.$CapabilityCOTPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ratingCode: string
      trainingCode: string
      trainingName: string
      totalTheoryDurationRegGse: number | null
      totalPracticeDurationRegGse: number | null
      totalTheoryDurationCompetency: number | null
      totalPracticeDurationCompetency: number | null
      totalDuration: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["capability"]>
    composites: {}
  }

  type CapabilityGetPayload<S extends boolean | null | undefined | CapabilityDefaultArgs> = $Result.GetResult<Prisma.$CapabilityPayload, S>

  type CapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CapabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapabilityCountAggregateInputType | true
    }

  export interface CapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Capability'], meta: { name: 'Capability' } }
    /**
     * Find zero or one Capability that matches the filter.
     * @param {CapabilityFindUniqueArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapabilityFindUniqueArgs>(args: SelectSubset<T, CapabilityFindUniqueArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CapabilityFindUniqueOrThrowArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, CapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityFindFirstArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapabilityFindFirstArgs>(args?: SelectSubset<T, CapabilityFindFirstArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityFindFirstOrThrowArgs} args - Arguments to find a Capability
     * @example
     * // Get one Capability
     * const capability = await prisma.capability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, CapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capabilities
     * const capabilities = await prisma.capability.findMany()
     * 
     * // Get first 10 Capabilities
     * const capabilities = await prisma.capability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capabilityWithIdOnly = await prisma.capability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapabilityFindManyArgs>(args?: SelectSubset<T, CapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capability.
     * @param {CapabilityCreateArgs} args - Arguments to create a Capability.
     * @example
     * // Create one Capability
     * const Capability = await prisma.capability.create({
     *   data: {
     *     // ... data to create a Capability
     *   }
     * })
     * 
     */
    create<T extends CapabilityCreateArgs>(args: SelectSubset<T, CapabilityCreateArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capabilities.
     * @param {CapabilityCreateManyArgs} args - Arguments to create many Capabilities.
     * @example
     * // Create many Capabilities
     * const capability = await prisma.capability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapabilityCreateManyArgs>(args?: SelectSubset<T, CapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Capabilities and returns the data saved in the database.
     * @param {CapabilityCreateManyAndReturnArgs} args - Arguments to create many Capabilities.
     * @example
     * // Create many Capabilities
     * const capability = await prisma.capability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Capabilities and only return the `id`
     * const capabilityWithIdOnly = await prisma.capability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CapabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, CapabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Capability.
     * @param {CapabilityDeleteArgs} args - Arguments to delete one Capability.
     * @example
     * // Delete one Capability
     * const Capability = await prisma.capability.delete({
     *   where: {
     *     // ... filter to delete one Capability
     *   }
     * })
     * 
     */
    delete<T extends CapabilityDeleteArgs>(args: SelectSubset<T, CapabilityDeleteArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capability.
     * @param {CapabilityUpdateArgs} args - Arguments to update one Capability.
     * @example
     * // Update one Capability
     * const capability = await prisma.capability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapabilityUpdateArgs>(args: SelectSubset<T, CapabilityUpdateArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capabilities.
     * @param {CapabilityDeleteManyArgs} args - Arguments to filter Capabilities to delete.
     * @example
     * // Delete a few Capabilities
     * const { count } = await prisma.capability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapabilityDeleteManyArgs>(args?: SelectSubset<T, CapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capabilities
     * const capability = await prisma.capability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapabilityUpdateManyArgs>(args: SelectSubset<T, CapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capabilities and returns the data updated in the database.
     * @param {CapabilityUpdateManyAndReturnArgs} args - Arguments to update many Capabilities.
     * @example
     * // Update many Capabilities
     * const capability = await prisma.capability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Capabilities and only return the `id`
     * const capabilityWithIdOnly = await prisma.capability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CapabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, CapabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Capability.
     * @param {CapabilityUpsertArgs} args - Arguments to update or create a Capability.
     * @example
     * // Update or create a Capability
     * const capability = await prisma.capability.upsert({
     *   create: {
     *     // ... data to create a Capability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capability we want to update
     *   }
     * })
     */
    upsert<T extends CapabilityUpsertArgs>(args: SelectSubset<T, CapabilityUpsertArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCountArgs} args - Arguments to filter Capabilities to count.
     * @example
     * // Count the number of Capabilities
     * const count = await prisma.capability.count({
     *   where: {
     *     // ... the filter for the Capabilities we want to count
     *   }
     * })
    **/
    count<T extends CapabilityCountArgs>(
      args?: Subset<T, CapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapabilityAggregateArgs>(args: Subset<T, CapabilityAggregateArgs>): Prisma.PrismaPromise<GetCapabilityAggregateType<T>>

    /**
     * Group by Capability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapabilityGroupByArgs['orderBy'] }
        : { orderBy?: CapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Capability model
   */
  readonly fields: CapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Capability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curriculumSyllabus<T extends Capability$curriculumSyllabusArgs<ExtArgs> = {}>(args?: Subset<T, Capability$curriculumSyllabusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capabilityCots<T extends Capability$capabilityCotsArgs<ExtArgs> = {}>(args?: Subset<T, Capability$capabilityCotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Capability model
   */
  interface CapabilityFieldRefs {
    readonly id: FieldRef<"Capability", 'String'>
    readonly ratingCode: FieldRef<"Capability", 'String'>
    readonly trainingCode: FieldRef<"Capability", 'String'>
    readonly trainingName: FieldRef<"Capability", 'String'>
    readonly totalTheoryDurationRegGse: FieldRef<"Capability", 'Int'>
    readonly totalPracticeDurationRegGse: FieldRef<"Capability", 'Int'>
    readonly totalTheoryDurationCompetency: FieldRef<"Capability", 'Int'>
    readonly totalPracticeDurationCompetency: FieldRef<"Capability", 'Int'>
    readonly totalDuration: FieldRef<"Capability", 'Int'>
    readonly createdAt: FieldRef<"Capability", 'DateTime'>
    readonly updatedAt: FieldRef<"Capability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Capability findUnique
   */
  export type CapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability findUniqueOrThrow
   */
  export type CapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability findFirst
   */
  export type CapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Capabilities.
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Capabilities.
     */
    distinct?: CapabilityScalarFieldEnum | CapabilityScalarFieldEnum[]
  }

  /**
   * Capability findFirstOrThrow
   */
  export type CapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capability to fetch.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Capabilities.
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Capabilities.
     */
    distinct?: CapabilityScalarFieldEnum | CapabilityScalarFieldEnum[]
  }

  /**
   * Capability findMany
   */
  export type CapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter, which Capabilities to fetch.
     */
    where?: CapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Capabilities to fetch.
     */
    orderBy?: CapabilityOrderByWithRelationInput | CapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Capabilities.
     */
    cursor?: CapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Capabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Capabilities.
     */
    skip?: number
    distinct?: CapabilityScalarFieldEnum | CapabilityScalarFieldEnum[]
  }

  /**
   * Capability create
   */
  export type CapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Capability.
     */
    data: XOR<CapabilityCreateInput, CapabilityUncheckedCreateInput>
  }

  /**
   * Capability createMany
   */
  export type CapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Capabilities.
     */
    data: CapabilityCreateManyInput | CapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Capability createManyAndReturn
   */
  export type CapabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * The data used to create many Capabilities.
     */
    data: CapabilityCreateManyInput | CapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Capability update
   */
  export type CapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Capability.
     */
    data: XOR<CapabilityUpdateInput, CapabilityUncheckedUpdateInput>
    /**
     * Choose, which Capability to update.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability updateMany
   */
  export type CapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Capabilities.
     */
    data: XOR<CapabilityUpdateManyMutationInput, CapabilityUncheckedUpdateManyInput>
    /**
     * Filter which Capabilities to update
     */
    where?: CapabilityWhereInput
    /**
     * Limit how many Capabilities to update.
     */
    limit?: number
  }

  /**
   * Capability updateManyAndReturn
   */
  export type CapabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * The data used to update Capabilities.
     */
    data: XOR<CapabilityUpdateManyMutationInput, CapabilityUncheckedUpdateManyInput>
    /**
     * Filter which Capabilities to update
     */
    where?: CapabilityWhereInput
    /**
     * Limit how many Capabilities to update.
     */
    limit?: number
  }

  /**
   * Capability upsert
   */
  export type CapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Capability to update in case it exists.
     */
    where: CapabilityWhereUniqueInput
    /**
     * In case the Capability found by the `where` argument doesn't exist, create a new Capability with this data.
     */
    create: XOR<CapabilityCreateInput, CapabilityUncheckedCreateInput>
    /**
     * In case the Capability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapabilityUpdateInput, CapabilityUncheckedUpdateInput>
  }

  /**
   * Capability delete
   */
  export type CapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
    /**
     * Filter which Capability to delete.
     */
    where: CapabilityWhereUniqueInput
  }

  /**
   * Capability deleteMany
   */
  export type CapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Capabilities to delete
     */
    where?: CapabilityWhereInput
    /**
     * Limit how many Capabilities to delete.
     */
    limit?: number
  }

  /**
   * Capability.curriculumSyllabus
   */
  export type Capability$curriculumSyllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    where?: CurriculumSyllabusWhereInput
    orderBy?: CurriculumSyllabusOrderByWithRelationInput | CurriculumSyllabusOrderByWithRelationInput[]
    cursor?: CurriculumSyllabusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurriculumSyllabusScalarFieldEnum | CurriculumSyllabusScalarFieldEnum[]
  }

  /**
   * Capability.capabilityCots
   */
  export type Capability$capabilityCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    where?: CapabilityCOTWhereInput
    orderBy?: CapabilityCOTOrderByWithRelationInput | CapabilityCOTOrderByWithRelationInput[]
    cursor?: CapabilityCOTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapabilityCOTScalarFieldEnum | CapabilityCOTScalarFieldEnum[]
  }

  /**
   * Capability without action
   */
  export type CapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Capability
     */
    select?: CapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Capability
     */
    omit?: CapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityInclude<ExtArgs> | null
  }


  /**
   * Model CurriculumSyllabus
   */

  export type AggregateCurriculumSyllabus = {
    _count: CurriculumSyllabusCountAggregateOutputType | null
    _avg: CurriculumSyllabusAvgAggregateOutputType | null
    _sum: CurriculumSyllabusSumAggregateOutputType | null
    _min: CurriculumSyllabusMinAggregateOutputType | null
    _max: CurriculumSyllabusMaxAggregateOutputType | null
  }

  export type CurriculumSyllabusAvgAggregateOutputType = {
    theoryDuration: number | null
    practiceDuration: number | null
  }

  export type CurriculumSyllabusSumAggregateOutputType = {
    theoryDuration: number | null
    practiceDuration: number | null
  }

  export type CurriculumSyllabusMinAggregateOutputType = {
    id: string | null
    capabilityId: string | null
    name: string | null
    theoryDuration: number | null
    practiceDuration: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurriculumSyllabusMaxAggregateOutputType = {
    id: string | null
    capabilityId: string | null
    name: string | null
    theoryDuration: number | null
    practiceDuration: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurriculumSyllabusCountAggregateOutputType = {
    id: number
    capabilityId: number
    name: number
    theoryDuration: number
    practiceDuration: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurriculumSyllabusAvgAggregateInputType = {
    theoryDuration?: true
    practiceDuration?: true
  }

  export type CurriculumSyllabusSumAggregateInputType = {
    theoryDuration?: true
    practiceDuration?: true
  }

  export type CurriculumSyllabusMinAggregateInputType = {
    id?: true
    capabilityId?: true
    name?: true
    theoryDuration?: true
    practiceDuration?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurriculumSyllabusMaxAggregateInputType = {
    id?: true
    capabilityId?: true
    name?: true
    theoryDuration?: true
    practiceDuration?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurriculumSyllabusCountAggregateInputType = {
    id?: true
    capabilityId?: true
    name?: true
    theoryDuration?: true
    practiceDuration?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurriculumSyllabusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurriculumSyllabus to aggregate.
     */
    where?: CurriculumSyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumSyllabi to fetch.
     */
    orderBy?: CurriculumSyllabusOrderByWithRelationInput | CurriculumSyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurriculumSyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumSyllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumSyllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurriculumSyllabi
    **/
    _count?: true | CurriculumSyllabusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurriculumSyllabusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurriculumSyllabusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurriculumSyllabusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurriculumSyllabusMaxAggregateInputType
  }

  export type GetCurriculumSyllabusAggregateType<T extends CurriculumSyllabusAggregateArgs> = {
        [P in keyof T & keyof AggregateCurriculumSyllabus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurriculumSyllabus[P]>
      : GetScalarType<T[P], AggregateCurriculumSyllabus[P]>
  }




  export type CurriculumSyllabusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurriculumSyllabusWhereInput
    orderBy?: CurriculumSyllabusOrderByWithAggregationInput | CurriculumSyllabusOrderByWithAggregationInput[]
    by: CurriculumSyllabusScalarFieldEnum[] | CurriculumSyllabusScalarFieldEnum
    having?: CurriculumSyllabusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurriculumSyllabusCountAggregateInputType | true
    _avg?: CurriculumSyllabusAvgAggregateInputType
    _sum?: CurriculumSyllabusSumAggregateInputType
    _min?: CurriculumSyllabusMinAggregateInputType
    _max?: CurriculumSyllabusMaxAggregateInputType
  }

  export type CurriculumSyllabusGroupByOutputType = {
    id: string
    capabilityId: string
    name: string
    theoryDuration: number
    practiceDuration: number
    type: string
    createdAt: Date
    updatedAt: Date
    _count: CurriculumSyllabusCountAggregateOutputType | null
    _avg: CurriculumSyllabusAvgAggregateOutputType | null
    _sum: CurriculumSyllabusSumAggregateOutputType | null
    _min: CurriculumSyllabusMinAggregateOutputType | null
    _max: CurriculumSyllabusMaxAggregateOutputType | null
  }

  type GetCurriculumSyllabusGroupByPayload<T extends CurriculumSyllabusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurriculumSyllabusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurriculumSyllabusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurriculumSyllabusGroupByOutputType[P]>
            : GetScalarType<T[P], CurriculumSyllabusGroupByOutputType[P]>
        }
      >
    >


  export type CurriculumSyllabusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    capabilityId?: boolean
    name?: boolean
    theoryDuration?: boolean
    practiceDuration?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curriculumSyllabus"]>

  export type CurriculumSyllabusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    capabilityId?: boolean
    name?: boolean
    theoryDuration?: boolean
    practiceDuration?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curriculumSyllabus"]>

  export type CurriculumSyllabusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    capabilityId?: boolean
    name?: boolean
    theoryDuration?: boolean
    practiceDuration?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curriculumSyllabus"]>

  export type CurriculumSyllabusSelectScalar = {
    id?: boolean
    capabilityId?: boolean
    name?: boolean
    theoryDuration?: boolean
    practiceDuration?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurriculumSyllabusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "capabilityId" | "name" | "theoryDuration" | "practiceDuration" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["curriculumSyllabus"]>
  export type CurriculumSyllabusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }
  export type CurriculumSyllabusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }
  export type CurriculumSyllabusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
  }

  export type $CurriculumSyllabusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurriculumSyllabus"
    objects: {
      capability: Prisma.$CapabilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      capabilityId: string
      name: string
      theoryDuration: number
      practiceDuration: number
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["curriculumSyllabus"]>
    composites: {}
  }

  type CurriculumSyllabusGetPayload<S extends boolean | null | undefined | CurriculumSyllabusDefaultArgs> = $Result.GetResult<Prisma.$CurriculumSyllabusPayload, S>

  type CurriculumSyllabusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurriculumSyllabusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurriculumSyllabusCountAggregateInputType | true
    }

  export interface CurriculumSyllabusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurriculumSyllabus'], meta: { name: 'CurriculumSyllabus' } }
    /**
     * Find zero or one CurriculumSyllabus that matches the filter.
     * @param {CurriculumSyllabusFindUniqueArgs} args - Arguments to find a CurriculumSyllabus
     * @example
     * // Get one CurriculumSyllabus
     * const curriculumSyllabus = await prisma.curriculumSyllabus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurriculumSyllabusFindUniqueArgs>(args: SelectSubset<T, CurriculumSyllabusFindUniqueArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CurriculumSyllabus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurriculumSyllabusFindUniqueOrThrowArgs} args - Arguments to find a CurriculumSyllabus
     * @example
     * // Get one CurriculumSyllabus
     * const curriculumSyllabus = await prisma.curriculumSyllabus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurriculumSyllabusFindUniqueOrThrowArgs>(args: SelectSubset<T, CurriculumSyllabusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurriculumSyllabus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumSyllabusFindFirstArgs} args - Arguments to find a CurriculumSyllabus
     * @example
     * // Get one CurriculumSyllabus
     * const curriculumSyllabus = await prisma.curriculumSyllabus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurriculumSyllabusFindFirstArgs>(args?: SelectSubset<T, CurriculumSyllabusFindFirstArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurriculumSyllabus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumSyllabusFindFirstOrThrowArgs} args - Arguments to find a CurriculumSyllabus
     * @example
     * // Get one CurriculumSyllabus
     * const curriculumSyllabus = await prisma.curriculumSyllabus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurriculumSyllabusFindFirstOrThrowArgs>(args?: SelectSubset<T, CurriculumSyllabusFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CurriculumSyllabi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumSyllabusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurriculumSyllabi
     * const curriculumSyllabi = await prisma.curriculumSyllabus.findMany()
     * 
     * // Get first 10 CurriculumSyllabi
     * const curriculumSyllabi = await prisma.curriculumSyllabus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const curriculumSyllabusWithIdOnly = await prisma.curriculumSyllabus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurriculumSyllabusFindManyArgs>(args?: SelectSubset<T, CurriculumSyllabusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CurriculumSyllabus.
     * @param {CurriculumSyllabusCreateArgs} args - Arguments to create a CurriculumSyllabus.
     * @example
     * // Create one CurriculumSyllabus
     * const CurriculumSyllabus = await prisma.curriculumSyllabus.create({
     *   data: {
     *     // ... data to create a CurriculumSyllabus
     *   }
     * })
     * 
     */
    create<T extends CurriculumSyllabusCreateArgs>(args: SelectSubset<T, CurriculumSyllabusCreateArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CurriculumSyllabi.
     * @param {CurriculumSyllabusCreateManyArgs} args - Arguments to create many CurriculumSyllabi.
     * @example
     * // Create many CurriculumSyllabi
     * const curriculumSyllabus = await prisma.curriculumSyllabus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurriculumSyllabusCreateManyArgs>(args?: SelectSubset<T, CurriculumSyllabusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CurriculumSyllabi and returns the data saved in the database.
     * @param {CurriculumSyllabusCreateManyAndReturnArgs} args - Arguments to create many CurriculumSyllabi.
     * @example
     * // Create many CurriculumSyllabi
     * const curriculumSyllabus = await prisma.curriculumSyllabus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CurriculumSyllabi and only return the `id`
     * const curriculumSyllabusWithIdOnly = await prisma.curriculumSyllabus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurriculumSyllabusCreateManyAndReturnArgs>(args?: SelectSubset<T, CurriculumSyllabusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CurriculumSyllabus.
     * @param {CurriculumSyllabusDeleteArgs} args - Arguments to delete one CurriculumSyllabus.
     * @example
     * // Delete one CurriculumSyllabus
     * const CurriculumSyllabus = await prisma.curriculumSyllabus.delete({
     *   where: {
     *     // ... filter to delete one CurriculumSyllabus
     *   }
     * })
     * 
     */
    delete<T extends CurriculumSyllabusDeleteArgs>(args: SelectSubset<T, CurriculumSyllabusDeleteArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CurriculumSyllabus.
     * @param {CurriculumSyllabusUpdateArgs} args - Arguments to update one CurriculumSyllabus.
     * @example
     * // Update one CurriculumSyllabus
     * const curriculumSyllabus = await prisma.curriculumSyllabus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurriculumSyllabusUpdateArgs>(args: SelectSubset<T, CurriculumSyllabusUpdateArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CurriculumSyllabi.
     * @param {CurriculumSyllabusDeleteManyArgs} args - Arguments to filter CurriculumSyllabi to delete.
     * @example
     * // Delete a few CurriculumSyllabi
     * const { count } = await prisma.curriculumSyllabus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurriculumSyllabusDeleteManyArgs>(args?: SelectSubset<T, CurriculumSyllabusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurriculumSyllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumSyllabusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurriculumSyllabi
     * const curriculumSyllabus = await prisma.curriculumSyllabus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurriculumSyllabusUpdateManyArgs>(args: SelectSubset<T, CurriculumSyllabusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurriculumSyllabi and returns the data updated in the database.
     * @param {CurriculumSyllabusUpdateManyAndReturnArgs} args - Arguments to update many CurriculumSyllabi.
     * @example
     * // Update many CurriculumSyllabi
     * const curriculumSyllabus = await prisma.curriculumSyllabus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CurriculumSyllabi and only return the `id`
     * const curriculumSyllabusWithIdOnly = await prisma.curriculumSyllabus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurriculumSyllabusUpdateManyAndReturnArgs>(args: SelectSubset<T, CurriculumSyllabusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CurriculumSyllabus.
     * @param {CurriculumSyllabusUpsertArgs} args - Arguments to update or create a CurriculumSyllabus.
     * @example
     * // Update or create a CurriculumSyllabus
     * const curriculumSyllabus = await prisma.curriculumSyllabus.upsert({
     *   create: {
     *     // ... data to create a CurriculumSyllabus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurriculumSyllabus we want to update
     *   }
     * })
     */
    upsert<T extends CurriculumSyllabusUpsertArgs>(args: SelectSubset<T, CurriculumSyllabusUpsertArgs<ExtArgs>>): Prisma__CurriculumSyllabusClient<$Result.GetResult<Prisma.$CurriculumSyllabusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CurriculumSyllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumSyllabusCountArgs} args - Arguments to filter CurriculumSyllabi to count.
     * @example
     * // Count the number of CurriculumSyllabi
     * const count = await prisma.curriculumSyllabus.count({
     *   where: {
     *     // ... the filter for the CurriculumSyllabi we want to count
     *   }
     * })
    **/
    count<T extends CurriculumSyllabusCountArgs>(
      args?: Subset<T, CurriculumSyllabusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurriculumSyllabusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurriculumSyllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumSyllabusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurriculumSyllabusAggregateArgs>(args: Subset<T, CurriculumSyllabusAggregateArgs>): Prisma.PrismaPromise<GetCurriculumSyllabusAggregateType<T>>

    /**
     * Group by CurriculumSyllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumSyllabusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurriculumSyllabusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurriculumSyllabusGroupByArgs['orderBy'] }
        : { orderBy?: CurriculumSyllabusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurriculumSyllabusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurriculumSyllabusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurriculumSyllabus model
   */
  readonly fields: CurriculumSyllabusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurriculumSyllabus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurriculumSyllabusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capability<T extends CapabilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CapabilityDefaultArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurriculumSyllabus model
   */
  interface CurriculumSyllabusFieldRefs {
    readonly id: FieldRef<"CurriculumSyllabus", 'String'>
    readonly capabilityId: FieldRef<"CurriculumSyllabus", 'String'>
    readonly name: FieldRef<"CurriculumSyllabus", 'String'>
    readonly theoryDuration: FieldRef<"CurriculumSyllabus", 'Int'>
    readonly practiceDuration: FieldRef<"CurriculumSyllabus", 'Int'>
    readonly type: FieldRef<"CurriculumSyllabus", 'String'>
    readonly createdAt: FieldRef<"CurriculumSyllabus", 'DateTime'>
    readonly updatedAt: FieldRef<"CurriculumSyllabus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CurriculumSyllabus findUnique
   */
  export type CurriculumSyllabusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumSyllabus to fetch.
     */
    where: CurriculumSyllabusWhereUniqueInput
  }

  /**
   * CurriculumSyllabus findUniqueOrThrow
   */
  export type CurriculumSyllabusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumSyllabus to fetch.
     */
    where: CurriculumSyllabusWhereUniqueInput
  }

  /**
   * CurriculumSyllabus findFirst
   */
  export type CurriculumSyllabusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumSyllabus to fetch.
     */
    where?: CurriculumSyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumSyllabi to fetch.
     */
    orderBy?: CurriculumSyllabusOrderByWithRelationInput | CurriculumSyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurriculumSyllabi.
     */
    cursor?: CurriculumSyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumSyllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumSyllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurriculumSyllabi.
     */
    distinct?: CurriculumSyllabusScalarFieldEnum | CurriculumSyllabusScalarFieldEnum[]
  }

  /**
   * CurriculumSyllabus findFirstOrThrow
   */
  export type CurriculumSyllabusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumSyllabus to fetch.
     */
    where?: CurriculumSyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumSyllabi to fetch.
     */
    orderBy?: CurriculumSyllabusOrderByWithRelationInput | CurriculumSyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurriculumSyllabi.
     */
    cursor?: CurriculumSyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumSyllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumSyllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurriculumSyllabi.
     */
    distinct?: CurriculumSyllabusScalarFieldEnum | CurriculumSyllabusScalarFieldEnum[]
  }

  /**
   * CurriculumSyllabus findMany
   */
  export type CurriculumSyllabusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumSyllabi to fetch.
     */
    where?: CurriculumSyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumSyllabi to fetch.
     */
    orderBy?: CurriculumSyllabusOrderByWithRelationInput | CurriculumSyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurriculumSyllabi.
     */
    cursor?: CurriculumSyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumSyllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumSyllabi.
     */
    skip?: number
    distinct?: CurriculumSyllabusScalarFieldEnum | CurriculumSyllabusScalarFieldEnum[]
  }

  /**
   * CurriculumSyllabus create
   */
  export type CurriculumSyllabusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * The data needed to create a CurriculumSyllabus.
     */
    data: XOR<CurriculumSyllabusCreateInput, CurriculumSyllabusUncheckedCreateInput>
  }

  /**
   * CurriculumSyllabus createMany
   */
  export type CurriculumSyllabusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurriculumSyllabi.
     */
    data: CurriculumSyllabusCreateManyInput | CurriculumSyllabusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CurriculumSyllabus createManyAndReturn
   */
  export type CurriculumSyllabusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * The data used to create many CurriculumSyllabi.
     */
    data: CurriculumSyllabusCreateManyInput | CurriculumSyllabusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurriculumSyllabus update
   */
  export type CurriculumSyllabusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * The data needed to update a CurriculumSyllabus.
     */
    data: XOR<CurriculumSyllabusUpdateInput, CurriculumSyllabusUncheckedUpdateInput>
    /**
     * Choose, which CurriculumSyllabus to update.
     */
    where: CurriculumSyllabusWhereUniqueInput
  }

  /**
   * CurriculumSyllabus updateMany
   */
  export type CurriculumSyllabusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurriculumSyllabi.
     */
    data: XOR<CurriculumSyllabusUpdateManyMutationInput, CurriculumSyllabusUncheckedUpdateManyInput>
    /**
     * Filter which CurriculumSyllabi to update
     */
    where?: CurriculumSyllabusWhereInput
    /**
     * Limit how many CurriculumSyllabi to update.
     */
    limit?: number
  }

  /**
   * CurriculumSyllabus updateManyAndReturn
   */
  export type CurriculumSyllabusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * The data used to update CurriculumSyllabi.
     */
    data: XOR<CurriculumSyllabusUpdateManyMutationInput, CurriculumSyllabusUncheckedUpdateManyInput>
    /**
     * Filter which CurriculumSyllabi to update
     */
    where?: CurriculumSyllabusWhereInput
    /**
     * Limit how many CurriculumSyllabi to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurriculumSyllabus upsert
   */
  export type CurriculumSyllabusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * The filter to search for the CurriculumSyllabus to update in case it exists.
     */
    where: CurriculumSyllabusWhereUniqueInput
    /**
     * In case the CurriculumSyllabus found by the `where` argument doesn't exist, create a new CurriculumSyllabus with this data.
     */
    create: XOR<CurriculumSyllabusCreateInput, CurriculumSyllabusUncheckedCreateInput>
    /**
     * In case the CurriculumSyllabus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurriculumSyllabusUpdateInput, CurriculumSyllabusUncheckedUpdateInput>
  }

  /**
   * CurriculumSyllabus delete
   */
  export type CurriculumSyllabusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
    /**
     * Filter which CurriculumSyllabus to delete.
     */
    where: CurriculumSyllabusWhereUniqueInput
  }

  /**
   * CurriculumSyllabus deleteMany
   */
  export type CurriculumSyllabusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurriculumSyllabi to delete
     */
    where?: CurriculumSyllabusWhereInput
    /**
     * Limit how many CurriculumSyllabi to delete.
     */
    limit?: number
  }

  /**
   * CurriculumSyllabus without action
   */
  export type CurriculumSyllabusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumSyllabus
     */
    select?: CurriculumSyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumSyllabus
     */
    omit?: CurriculumSyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumSyllabusInclude<ExtArgs> | null
  }


  /**
   * Model COT
   */

  export type AggregateCOT = {
    _count: COTCountAggregateOutputType | null
    _min: COTMinAggregateOutputType | null
    _max: COTMaxAggregateOutputType | null
  }

  export type COTMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    trainingLocation: string | null
    theoryInstructorRegGse: string | null
    theoryInstructorCompetency: string | null
    practicalInstructor1: string | null
    practicalInstructor2: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type COTMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    trainingLocation: string | null
    theoryInstructorRegGse: string | null
    theoryInstructorCompetency: string | null
    practicalInstructor1: string | null
    practicalInstructor2: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type COTCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    trainingLocation: number
    theoryInstructorRegGse: number
    theoryInstructorCompetency: number
    practicalInstructor1: number
    practicalInstructor2: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type COTMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    trainingLocation?: true
    theoryInstructorRegGse?: true
    theoryInstructorCompetency?: true
    practicalInstructor1?: true
    practicalInstructor2?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type COTMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    trainingLocation?: true
    theoryInstructorRegGse?: true
    theoryInstructorCompetency?: true
    practicalInstructor1?: true
    practicalInstructor2?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type COTCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    trainingLocation?: true
    theoryInstructorRegGse?: true
    theoryInstructorCompetency?: true
    practicalInstructor1?: true
    practicalInstructor2?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type COTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which COT to aggregate.
     */
    where?: COTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COTS to fetch.
     */
    orderBy?: COTOrderByWithRelationInput | COTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: COTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned COTS
    **/
    _count?: true | COTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: COTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: COTMaxAggregateInputType
  }

  export type GetCOTAggregateType<T extends COTAggregateArgs> = {
        [P in keyof T & keyof AggregateCOT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCOT[P]>
      : GetScalarType<T[P], AggregateCOT[P]>
  }




  export type COTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: COTWhereInput
    orderBy?: COTOrderByWithAggregationInput | COTOrderByWithAggregationInput[]
    by: COTScalarFieldEnum[] | COTScalarFieldEnum
    having?: COTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: COTCountAggregateInputType | true
    _min?: COTMinAggregateInputType
    _max?: COTMaxAggregateInputType
  }

  export type COTGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: COTCountAggregateOutputType | null
    _min: COTMinAggregateOutputType | null
    _max: COTMaxAggregateOutputType | null
  }

  type GetCOTGroupByPayload<T extends COTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<COTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof COTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], COTGroupByOutputType[P]>
            : GetScalarType<T[P], COTGroupByOutputType[P]>
        }
      >
    >


  export type COTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingLocation?: boolean
    theoryInstructorRegGse?: boolean
    theoryInstructorCompetency?: boolean
    practicalInstructor1?: boolean
    practicalInstructor2?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capabilityCots?: boolean | COT$capabilityCotsArgs<ExtArgs>
    participantsCots?: boolean | COT$participantsCotsArgs<ExtArgs>
    certificates?: boolean | COT$certificatesArgs<ExtArgs>
    _count?: boolean | COTCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cOT"]>

  export type COTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingLocation?: boolean
    theoryInstructorRegGse?: boolean
    theoryInstructorCompetency?: boolean
    practicalInstructor1?: boolean
    practicalInstructor2?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cOT"]>

  export type COTSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingLocation?: boolean
    theoryInstructorRegGse?: boolean
    theoryInstructorCompetency?: boolean
    practicalInstructor1?: boolean
    practicalInstructor2?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cOT"]>

  export type COTSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    trainingLocation?: boolean
    theoryInstructorRegGse?: boolean
    theoryInstructorCompetency?: boolean
    practicalInstructor1?: boolean
    practicalInstructor2?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type COTOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "trainingLocation" | "theoryInstructorRegGse" | "theoryInstructorCompetency" | "practicalInstructor1" | "practicalInstructor2" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["cOT"]>
  export type COTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capabilityCots?: boolean | COT$capabilityCotsArgs<ExtArgs>
    participantsCots?: boolean | COT$participantsCotsArgs<ExtArgs>
    certificates?: boolean | COT$certificatesArgs<ExtArgs>
    _count?: boolean | COTCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type COTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type COTIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $COTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "COT"
    objects: {
      capabilityCots: Prisma.$CapabilityCOTPayload<ExtArgs>[]
      participantsCots: Prisma.$ParticipantsCOTPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      trainingLocation: string
      theoryInstructorRegGse: string
      theoryInstructorCompetency: string
      practicalInstructor1: string
      practicalInstructor2: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cOT"]>
    composites: {}
  }

  type COTGetPayload<S extends boolean | null | undefined | COTDefaultArgs> = $Result.GetResult<Prisma.$COTPayload, S>

  type COTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<COTFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: COTCountAggregateInputType | true
    }

  export interface COTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['COT'], meta: { name: 'COT' } }
    /**
     * Find zero or one COT that matches the filter.
     * @param {COTFindUniqueArgs} args - Arguments to find a COT
     * @example
     * // Get one COT
     * const cOT = await prisma.cOT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends COTFindUniqueArgs>(args: SelectSubset<T, COTFindUniqueArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one COT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {COTFindUniqueOrThrowArgs} args - Arguments to find a COT
     * @example
     * // Get one COT
     * const cOT = await prisma.cOT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends COTFindUniqueOrThrowArgs>(args: SelectSubset<T, COTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first COT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COTFindFirstArgs} args - Arguments to find a COT
     * @example
     * // Get one COT
     * const cOT = await prisma.cOT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends COTFindFirstArgs>(args?: SelectSubset<T, COTFindFirstArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first COT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COTFindFirstOrThrowArgs} args - Arguments to find a COT
     * @example
     * // Get one COT
     * const cOT = await prisma.cOT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends COTFindFirstOrThrowArgs>(args?: SelectSubset<T, COTFindFirstOrThrowArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more COTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all COTS
     * const cOTS = await prisma.cOT.findMany()
     * 
     * // Get first 10 COTS
     * const cOTS = await prisma.cOT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cOTWithIdOnly = await prisma.cOT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends COTFindManyArgs>(args?: SelectSubset<T, COTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a COT.
     * @param {COTCreateArgs} args - Arguments to create a COT.
     * @example
     * // Create one COT
     * const COT = await prisma.cOT.create({
     *   data: {
     *     // ... data to create a COT
     *   }
     * })
     * 
     */
    create<T extends COTCreateArgs>(args: SelectSubset<T, COTCreateArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many COTS.
     * @param {COTCreateManyArgs} args - Arguments to create many COTS.
     * @example
     * // Create many COTS
     * const cOT = await prisma.cOT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends COTCreateManyArgs>(args?: SelectSubset<T, COTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many COTS and returns the data saved in the database.
     * @param {COTCreateManyAndReturnArgs} args - Arguments to create many COTS.
     * @example
     * // Create many COTS
     * const cOT = await prisma.cOT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many COTS and only return the `id`
     * const cOTWithIdOnly = await prisma.cOT.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends COTCreateManyAndReturnArgs>(args?: SelectSubset<T, COTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a COT.
     * @param {COTDeleteArgs} args - Arguments to delete one COT.
     * @example
     * // Delete one COT
     * const COT = await prisma.cOT.delete({
     *   where: {
     *     // ... filter to delete one COT
     *   }
     * })
     * 
     */
    delete<T extends COTDeleteArgs>(args: SelectSubset<T, COTDeleteArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one COT.
     * @param {COTUpdateArgs} args - Arguments to update one COT.
     * @example
     * // Update one COT
     * const cOT = await prisma.cOT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends COTUpdateArgs>(args: SelectSubset<T, COTUpdateArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more COTS.
     * @param {COTDeleteManyArgs} args - Arguments to filter COTS to delete.
     * @example
     * // Delete a few COTS
     * const { count } = await prisma.cOT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends COTDeleteManyArgs>(args?: SelectSubset<T, COTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more COTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many COTS
     * const cOT = await prisma.cOT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends COTUpdateManyArgs>(args: SelectSubset<T, COTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more COTS and returns the data updated in the database.
     * @param {COTUpdateManyAndReturnArgs} args - Arguments to update many COTS.
     * @example
     * // Update many COTS
     * const cOT = await prisma.cOT.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more COTS and only return the `id`
     * const cOTWithIdOnly = await prisma.cOT.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends COTUpdateManyAndReturnArgs>(args: SelectSubset<T, COTUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one COT.
     * @param {COTUpsertArgs} args - Arguments to update or create a COT.
     * @example
     * // Update or create a COT
     * const cOT = await prisma.cOT.upsert({
     *   create: {
     *     // ... data to create a COT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the COT we want to update
     *   }
     * })
     */
    upsert<T extends COTUpsertArgs>(args: SelectSubset<T, COTUpsertArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of COTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COTCountArgs} args - Arguments to filter COTS to count.
     * @example
     * // Count the number of COTS
     * const count = await prisma.cOT.count({
     *   where: {
     *     // ... the filter for the COTS we want to count
     *   }
     * })
    **/
    count<T extends COTCountArgs>(
      args?: Subset<T, COTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], COTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a COT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends COTAggregateArgs>(args: Subset<T, COTAggregateArgs>): Prisma.PrismaPromise<GetCOTAggregateType<T>>

    /**
     * Group by COT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends COTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: COTGroupByArgs['orderBy'] }
        : { orderBy?: COTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, COTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCOTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the COT model
   */
  readonly fields: COTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for COT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__COTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capabilityCots<T extends COT$capabilityCotsArgs<ExtArgs> = {}>(args?: Subset<T, COT$capabilityCotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participantsCots<T extends COT$participantsCotsArgs<ExtArgs> = {}>(args?: Subset<T, COT$participantsCotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends COT$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, COT$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the COT model
   */
  interface COTFieldRefs {
    readonly id: FieldRef<"COT", 'String'>
    readonly startDate: FieldRef<"COT", 'DateTime'>
    readonly endDate: FieldRef<"COT", 'DateTime'>
    readonly trainingLocation: FieldRef<"COT", 'String'>
    readonly theoryInstructorRegGse: FieldRef<"COT", 'String'>
    readonly theoryInstructorCompetency: FieldRef<"COT", 'String'>
    readonly practicalInstructor1: FieldRef<"COT", 'String'>
    readonly practicalInstructor2: FieldRef<"COT", 'String'>
    readonly status: FieldRef<"COT", 'String'>
    readonly createdAt: FieldRef<"COT", 'DateTime'>
    readonly updatedAt: FieldRef<"COT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * COT findUnique
   */
  export type COTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * Filter, which COT to fetch.
     */
    where: COTWhereUniqueInput
  }

  /**
   * COT findUniqueOrThrow
   */
  export type COTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * Filter, which COT to fetch.
     */
    where: COTWhereUniqueInput
  }

  /**
   * COT findFirst
   */
  export type COTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * Filter, which COT to fetch.
     */
    where?: COTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COTS to fetch.
     */
    orderBy?: COTOrderByWithRelationInput | COTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for COTS.
     */
    cursor?: COTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of COTS.
     */
    distinct?: COTScalarFieldEnum | COTScalarFieldEnum[]
  }

  /**
   * COT findFirstOrThrow
   */
  export type COTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * Filter, which COT to fetch.
     */
    where?: COTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COTS to fetch.
     */
    orderBy?: COTOrderByWithRelationInput | COTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for COTS.
     */
    cursor?: COTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of COTS.
     */
    distinct?: COTScalarFieldEnum | COTScalarFieldEnum[]
  }

  /**
   * COT findMany
   */
  export type COTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * Filter, which COTS to fetch.
     */
    where?: COTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COTS to fetch.
     */
    orderBy?: COTOrderByWithRelationInput | COTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing COTS.
     */
    cursor?: COTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COTS.
     */
    skip?: number
    distinct?: COTScalarFieldEnum | COTScalarFieldEnum[]
  }

  /**
   * COT create
   */
  export type COTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * The data needed to create a COT.
     */
    data: XOR<COTCreateInput, COTUncheckedCreateInput>
  }

  /**
   * COT createMany
   */
  export type COTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many COTS.
     */
    data: COTCreateManyInput | COTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * COT createManyAndReturn
   */
  export type COTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * The data used to create many COTS.
     */
    data: COTCreateManyInput | COTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * COT update
   */
  export type COTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * The data needed to update a COT.
     */
    data: XOR<COTUpdateInput, COTUncheckedUpdateInput>
    /**
     * Choose, which COT to update.
     */
    where: COTWhereUniqueInput
  }

  /**
   * COT updateMany
   */
  export type COTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update COTS.
     */
    data: XOR<COTUpdateManyMutationInput, COTUncheckedUpdateManyInput>
    /**
     * Filter which COTS to update
     */
    where?: COTWhereInput
    /**
     * Limit how many COTS to update.
     */
    limit?: number
  }

  /**
   * COT updateManyAndReturn
   */
  export type COTUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * The data used to update COTS.
     */
    data: XOR<COTUpdateManyMutationInput, COTUncheckedUpdateManyInput>
    /**
     * Filter which COTS to update
     */
    where?: COTWhereInput
    /**
     * Limit how many COTS to update.
     */
    limit?: number
  }

  /**
   * COT upsert
   */
  export type COTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * The filter to search for the COT to update in case it exists.
     */
    where: COTWhereUniqueInput
    /**
     * In case the COT found by the `where` argument doesn't exist, create a new COT with this data.
     */
    create: XOR<COTCreateInput, COTUncheckedCreateInput>
    /**
     * In case the COT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<COTUpdateInput, COTUncheckedUpdateInput>
  }

  /**
   * COT delete
   */
  export type COTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
    /**
     * Filter which COT to delete.
     */
    where: COTWhereUniqueInput
  }

  /**
   * COT deleteMany
   */
  export type COTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which COTS to delete
     */
    where?: COTWhereInput
    /**
     * Limit how many COTS to delete.
     */
    limit?: number
  }

  /**
   * COT.capabilityCots
   */
  export type COT$capabilityCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    where?: CapabilityCOTWhereInput
    orderBy?: CapabilityCOTOrderByWithRelationInput | CapabilityCOTOrderByWithRelationInput[]
    cursor?: CapabilityCOTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapabilityCOTScalarFieldEnum | CapabilityCOTScalarFieldEnum[]
  }

  /**
   * COT.participantsCots
   */
  export type COT$participantsCotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    where?: ParticipantsCOTWhereInput
    orderBy?: ParticipantsCOTOrderByWithRelationInput | ParticipantsCOTOrderByWithRelationInput[]
    cursor?: ParticipantsCOTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipantsCOTScalarFieldEnum | ParticipantsCOTScalarFieldEnum[]
  }

  /**
   * COT.certificates
   */
  export type COT$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * COT without action
   */
  export type COTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COT
     */
    select?: COTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COT
     */
    omit?: COTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COTInclude<ExtArgs> | null
  }


  /**
   * Model CapabilityCOT
   */

  export type AggregateCapabilityCOT = {
    _count: CapabilityCOTCountAggregateOutputType | null
    _min: CapabilityCOTMinAggregateOutputType | null
    _max: CapabilityCOTMaxAggregateOutputType | null
  }

  export type CapabilityCOTMinAggregateOutputType = {
    capabilityId: string | null
    cotId: string | null
  }

  export type CapabilityCOTMaxAggregateOutputType = {
    capabilityId: string | null
    cotId: string | null
  }

  export type CapabilityCOTCountAggregateOutputType = {
    capabilityId: number
    cotId: number
    _all: number
  }


  export type CapabilityCOTMinAggregateInputType = {
    capabilityId?: true
    cotId?: true
  }

  export type CapabilityCOTMaxAggregateInputType = {
    capabilityId?: true
    cotId?: true
  }

  export type CapabilityCOTCountAggregateInputType = {
    capabilityId?: true
    cotId?: true
    _all?: true
  }

  export type CapabilityCOTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapabilityCOT to aggregate.
     */
    where?: CapabilityCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityCOTS to fetch.
     */
    orderBy?: CapabilityCOTOrderByWithRelationInput | CapabilityCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapabilityCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityCOTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CapabilityCOTS
    **/
    _count?: true | CapabilityCOTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapabilityCOTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapabilityCOTMaxAggregateInputType
  }

  export type GetCapabilityCOTAggregateType<T extends CapabilityCOTAggregateArgs> = {
        [P in keyof T & keyof AggregateCapabilityCOT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapabilityCOT[P]>
      : GetScalarType<T[P], AggregateCapabilityCOT[P]>
  }




  export type CapabilityCOTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapabilityCOTWhereInput
    orderBy?: CapabilityCOTOrderByWithAggregationInput | CapabilityCOTOrderByWithAggregationInput[]
    by: CapabilityCOTScalarFieldEnum[] | CapabilityCOTScalarFieldEnum
    having?: CapabilityCOTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapabilityCOTCountAggregateInputType | true
    _min?: CapabilityCOTMinAggregateInputType
    _max?: CapabilityCOTMaxAggregateInputType
  }

  export type CapabilityCOTGroupByOutputType = {
    capabilityId: string
    cotId: string
    _count: CapabilityCOTCountAggregateOutputType | null
    _min: CapabilityCOTMinAggregateOutputType | null
    _max: CapabilityCOTMaxAggregateOutputType | null
  }

  type GetCapabilityCOTGroupByPayload<T extends CapabilityCOTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapabilityCOTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapabilityCOTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapabilityCOTGroupByOutputType[P]>
            : GetScalarType<T[P], CapabilityCOTGroupByOutputType[P]>
        }
      >
    >


  export type CapabilityCOTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    capabilityId?: boolean
    cotId?: boolean
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capabilityCOT"]>

  export type CapabilityCOTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    capabilityId?: boolean
    cotId?: boolean
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capabilityCOT"]>

  export type CapabilityCOTSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    capabilityId?: boolean
    cotId?: boolean
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capabilityCOT"]>

  export type CapabilityCOTSelectScalar = {
    capabilityId?: boolean
    cotId?: boolean
  }

  export type CapabilityCOTOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"capabilityId" | "cotId", ExtArgs["result"]["capabilityCOT"]>
  export type CapabilityCOTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }
  export type CapabilityCOTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }
  export type CapabilityCOTIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capability?: boolean | CapabilityDefaultArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }

  export type $CapabilityCOTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CapabilityCOT"
    objects: {
      capability: Prisma.$CapabilityPayload<ExtArgs>
      cot: Prisma.$COTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      capabilityId: string
      cotId: string
    }, ExtArgs["result"]["capabilityCOT"]>
    composites: {}
  }

  type CapabilityCOTGetPayload<S extends boolean | null | undefined | CapabilityCOTDefaultArgs> = $Result.GetResult<Prisma.$CapabilityCOTPayload, S>

  type CapabilityCOTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CapabilityCOTFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapabilityCOTCountAggregateInputType | true
    }

  export interface CapabilityCOTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CapabilityCOT'], meta: { name: 'CapabilityCOT' } }
    /**
     * Find zero or one CapabilityCOT that matches the filter.
     * @param {CapabilityCOTFindUniqueArgs} args - Arguments to find a CapabilityCOT
     * @example
     * // Get one CapabilityCOT
     * const capabilityCOT = await prisma.capabilityCOT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapabilityCOTFindUniqueArgs>(args: SelectSubset<T, CapabilityCOTFindUniqueArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CapabilityCOT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CapabilityCOTFindUniqueOrThrowArgs} args - Arguments to find a CapabilityCOT
     * @example
     * // Get one CapabilityCOT
     * const capabilityCOT = await prisma.capabilityCOT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapabilityCOTFindUniqueOrThrowArgs>(args: SelectSubset<T, CapabilityCOTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapabilityCOT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCOTFindFirstArgs} args - Arguments to find a CapabilityCOT
     * @example
     * // Get one CapabilityCOT
     * const capabilityCOT = await prisma.capabilityCOT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapabilityCOTFindFirstArgs>(args?: SelectSubset<T, CapabilityCOTFindFirstArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapabilityCOT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCOTFindFirstOrThrowArgs} args - Arguments to find a CapabilityCOT
     * @example
     * // Get one CapabilityCOT
     * const capabilityCOT = await prisma.capabilityCOT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapabilityCOTFindFirstOrThrowArgs>(args?: SelectSubset<T, CapabilityCOTFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CapabilityCOTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCOTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CapabilityCOTS
     * const capabilityCOTS = await prisma.capabilityCOT.findMany()
     * 
     * // Get first 10 CapabilityCOTS
     * const capabilityCOTS = await prisma.capabilityCOT.findMany({ take: 10 })
     * 
     * // Only select the `capabilityId`
     * const capabilityCOTWithCapabilityIdOnly = await prisma.capabilityCOT.findMany({ select: { capabilityId: true } })
     * 
     */
    findMany<T extends CapabilityCOTFindManyArgs>(args?: SelectSubset<T, CapabilityCOTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CapabilityCOT.
     * @param {CapabilityCOTCreateArgs} args - Arguments to create a CapabilityCOT.
     * @example
     * // Create one CapabilityCOT
     * const CapabilityCOT = await prisma.capabilityCOT.create({
     *   data: {
     *     // ... data to create a CapabilityCOT
     *   }
     * })
     * 
     */
    create<T extends CapabilityCOTCreateArgs>(args: SelectSubset<T, CapabilityCOTCreateArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CapabilityCOTS.
     * @param {CapabilityCOTCreateManyArgs} args - Arguments to create many CapabilityCOTS.
     * @example
     * // Create many CapabilityCOTS
     * const capabilityCOT = await prisma.capabilityCOT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapabilityCOTCreateManyArgs>(args?: SelectSubset<T, CapabilityCOTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CapabilityCOTS and returns the data saved in the database.
     * @param {CapabilityCOTCreateManyAndReturnArgs} args - Arguments to create many CapabilityCOTS.
     * @example
     * // Create many CapabilityCOTS
     * const capabilityCOT = await prisma.capabilityCOT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CapabilityCOTS and only return the `capabilityId`
     * const capabilityCOTWithCapabilityIdOnly = await prisma.capabilityCOT.createManyAndReturn({
     *   select: { capabilityId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CapabilityCOTCreateManyAndReturnArgs>(args?: SelectSubset<T, CapabilityCOTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CapabilityCOT.
     * @param {CapabilityCOTDeleteArgs} args - Arguments to delete one CapabilityCOT.
     * @example
     * // Delete one CapabilityCOT
     * const CapabilityCOT = await prisma.capabilityCOT.delete({
     *   where: {
     *     // ... filter to delete one CapabilityCOT
     *   }
     * })
     * 
     */
    delete<T extends CapabilityCOTDeleteArgs>(args: SelectSubset<T, CapabilityCOTDeleteArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CapabilityCOT.
     * @param {CapabilityCOTUpdateArgs} args - Arguments to update one CapabilityCOT.
     * @example
     * // Update one CapabilityCOT
     * const capabilityCOT = await prisma.capabilityCOT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapabilityCOTUpdateArgs>(args: SelectSubset<T, CapabilityCOTUpdateArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CapabilityCOTS.
     * @param {CapabilityCOTDeleteManyArgs} args - Arguments to filter CapabilityCOTS to delete.
     * @example
     * // Delete a few CapabilityCOTS
     * const { count } = await prisma.capabilityCOT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapabilityCOTDeleteManyArgs>(args?: SelectSubset<T, CapabilityCOTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapabilityCOTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCOTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CapabilityCOTS
     * const capabilityCOT = await prisma.capabilityCOT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapabilityCOTUpdateManyArgs>(args: SelectSubset<T, CapabilityCOTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapabilityCOTS and returns the data updated in the database.
     * @param {CapabilityCOTUpdateManyAndReturnArgs} args - Arguments to update many CapabilityCOTS.
     * @example
     * // Update many CapabilityCOTS
     * const capabilityCOT = await prisma.capabilityCOT.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CapabilityCOTS and only return the `capabilityId`
     * const capabilityCOTWithCapabilityIdOnly = await prisma.capabilityCOT.updateManyAndReturn({
     *   select: { capabilityId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CapabilityCOTUpdateManyAndReturnArgs>(args: SelectSubset<T, CapabilityCOTUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CapabilityCOT.
     * @param {CapabilityCOTUpsertArgs} args - Arguments to update or create a CapabilityCOT.
     * @example
     * // Update or create a CapabilityCOT
     * const capabilityCOT = await prisma.capabilityCOT.upsert({
     *   create: {
     *     // ... data to create a CapabilityCOT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CapabilityCOT we want to update
     *   }
     * })
     */
    upsert<T extends CapabilityCOTUpsertArgs>(args: SelectSubset<T, CapabilityCOTUpsertArgs<ExtArgs>>): Prisma__CapabilityCOTClient<$Result.GetResult<Prisma.$CapabilityCOTPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CapabilityCOTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCOTCountArgs} args - Arguments to filter CapabilityCOTS to count.
     * @example
     * // Count the number of CapabilityCOTS
     * const count = await prisma.capabilityCOT.count({
     *   where: {
     *     // ... the filter for the CapabilityCOTS we want to count
     *   }
     * })
    **/
    count<T extends CapabilityCOTCountArgs>(
      args?: Subset<T, CapabilityCOTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapabilityCOTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CapabilityCOT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCOTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapabilityCOTAggregateArgs>(args: Subset<T, CapabilityCOTAggregateArgs>): Prisma.PrismaPromise<GetCapabilityCOTAggregateType<T>>

    /**
     * Group by CapabilityCOT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityCOTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapabilityCOTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapabilityCOTGroupByArgs['orderBy'] }
        : { orderBy?: CapabilityCOTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapabilityCOTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapabilityCOTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CapabilityCOT model
   */
  readonly fields: CapabilityCOTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CapabilityCOT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapabilityCOTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capability<T extends CapabilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CapabilityDefaultArgs<ExtArgs>>): Prisma__CapabilityClient<$Result.GetResult<Prisma.$CapabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cot<T extends COTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, COTDefaultArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CapabilityCOT model
   */
  interface CapabilityCOTFieldRefs {
    readonly capabilityId: FieldRef<"CapabilityCOT", 'String'>
    readonly cotId: FieldRef<"CapabilityCOT", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CapabilityCOT findUnique
   */
  export type CapabilityCOTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * Filter, which CapabilityCOT to fetch.
     */
    where: CapabilityCOTWhereUniqueInput
  }

  /**
   * CapabilityCOT findUniqueOrThrow
   */
  export type CapabilityCOTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * Filter, which CapabilityCOT to fetch.
     */
    where: CapabilityCOTWhereUniqueInput
  }

  /**
   * CapabilityCOT findFirst
   */
  export type CapabilityCOTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * Filter, which CapabilityCOT to fetch.
     */
    where?: CapabilityCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityCOTS to fetch.
     */
    orderBy?: CapabilityCOTOrderByWithRelationInput | CapabilityCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapabilityCOTS.
     */
    cursor?: CapabilityCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityCOTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapabilityCOTS.
     */
    distinct?: CapabilityCOTScalarFieldEnum | CapabilityCOTScalarFieldEnum[]
  }

  /**
   * CapabilityCOT findFirstOrThrow
   */
  export type CapabilityCOTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * Filter, which CapabilityCOT to fetch.
     */
    where?: CapabilityCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityCOTS to fetch.
     */
    orderBy?: CapabilityCOTOrderByWithRelationInput | CapabilityCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapabilityCOTS.
     */
    cursor?: CapabilityCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityCOTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapabilityCOTS.
     */
    distinct?: CapabilityCOTScalarFieldEnum | CapabilityCOTScalarFieldEnum[]
  }

  /**
   * CapabilityCOT findMany
   */
  export type CapabilityCOTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * Filter, which CapabilityCOTS to fetch.
     */
    where?: CapabilityCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityCOTS to fetch.
     */
    orderBy?: CapabilityCOTOrderByWithRelationInput | CapabilityCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CapabilityCOTS.
     */
    cursor?: CapabilityCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapabilityCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityCOTS.
     */
    skip?: number
    distinct?: CapabilityCOTScalarFieldEnum | CapabilityCOTScalarFieldEnum[]
  }

  /**
   * CapabilityCOT create
   */
  export type CapabilityCOTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * The data needed to create a CapabilityCOT.
     */
    data: XOR<CapabilityCOTCreateInput, CapabilityCOTUncheckedCreateInput>
  }

  /**
   * CapabilityCOT createMany
   */
  export type CapabilityCOTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CapabilityCOTS.
     */
    data: CapabilityCOTCreateManyInput | CapabilityCOTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapabilityCOT createManyAndReturn
   */
  export type CapabilityCOTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * The data used to create many CapabilityCOTS.
     */
    data: CapabilityCOTCreateManyInput | CapabilityCOTCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapabilityCOT update
   */
  export type CapabilityCOTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * The data needed to update a CapabilityCOT.
     */
    data: XOR<CapabilityCOTUpdateInput, CapabilityCOTUncheckedUpdateInput>
    /**
     * Choose, which CapabilityCOT to update.
     */
    where: CapabilityCOTWhereUniqueInput
  }

  /**
   * CapabilityCOT updateMany
   */
  export type CapabilityCOTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CapabilityCOTS.
     */
    data: XOR<CapabilityCOTUpdateManyMutationInput, CapabilityCOTUncheckedUpdateManyInput>
    /**
     * Filter which CapabilityCOTS to update
     */
    where?: CapabilityCOTWhereInput
    /**
     * Limit how many CapabilityCOTS to update.
     */
    limit?: number
  }

  /**
   * CapabilityCOT updateManyAndReturn
   */
  export type CapabilityCOTUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * The data used to update CapabilityCOTS.
     */
    data: XOR<CapabilityCOTUpdateManyMutationInput, CapabilityCOTUncheckedUpdateManyInput>
    /**
     * Filter which CapabilityCOTS to update
     */
    where?: CapabilityCOTWhereInput
    /**
     * Limit how many CapabilityCOTS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapabilityCOT upsert
   */
  export type CapabilityCOTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * The filter to search for the CapabilityCOT to update in case it exists.
     */
    where: CapabilityCOTWhereUniqueInput
    /**
     * In case the CapabilityCOT found by the `where` argument doesn't exist, create a new CapabilityCOT with this data.
     */
    create: XOR<CapabilityCOTCreateInput, CapabilityCOTUncheckedCreateInput>
    /**
     * In case the CapabilityCOT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapabilityCOTUpdateInput, CapabilityCOTUncheckedUpdateInput>
  }

  /**
   * CapabilityCOT delete
   */
  export type CapabilityCOTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
    /**
     * Filter which CapabilityCOT to delete.
     */
    where: CapabilityCOTWhereUniqueInput
  }

  /**
   * CapabilityCOT deleteMany
   */
  export type CapabilityCOTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapabilityCOTS to delete
     */
    where?: CapabilityCOTWhereInput
    /**
     * Limit how many CapabilityCOTS to delete.
     */
    limit?: number
  }

  /**
   * CapabilityCOT without action
   */
  export type CapabilityCOTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityCOT
     */
    select?: CapabilityCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityCOT
     */
    omit?: CapabilityCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapabilityCOTInclude<ExtArgs> | null
  }


  /**
   * Model ParticipantsCOT
   */

  export type AggregateParticipantsCOT = {
    _count: ParticipantsCOTCountAggregateOutputType | null
    _min: ParticipantsCOTMinAggregateOutputType | null
    _max: ParticipantsCOTMaxAggregateOutputType | null
  }

  export type ParticipantsCOTMinAggregateOutputType = {
    id: string | null
    participantId: string | null
    cotId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipantsCOTMaxAggregateOutputType = {
    id: string | null
    participantId: string | null
    cotId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipantsCOTCountAggregateOutputType = {
    id: number
    participantId: number
    cotId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParticipantsCOTMinAggregateInputType = {
    id?: true
    participantId?: true
    cotId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipantsCOTMaxAggregateInputType = {
    id?: true
    participantId?: true
    cotId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipantsCOTCountAggregateInputType = {
    id?: true
    participantId?: true
    cotId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParticipantsCOTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParticipantsCOT to aggregate.
     */
    where?: ParticipantsCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipantsCOTS to fetch.
     */
    orderBy?: ParticipantsCOTOrderByWithRelationInput | ParticipantsCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipantsCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipantsCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipantsCOTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParticipantsCOTS
    **/
    _count?: true | ParticipantsCOTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipantsCOTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipantsCOTMaxAggregateInputType
  }

  export type GetParticipantsCOTAggregateType<T extends ParticipantsCOTAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipantsCOT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipantsCOT[P]>
      : GetScalarType<T[P], AggregateParticipantsCOT[P]>
  }




  export type ParticipantsCOTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantsCOTWhereInput
    orderBy?: ParticipantsCOTOrderByWithAggregationInput | ParticipantsCOTOrderByWithAggregationInput[]
    by: ParticipantsCOTScalarFieldEnum[] | ParticipantsCOTScalarFieldEnum
    having?: ParticipantsCOTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipantsCOTCountAggregateInputType | true
    _min?: ParticipantsCOTMinAggregateInputType
    _max?: ParticipantsCOTMaxAggregateInputType
  }

  export type ParticipantsCOTGroupByOutputType = {
    id: string
    participantId: string | null
    cotId: string
    createdAt: Date
    updatedAt: Date
    _count: ParticipantsCOTCountAggregateOutputType | null
    _min: ParticipantsCOTMinAggregateOutputType | null
    _max: ParticipantsCOTMaxAggregateOutputType | null
  }

  type GetParticipantsCOTGroupByPayload<T extends ParticipantsCOTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipantsCOTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipantsCOTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipantsCOTGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipantsCOTGroupByOutputType[P]>
        }
      >
    >


  export type ParticipantsCOTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    cotId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant?: boolean | ParticipantsCOT$participantArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participantsCOT"]>

  export type ParticipantsCOTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    cotId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant?: boolean | ParticipantsCOT$participantArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participantsCOT"]>

  export type ParticipantsCOTSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    cotId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant?: boolean | ParticipantsCOT$participantArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participantsCOT"]>

  export type ParticipantsCOTSelectScalar = {
    id?: boolean
    participantId?: boolean
    cotId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParticipantsCOTOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "participantId" | "cotId" | "createdAt" | "updatedAt", ExtArgs["result"]["participantsCOT"]>
  export type ParticipantsCOTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantsCOT$participantArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }
  export type ParticipantsCOTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantsCOT$participantArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }
  export type ParticipantsCOTIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantsCOT$participantArgs<ExtArgs>
    cot?: boolean | COTDefaultArgs<ExtArgs>
  }

  export type $ParticipantsCOTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParticipantsCOT"
    objects: {
      participant: Prisma.$ParticipantPayload<ExtArgs> | null
      cot: Prisma.$COTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participantId: string | null
      cotId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["participantsCOT"]>
    composites: {}
  }

  type ParticipantsCOTGetPayload<S extends boolean | null | undefined | ParticipantsCOTDefaultArgs> = $Result.GetResult<Prisma.$ParticipantsCOTPayload, S>

  type ParticipantsCOTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParticipantsCOTFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParticipantsCOTCountAggregateInputType | true
    }

  export interface ParticipantsCOTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParticipantsCOT'], meta: { name: 'ParticipantsCOT' } }
    /**
     * Find zero or one ParticipantsCOT that matches the filter.
     * @param {ParticipantsCOTFindUniqueArgs} args - Arguments to find a ParticipantsCOT
     * @example
     * // Get one ParticipantsCOT
     * const participantsCOT = await prisma.participantsCOT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParticipantsCOTFindUniqueArgs>(args: SelectSubset<T, ParticipantsCOTFindUniqueArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParticipantsCOT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParticipantsCOTFindUniqueOrThrowArgs} args - Arguments to find a ParticipantsCOT
     * @example
     * // Get one ParticipantsCOT
     * const participantsCOT = await prisma.participantsCOT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParticipantsCOTFindUniqueOrThrowArgs>(args: SelectSubset<T, ParticipantsCOTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParticipantsCOT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantsCOTFindFirstArgs} args - Arguments to find a ParticipantsCOT
     * @example
     * // Get one ParticipantsCOT
     * const participantsCOT = await prisma.participantsCOT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParticipantsCOTFindFirstArgs>(args?: SelectSubset<T, ParticipantsCOTFindFirstArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParticipantsCOT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantsCOTFindFirstOrThrowArgs} args - Arguments to find a ParticipantsCOT
     * @example
     * // Get one ParticipantsCOT
     * const participantsCOT = await prisma.participantsCOT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParticipantsCOTFindFirstOrThrowArgs>(args?: SelectSubset<T, ParticipantsCOTFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParticipantsCOTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantsCOTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParticipantsCOTS
     * const participantsCOTS = await prisma.participantsCOT.findMany()
     * 
     * // Get first 10 ParticipantsCOTS
     * const participantsCOTS = await prisma.participantsCOT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participantsCOTWithIdOnly = await prisma.participantsCOT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParticipantsCOTFindManyArgs>(args?: SelectSubset<T, ParticipantsCOTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParticipantsCOT.
     * @param {ParticipantsCOTCreateArgs} args - Arguments to create a ParticipantsCOT.
     * @example
     * // Create one ParticipantsCOT
     * const ParticipantsCOT = await prisma.participantsCOT.create({
     *   data: {
     *     // ... data to create a ParticipantsCOT
     *   }
     * })
     * 
     */
    create<T extends ParticipantsCOTCreateArgs>(args: SelectSubset<T, ParticipantsCOTCreateArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParticipantsCOTS.
     * @param {ParticipantsCOTCreateManyArgs} args - Arguments to create many ParticipantsCOTS.
     * @example
     * // Create many ParticipantsCOTS
     * const participantsCOT = await prisma.participantsCOT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParticipantsCOTCreateManyArgs>(args?: SelectSubset<T, ParticipantsCOTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParticipantsCOTS and returns the data saved in the database.
     * @param {ParticipantsCOTCreateManyAndReturnArgs} args - Arguments to create many ParticipantsCOTS.
     * @example
     * // Create many ParticipantsCOTS
     * const participantsCOT = await prisma.participantsCOT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParticipantsCOTS and only return the `id`
     * const participantsCOTWithIdOnly = await prisma.participantsCOT.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParticipantsCOTCreateManyAndReturnArgs>(args?: SelectSubset<T, ParticipantsCOTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParticipantsCOT.
     * @param {ParticipantsCOTDeleteArgs} args - Arguments to delete one ParticipantsCOT.
     * @example
     * // Delete one ParticipantsCOT
     * const ParticipantsCOT = await prisma.participantsCOT.delete({
     *   where: {
     *     // ... filter to delete one ParticipantsCOT
     *   }
     * })
     * 
     */
    delete<T extends ParticipantsCOTDeleteArgs>(args: SelectSubset<T, ParticipantsCOTDeleteArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParticipantsCOT.
     * @param {ParticipantsCOTUpdateArgs} args - Arguments to update one ParticipantsCOT.
     * @example
     * // Update one ParticipantsCOT
     * const participantsCOT = await prisma.participantsCOT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParticipantsCOTUpdateArgs>(args: SelectSubset<T, ParticipantsCOTUpdateArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParticipantsCOTS.
     * @param {ParticipantsCOTDeleteManyArgs} args - Arguments to filter ParticipantsCOTS to delete.
     * @example
     * // Delete a few ParticipantsCOTS
     * const { count } = await prisma.participantsCOT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParticipantsCOTDeleteManyArgs>(args?: SelectSubset<T, ParticipantsCOTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParticipantsCOTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantsCOTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParticipantsCOTS
     * const participantsCOT = await prisma.participantsCOT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParticipantsCOTUpdateManyArgs>(args: SelectSubset<T, ParticipantsCOTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParticipantsCOTS and returns the data updated in the database.
     * @param {ParticipantsCOTUpdateManyAndReturnArgs} args - Arguments to update many ParticipantsCOTS.
     * @example
     * // Update many ParticipantsCOTS
     * const participantsCOT = await prisma.participantsCOT.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParticipantsCOTS and only return the `id`
     * const participantsCOTWithIdOnly = await prisma.participantsCOT.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParticipantsCOTUpdateManyAndReturnArgs>(args: SelectSubset<T, ParticipantsCOTUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParticipantsCOT.
     * @param {ParticipantsCOTUpsertArgs} args - Arguments to update or create a ParticipantsCOT.
     * @example
     * // Update or create a ParticipantsCOT
     * const participantsCOT = await prisma.participantsCOT.upsert({
     *   create: {
     *     // ... data to create a ParticipantsCOT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParticipantsCOT we want to update
     *   }
     * })
     */
    upsert<T extends ParticipantsCOTUpsertArgs>(args: SelectSubset<T, ParticipantsCOTUpsertArgs<ExtArgs>>): Prisma__ParticipantsCOTClient<$Result.GetResult<Prisma.$ParticipantsCOTPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParticipantsCOTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantsCOTCountArgs} args - Arguments to filter ParticipantsCOTS to count.
     * @example
     * // Count the number of ParticipantsCOTS
     * const count = await prisma.participantsCOT.count({
     *   where: {
     *     // ... the filter for the ParticipantsCOTS we want to count
     *   }
     * })
    **/
    count<T extends ParticipantsCOTCountArgs>(
      args?: Subset<T, ParticipantsCOTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipantsCOTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParticipantsCOT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantsCOTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipantsCOTAggregateArgs>(args: Subset<T, ParticipantsCOTAggregateArgs>): Prisma.PrismaPromise<GetParticipantsCOTAggregateType<T>>

    /**
     * Group by ParticipantsCOT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantsCOTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipantsCOTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipantsCOTGroupByArgs['orderBy'] }
        : { orderBy?: ParticipantsCOTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipantsCOTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipantsCOTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParticipantsCOT model
   */
  readonly fields: ParticipantsCOTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParticipantsCOT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipantsCOTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends ParticipantsCOT$participantArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantsCOT$participantArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cot<T extends COTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, COTDefaultArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParticipantsCOT model
   */
  interface ParticipantsCOTFieldRefs {
    readonly id: FieldRef<"ParticipantsCOT", 'String'>
    readonly participantId: FieldRef<"ParticipantsCOT", 'String'>
    readonly cotId: FieldRef<"ParticipantsCOT", 'String'>
    readonly createdAt: FieldRef<"ParticipantsCOT", 'DateTime'>
    readonly updatedAt: FieldRef<"ParticipantsCOT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParticipantsCOT findUnique
   */
  export type ParticipantsCOTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * Filter, which ParticipantsCOT to fetch.
     */
    where: ParticipantsCOTWhereUniqueInput
  }

  /**
   * ParticipantsCOT findUniqueOrThrow
   */
  export type ParticipantsCOTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * Filter, which ParticipantsCOT to fetch.
     */
    where: ParticipantsCOTWhereUniqueInput
  }

  /**
   * ParticipantsCOT findFirst
   */
  export type ParticipantsCOTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * Filter, which ParticipantsCOT to fetch.
     */
    where?: ParticipantsCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipantsCOTS to fetch.
     */
    orderBy?: ParticipantsCOTOrderByWithRelationInput | ParticipantsCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParticipantsCOTS.
     */
    cursor?: ParticipantsCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipantsCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipantsCOTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParticipantsCOTS.
     */
    distinct?: ParticipantsCOTScalarFieldEnum | ParticipantsCOTScalarFieldEnum[]
  }

  /**
   * ParticipantsCOT findFirstOrThrow
   */
  export type ParticipantsCOTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * Filter, which ParticipantsCOT to fetch.
     */
    where?: ParticipantsCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipantsCOTS to fetch.
     */
    orderBy?: ParticipantsCOTOrderByWithRelationInput | ParticipantsCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParticipantsCOTS.
     */
    cursor?: ParticipantsCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipantsCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipantsCOTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParticipantsCOTS.
     */
    distinct?: ParticipantsCOTScalarFieldEnum | ParticipantsCOTScalarFieldEnum[]
  }

  /**
   * ParticipantsCOT findMany
   */
  export type ParticipantsCOTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * Filter, which ParticipantsCOTS to fetch.
     */
    where?: ParticipantsCOTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipantsCOTS to fetch.
     */
    orderBy?: ParticipantsCOTOrderByWithRelationInput | ParticipantsCOTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParticipantsCOTS.
     */
    cursor?: ParticipantsCOTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipantsCOTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipantsCOTS.
     */
    skip?: number
    distinct?: ParticipantsCOTScalarFieldEnum | ParticipantsCOTScalarFieldEnum[]
  }

  /**
   * ParticipantsCOT create
   */
  export type ParticipantsCOTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * The data needed to create a ParticipantsCOT.
     */
    data: XOR<ParticipantsCOTCreateInput, ParticipantsCOTUncheckedCreateInput>
  }

  /**
   * ParticipantsCOT createMany
   */
  export type ParticipantsCOTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParticipantsCOTS.
     */
    data: ParticipantsCOTCreateManyInput | ParticipantsCOTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParticipantsCOT createManyAndReturn
   */
  export type ParticipantsCOTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * The data used to create many ParticipantsCOTS.
     */
    data: ParticipantsCOTCreateManyInput | ParticipantsCOTCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParticipantsCOT update
   */
  export type ParticipantsCOTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * The data needed to update a ParticipantsCOT.
     */
    data: XOR<ParticipantsCOTUpdateInput, ParticipantsCOTUncheckedUpdateInput>
    /**
     * Choose, which ParticipantsCOT to update.
     */
    where: ParticipantsCOTWhereUniqueInput
  }

  /**
   * ParticipantsCOT updateMany
   */
  export type ParticipantsCOTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParticipantsCOTS.
     */
    data: XOR<ParticipantsCOTUpdateManyMutationInput, ParticipantsCOTUncheckedUpdateManyInput>
    /**
     * Filter which ParticipantsCOTS to update
     */
    where?: ParticipantsCOTWhereInput
    /**
     * Limit how many ParticipantsCOTS to update.
     */
    limit?: number
  }

  /**
   * ParticipantsCOT updateManyAndReturn
   */
  export type ParticipantsCOTUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * The data used to update ParticipantsCOTS.
     */
    data: XOR<ParticipantsCOTUpdateManyMutationInput, ParticipantsCOTUncheckedUpdateManyInput>
    /**
     * Filter which ParticipantsCOTS to update
     */
    where?: ParticipantsCOTWhereInput
    /**
     * Limit how many ParticipantsCOTS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParticipantsCOT upsert
   */
  export type ParticipantsCOTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * The filter to search for the ParticipantsCOT to update in case it exists.
     */
    where: ParticipantsCOTWhereUniqueInput
    /**
     * In case the ParticipantsCOT found by the `where` argument doesn't exist, create a new ParticipantsCOT with this data.
     */
    create: XOR<ParticipantsCOTCreateInput, ParticipantsCOTUncheckedCreateInput>
    /**
     * In case the ParticipantsCOT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipantsCOTUpdateInput, ParticipantsCOTUncheckedUpdateInput>
  }

  /**
   * ParticipantsCOT delete
   */
  export type ParticipantsCOTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
    /**
     * Filter which ParticipantsCOT to delete.
     */
    where: ParticipantsCOTWhereUniqueInput
  }

  /**
   * ParticipantsCOT deleteMany
   */
  export type ParticipantsCOTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParticipantsCOTS to delete
     */
    where?: ParticipantsCOTWhereInput
    /**
     * Limit how many ParticipantsCOTS to delete.
     */
    limit?: number
  }

  /**
   * ParticipantsCOT.participant
   */
  export type ParticipantsCOT$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * ParticipantsCOT without action
   */
  export type ParticipantsCOTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantsCOT
     */
    select?: ParticipantsCOTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParticipantsCOT
     */
    omit?: ParticipantsCOTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantsCOTInclude<ExtArgs> | null
  }


  /**
   * Model Signature
   */

  export type AggregateSignature = {
    _count: SignatureCountAggregateOutputType | null
    _avg: SignatureAvgAggregateOutputType | null
    _sum: SignatureSumAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  export type SignatureAvgAggregateOutputType = {
    eSignId: number | null
  }

  export type SignatureSumAggregateOutputType = {
    eSignId: number | null
  }

  export type SignatureMinAggregateOutputType = {
    id: string | null
    idNumber: string | null
    role: string | null
    name: string | null
    eSignId: number | null
    signatureType: $Enums.SignatureType | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SignatureMaxAggregateOutputType = {
    id: string | null
    idNumber: string | null
    role: string | null
    name: string | null
    eSignId: number | null
    signatureType: $Enums.SignatureType | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SignatureCountAggregateOutputType = {
    id: number
    idNumber: number
    role: number
    name: number
    eSignId: number
    signatureType: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SignatureAvgAggregateInputType = {
    eSignId?: true
  }

  export type SignatureSumAggregateInputType = {
    eSignId?: true
  }

  export type SignatureMinAggregateInputType = {
    id?: true
    idNumber?: true
    role?: true
    name?: true
    eSignId?: true
    signatureType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SignatureMaxAggregateInputType = {
    id?: true
    idNumber?: true
    role?: true
    name?: true
    eSignId?: true
    signatureType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SignatureCountAggregateInputType = {
    id?: true
    idNumber?: true
    role?: true
    name?: true
    eSignId?: true
    signatureType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signature to aggregate.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signatures
    **/
    _count?: true | SignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignatureMaxAggregateInputType
  }

  export type GetSignatureAggregateType<T extends SignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignature[P]>
      : GetScalarType<T[P], AggregateSignature[P]>
  }




  export type SignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithAggregationInput | SignatureOrderByWithAggregationInput[]
    by: SignatureScalarFieldEnum[] | SignatureScalarFieldEnum
    having?: SignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignatureCountAggregateInputType | true
    _avg?: SignatureAvgAggregateInputType
    _sum?: SignatureSumAggregateInputType
    _min?: SignatureMinAggregateInputType
    _max?: SignatureMaxAggregateInputType
  }

  export type SignatureGroupByOutputType = {
    id: string
    idNumber: string
    role: string
    name: string
    eSignId: number | null
    signatureType: $Enums.SignatureType
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: SignatureCountAggregateOutputType | null
    _avg: SignatureAvgAggregateOutputType | null
    _sum: SignatureSumAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  type GetSignatureGroupByPayload<T extends SignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignatureGroupByOutputType[P]>
            : GetScalarType<T[P], SignatureGroupByOutputType[P]>
        }
      >
    >


  export type SignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idNumber?: boolean
    role?: boolean
    name?: boolean
    eSignId?: boolean
    signatureType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eSign?: boolean | Signature$eSignArgs<ExtArgs>
    certificates?: boolean | Signature$certificatesArgs<ExtArgs>
    _count?: boolean | SignatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signature"]>

  export type SignatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idNumber?: boolean
    role?: boolean
    name?: boolean
    eSignId?: boolean
    signatureType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eSign?: boolean | Signature$eSignArgs<ExtArgs>
  }, ExtArgs["result"]["signature"]>

  export type SignatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idNumber?: boolean
    role?: boolean
    name?: boolean
    eSignId?: boolean
    signatureType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eSign?: boolean | Signature$eSignArgs<ExtArgs>
  }, ExtArgs["result"]["signature"]>

  export type SignatureSelectScalar = {
    id?: boolean
    idNumber?: boolean
    role?: boolean
    name?: boolean
    eSignId?: boolean
    signatureType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SignatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idNumber" | "role" | "name" | "eSignId" | "signatureType" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["signature"]>
  export type SignatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eSign?: boolean | Signature$eSignArgs<ExtArgs>
    certificates?: boolean | Signature$certificatesArgs<ExtArgs>
    _count?: boolean | SignatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SignatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eSign?: boolean | Signature$eSignArgs<ExtArgs>
  }
  export type SignatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eSign?: boolean | Signature$eSignArgs<ExtArgs>
  }

  export type $SignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signature"
    objects: {
      eSign: Prisma.$FileMetadataPayload<ExtArgs> | null
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idNumber: string
      role: string
      name: string
      eSignId: number | null
      signatureType: $Enums.SignatureType
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["signature"]>
    composites: {}
  }

  type SignatureGetPayload<S extends boolean | null | undefined | SignatureDefaultArgs> = $Result.GetResult<Prisma.$SignaturePayload, S>

  type SignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignatureCountAggregateInputType | true
    }

  export interface SignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signature'], meta: { name: 'Signature' } }
    /**
     * Find zero or one Signature that matches the filter.
     * @param {SignatureFindUniqueArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignatureFindUniqueArgs>(args: SelectSubset<T, SignatureFindUniqueArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignatureFindUniqueOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignatureFindFirstArgs>(args?: SelectSubset<T, SignatureFindFirstArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signatures
     * const signatures = await prisma.signature.findMany()
     * 
     * // Get first 10 Signatures
     * const signatures = await prisma.signature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signatureWithIdOnly = await prisma.signature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignatureFindManyArgs>(args?: SelectSubset<T, SignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signature.
     * @param {SignatureCreateArgs} args - Arguments to create a Signature.
     * @example
     * // Create one Signature
     * const Signature = await prisma.signature.create({
     *   data: {
     *     // ... data to create a Signature
     *   }
     * })
     * 
     */
    create<T extends SignatureCreateArgs>(args: SelectSubset<T, SignatureCreateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signatures.
     * @param {SignatureCreateManyArgs} args - Arguments to create many Signatures.
     * @example
     * // Create many Signatures
     * const signature = await prisma.signature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignatureCreateManyArgs>(args?: SelectSubset<T, SignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signatures and returns the data saved in the database.
     * @param {SignatureCreateManyAndReturnArgs} args - Arguments to create many Signatures.
     * @example
     * // Create many Signatures
     * const signature = await prisma.signature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signatures and only return the `id`
     * const signatureWithIdOnly = await prisma.signature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignatureCreateManyAndReturnArgs>(args?: SelectSubset<T, SignatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signature.
     * @param {SignatureDeleteArgs} args - Arguments to delete one Signature.
     * @example
     * // Delete one Signature
     * const Signature = await prisma.signature.delete({
     *   where: {
     *     // ... filter to delete one Signature
     *   }
     * })
     * 
     */
    delete<T extends SignatureDeleteArgs>(args: SelectSubset<T, SignatureDeleteArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signature.
     * @param {SignatureUpdateArgs} args - Arguments to update one Signature.
     * @example
     * // Update one Signature
     * const signature = await prisma.signature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignatureUpdateArgs>(args: SelectSubset<T, SignatureUpdateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signatures.
     * @param {SignatureDeleteManyArgs} args - Arguments to filter Signatures to delete.
     * @example
     * // Delete a few Signatures
     * const { count } = await prisma.signature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignatureDeleteManyArgs>(args?: SelectSubset<T, SignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signatures
     * const signature = await prisma.signature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignatureUpdateManyArgs>(args: SelectSubset<T, SignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signatures and returns the data updated in the database.
     * @param {SignatureUpdateManyAndReturnArgs} args - Arguments to update many Signatures.
     * @example
     * // Update many Signatures
     * const signature = await prisma.signature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signatures and only return the `id`
     * const signatureWithIdOnly = await prisma.signature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SignatureUpdateManyAndReturnArgs>(args: SelectSubset<T, SignatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signature.
     * @param {SignatureUpsertArgs} args - Arguments to update or create a Signature.
     * @example
     * // Update or create a Signature
     * const signature = await prisma.signature.upsert({
     *   create: {
     *     // ... data to create a Signature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signature we want to update
     *   }
     * })
     */
    upsert<T extends SignatureUpsertArgs>(args: SelectSubset<T, SignatureUpsertArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureCountArgs} args - Arguments to filter Signatures to count.
     * @example
     * // Count the number of Signatures
     * const count = await prisma.signature.count({
     *   where: {
     *     // ... the filter for the Signatures we want to count
     *   }
     * })
    **/
    count<T extends SignatureCountArgs>(
      args?: Subset<T, SignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignatureAggregateArgs>(args: Subset<T, SignatureAggregateArgs>): Prisma.PrismaPromise<GetSignatureAggregateType<T>>

    /**
     * Group by Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignatureGroupByArgs['orderBy'] }
        : { orderBy?: SignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signature model
   */
  readonly fields: SignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eSign<T extends Signature$eSignArgs<ExtArgs> = {}>(args?: Subset<T, Signature$eSignArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    certificates<T extends Signature$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Signature$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signature model
   */
  interface SignatureFieldRefs {
    readonly id: FieldRef<"Signature", 'String'>
    readonly idNumber: FieldRef<"Signature", 'String'>
    readonly role: FieldRef<"Signature", 'String'>
    readonly name: FieldRef<"Signature", 'String'>
    readonly eSignId: FieldRef<"Signature", 'Int'>
    readonly signatureType: FieldRef<"Signature", 'SignatureType'>
    readonly status: FieldRef<"Signature", 'Boolean'>
    readonly createdAt: FieldRef<"Signature", 'DateTime'>
    readonly updatedAt: FieldRef<"Signature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Signature findUnique
   */
  export type SignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findUniqueOrThrow
   */
  export type SignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findFirst
   */
  export type SignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findFirstOrThrow
   */
  export type SignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findMany
   */
  export type SignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signatures to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature create
   */
  export type SignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Signature.
     */
    data: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
  }

  /**
   * Signature createMany
   */
  export type SignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signatures.
     */
    data: SignatureCreateManyInput | SignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signature createManyAndReturn
   */
  export type SignatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * The data used to create many Signatures.
     */
    data: SignatureCreateManyInput | SignatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signature update
   */
  export type SignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Signature.
     */
    data: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
    /**
     * Choose, which Signature to update.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature updateMany
   */
  export type SignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signatures.
     */
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyInput>
    /**
     * Filter which Signatures to update
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to update.
     */
    limit?: number
  }

  /**
   * Signature updateManyAndReturn
   */
  export type SignatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * The data used to update Signatures.
     */
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyInput>
    /**
     * Filter which Signatures to update
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signature upsert
   */
  export type SignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Signature to update in case it exists.
     */
    where: SignatureWhereUniqueInput
    /**
     * In case the Signature found by the `where` argument doesn't exist, create a new Signature with this data.
     */
    create: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
    /**
     * In case the Signature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
  }

  /**
   * Signature delete
   */
  export type SignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter which Signature to delete.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature deleteMany
   */
  export type SignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signatures to delete
     */
    where?: SignatureWhereInput
    /**
     * Limit how many Signatures to delete.
     */
    limit?: number
  }

  /**
   * Signature.eSign
   */
  export type Signature$eSignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
  }

  /**
   * Signature.certificates
   */
  export type Signature$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Signature without action
   */
  export type SignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signature
     */
    omit?: SignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    theoryScore: number | null
    practiceScore: number | null
  }

  export type CertificateSumAggregateOutputType = {
    theoryScore: number | null
    practiceScore: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    cotId: string | null
    signatureId: string | null
    participantId: string | null
    issuedDate: Date | null
    certificateNumber: string | null
    attendance: boolean | null
    theoryScore: number | null
    practiceScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    cotId: string | null
    signatureId: string | null
    participantId: string | null
    issuedDate: Date | null
    certificateNumber: string | null
    attendance: boolean | null
    theoryScore: number | null
    practiceScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    cotId: number
    signatureId: number
    participantId: number
    issuedDate: number
    certificateNumber: number
    attendance: number
    theoryScore: number
    practiceScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    theoryScore?: true
    practiceScore?: true
  }

  export type CertificateSumAggregateInputType = {
    theoryScore?: true
    practiceScore?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    cotId?: true
    signatureId?: true
    participantId?: true
    issuedDate?: true
    certificateNumber?: true
    attendance?: true
    theoryScore?: true
    practiceScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    cotId?: true
    signatureId?: true
    participantId?: true
    issuedDate?: true
    certificateNumber?: true
    attendance?: true
    theoryScore?: true
    practiceScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    cotId?: true
    signatureId?: true
    participantId?: true
    issuedDate?: true
    certificateNumber?: true
    attendance?: true
    theoryScore?: true
    practiceScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    cotId: string
    signatureId: string
    participantId: string
    issuedDate: Date
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt: Date
    updatedAt: Date
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cotId?: boolean
    signatureId?: boolean
    participantId?: boolean
    issuedDate?: boolean
    certificateNumber?: boolean
    attendance?: boolean
    theoryScore?: boolean
    practiceScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cot?: boolean | COTDefaultArgs<ExtArgs>
    signature?: boolean | SignatureDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cotId?: boolean
    signatureId?: boolean
    participantId?: boolean
    issuedDate?: boolean
    certificateNumber?: boolean
    attendance?: boolean
    theoryScore?: boolean
    practiceScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cot?: boolean | COTDefaultArgs<ExtArgs>
    signature?: boolean | SignatureDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cotId?: boolean
    signatureId?: boolean
    participantId?: boolean
    issuedDate?: boolean
    certificateNumber?: boolean
    attendance?: boolean
    theoryScore?: boolean
    practiceScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cot?: boolean | COTDefaultArgs<ExtArgs>
    signature?: boolean | SignatureDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    cotId?: boolean
    signatureId?: boolean
    participantId?: boolean
    issuedDate?: boolean
    certificateNumber?: boolean
    attendance?: boolean
    theoryScore?: boolean
    practiceScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cotId" | "signatureId" | "participantId" | "issuedDate" | "certificateNumber" | "attendance" | "theoryScore" | "practiceScore" | "createdAt" | "updatedAt", ExtArgs["result"]["certificate"]>
  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cot?: boolean | COTDefaultArgs<ExtArgs>
    signature?: boolean | SignatureDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cot?: boolean | COTDefaultArgs<ExtArgs>
    signature?: boolean | SignatureDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cot?: boolean | COTDefaultArgs<ExtArgs>
    signature?: boolean | SignatureDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      cot: Prisma.$COTPayload<ExtArgs>
      signature: Prisma.$SignaturePayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cotId: string
      signatureId: string
      participantId: string
      issuedDate: Date
      certificateNumber: string
      attendance: boolean
      theoryScore: number
      practiceScore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cot<T extends COTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, COTDefaultArgs<ExtArgs>>): Prisma__COTClient<$Result.GetResult<Prisma.$COTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    signature<T extends SignatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SignatureDefaultArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly cotId: FieldRef<"Certificate", 'String'>
    readonly signatureId: FieldRef<"Certificate", 'String'>
    readonly participantId: FieldRef<"Certificate", 'String'>
    readonly issuedDate: FieldRef<"Certificate", 'DateTime'>
    readonly certificateNumber: FieldRef<"Certificate", 'String'>
    readonly attendance: FieldRef<"Certificate", 'Boolean'>
    readonly theoryScore: FieldRef<"Certificate", 'Float'>
    readonly practiceScore: FieldRef<"Certificate", 'Float'>
    readonly createdAt: FieldRef<"Certificate", 'DateTime'>
    readonly updatedAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
  }

  /**
   * Certificate updateManyAndReturn
   */
  export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to delete.
     */
    limit?: number
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    sessionId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    sessionId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    sessionId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    sessionId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    sessionId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    sessionId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    sessionId: string | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    sessionId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    sessionId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    sessionId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    sessionId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "sessionId" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      sessionId: string | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly sessionId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model BlacklistedToken
   */

  export type AggregateBlacklistedToken = {
    _count: BlacklistedTokenCountAggregateOutputType | null
    _min: BlacklistedTokenMinAggregateOutputType | null
    _max: BlacklistedTokenMaxAggregateOutputType | null
  }

  export type BlacklistedTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type BlacklistedTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type BlacklistedTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type BlacklistedTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type BlacklistedTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type BlacklistedTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type BlacklistedTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistedToken to aggregate.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlacklistedTokens
    **/
    _count?: true | BlacklistedTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklistedTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklistedTokenMaxAggregateInputType
  }

  export type GetBlacklistedTokenAggregateType<T extends BlacklistedTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklistedToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklistedToken[P]>
      : GetScalarType<T[P], AggregateBlacklistedToken[P]>
  }




  export type BlacklistedTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistedTokenWhereInput
    orderBy?: BlacklistedTokenOrderByWithAggregationInput | BlacklistedTokenOrderByWithAggregationInput[]
    by: BlacklistedTokenScalarFieldEnum[] | BlacklistedTokenScalarFieldEnum
    having?: BlacklistedTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklistedTokenCountAggregateInputType | true
    _min?: BlacklistedTokenMinAggregateInputType
    _max?: BlacklistedTokenMaxAggregateInputType
  }

  export type BlacklistedTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    createdAt: Date
    expiresAt: Date
    _count: BlacklistedTokenCountAggregateOutputType | null
    _min: BlacklistedTokenMinAggregateOutputType | null
    _max: BlacklistedTokenMaxAggregateOutputType | null
  }

  type GetBlacklistedTokenGroupByPayload<T extends BlacklistedTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklistedTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklistedTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklistedTokenGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklistedTokenGroupByOutputType[P]>
        }
      >
    >


  export type BlacklistedTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklistedToken"]>

  export type BlacklistedTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklistedToken"]>

  export type BlacklistedTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklistedToken"]>

  export type BlacklistedTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type BlacklistedTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "createdAt" | "expiresAt", ExtArgs["result"]["blacklistedToken"]>
  export type BlacklistedTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlacklistedTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlacklistedTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlacklistedTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlacklistedToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["blacklistedToken"]>
    composites: {}
  }

  type BlacklistedTokenGetPayload<S extends boolean | null | undefined | BlacklistedTokenDefaultArgs> = $Result.GetResult<Prisma.$BlacklistedTokenPayload, S>

  type BlacklistedTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlacklistedTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlacklistedTokenCountAggregateInputType | true
    }

  export interface BlacklistedTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlacklistedToken'], meta: { name: 'BlacklistedToken' } }
    /**
     * Find zero or one BlacklistedToken that matches the filter.
     * @param {BlacklistedTokenFindUniqueArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlacklistedTokenFindUniqueArgs>(args: SelectSubset<T, BlacklistedTokenFindUniqueArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlacklistedToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlacklistedTokenFindUniqueOrThrowArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlacklistedTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlacklistedToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindFirstArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlacklistedTokenFindFirstArgs>(args?: SelectSubset<T, BlacklistedTokenFindFirstArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlacklistedToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindFirstOrThrowArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlacklistedTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, BlacklistedTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlacklistedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlacklistedTokens
     * const blacklistedTokens = await prisma.blacklistedToken.findMany()
     * 
     * // Get first 10 BlacklistedTokens
     * const blacklistedTokens = await prisma.blacklistedToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blacklistedTokenWithIdOnly = await prisma.blacklistedToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlacklistedTokenFindManyArgs>(args?: SelectSubset<T, BlacklistedTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlacklistedToken.
     * @param {BlacklistedTokenCreateArgs} args - Arguments to create a BlacklistedToken.
     * @example
     * // Create one BlacklistedToken
     * const BlacklistedToken = await prisma.blacklistedToken.create({
     *   data: {
     *     // ... data to create a BlacklistedToken
     *   }
     * })
     * 
     */
    create<T extends BlacklistedTokenCreateArgs>(args: SelectSubset<T, BlacklistedTokenCreateArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlacklistedTokens.
     * @param {BlacklistedTokenCreateManyArgs} args - Arguments to create many BlacklistedTokens.
     * @example
     * // Create many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlacklistedTokenCreateManyArgs>(args?: SelectSubset<T, BlacklistedTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlacklistedTokens and returns the data saved in the database.
     * @param {BlacklistedTokenCreateManyAndReturnArgs} args - Arguments to create many BlacklistedTokens.
     * @example
     * // Create many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlacklistedTokens and only return the `id`
     * const blacklistedTokenWithIdOnly = await prisma.blacklistedToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlacklistedTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, BlacklistedTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlacklistedToken.
     * @param {BlacklistedTokenDeleteArgs} args - Arguments to delete one BlacklistedToken.
     * @example
     * // Delete one BlacklistedToken
     * const BlacklistedToken = await prisma.blacklistedToken.delete({
     *   where: {
     *     // ... filter to delete one BlacklistedToken
     *   }
     * })
     * 
     */
    delete<T extends BlacklistedTokenDeleteArgs>(args: SelectSubset<T, BlacklistedTokenDeleteArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlacklistedToken.
     * @param {BlacklistedTokenUpdateArgs} args - Arguments to update one BlacklistedToken.
     * @example
     * // Update one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlacklistedTokenUpdateArgs>(args: SelectSubset<T, BlacklistedTokenUpdateArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlacklistedTokens.
     * @param {BlacklistedTokenDeleteManyArgs} args - Arguments to filter BlacklistedTokens to delete.
     * @example
     * // Delete a few BlacklistedTokens
     * const { count } = await prisma.blacklistedToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlacklistedTokenDeleteManyArgs>(args?: SelectSubset<T, BlacklistedTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlacklistedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlacklistedTokenUpdateManyArgs>(args: SelectSubset<T, BlacklistedTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlacklistedTokens and returns the data updated in the database.
     * @param {BlacklistedTokenUpdateManyAndReturnArgs} args - Arguments to update many BlacklistedTokens.
     * @example
     * // Update many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlacklistedTokens and only return the `id`
     * const blacklistedTokenWithIdOnly = await prisma.blacklistedToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlacklistedTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, BlacklistedTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlacklistedToken.
     * @param {BlacklistedTokenUpsertArgs} args - Arguments to update or create a BlacklistedToken.
     * @example
     * // Update or create a BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.upsert({
     *   create: {
     *     // ... data to create a BlacklistedToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlacklistedToken we want to update
     *   }
     * })
     */
    upsert<T extends BlacklistedTokenUpsertArgs>(args: SelectSubset<T, BlacklistedTokenUpsertArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlacklistedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenCountArgs} args - Arguments to filter BlacklistedTokens to count.
     * @example
     * // Count the number of BlacklistedTokens
     * const count = await prisma.blacklistedToken.count({
     *   where: {
     *     // ... the filter for the BlacklistedTokens we want to count
     *   }
     * })
    **/
    count<T extends BlacklistedTokenCountArgs>(
      args?: Subset<T, BlacklistedTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklistedTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlacklistedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklistedTokenAggregateArgs>(args: Subset<T, BlacklistedTokenAggregateArgs>): Prisma.PrismaPromise<GetBlacklistedTokenAggregateType<T>>

    /**
     * Group by BlacklistedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlacklistedTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlacklistedTokenGroupByArgs['orderBy'] }
        : { orderBy?: BlacklistedTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlacklistedTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklistedTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlacklistedToken model
   */
  readonly fields: BlacklistedTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlacklistedToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlacklistedTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlacklistedToken model
   */
  interface BlacklistedTokenFieldRefs {
    readonly id: FieldRef<"BlacklistedToken", 'String'>
    readonly token: FieldRef<"BlacklistedToken", 'String'>
    readonly userId: FieldRef<"BlacklistedToken", 'String'>
    readonly createdAt: FieldRef<"BlacklistedToken", 'DateTime'>
    readonly expiresAt: FieldRef<"BlacklistedToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlacklistedToken findUnique
   */
  export type BlacklistedTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken findUniqueOrThrow
   */
  export type BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken findFirst
   */
  export type BlacklistedTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistedTokens.
     */
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }

  /**
   * BlacklistedToken findFirstOrThrow
   */
  export type BlacklistedTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistedTokens.
     */
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }

  /**
   * BlacklistedToken findMany
   */
  export type BlacklistedTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistedTokens to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }

  /**
   * BlacklistedToken create
   */
  export type BlacklistedTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a BlacklistedToken.
     */
    data: XOR<BlacklistedTokenCreateInput, BlacklistedTokenUncheckedCreateInput>
  }

  /**
   * BlacklistedToken createMany
   */
  export type BlacklistedTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlacklistedTokens.
     */
    data: BlacklistedTokenCreateManyInput | BlacklistedTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlacklistedToken createManyAndReturn
   */
  export type BlacklistedTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * The data used to create many BlacklistedTokens.
     */
    data: BlacklistedTokenCreateManyInput | BlacklistedTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlacklistedToken update
   */
  export type BlacklistedTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a BlacklistedToken.
     */
    data: XOR<BlacklistedTokenUpdateInput, BlacklistedTokenUncheckedUpdateInput>
    /**
     * Choose, which BlacklistedToken to update.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken updateMany
   */
  export type BlacklistedTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlacklistedTokens.
     */
    data: XOR<BlacklistedTokenUpdateManyMutationInput, BlacklistedTokenUncheckedUpdateManyInput>
    /**
     * Filter which BlacklistedTokens to update
     */
    where?: BlacklistedTokenWhereInput
    /**
     * Limit how many BlacklistedTokens to update.
     */
    limit?: number
  }

  /**
   * BlacklistedToken updateManyAndReturn
   */
  export type BlacklistedTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * The data used to update BlacklistedTokens.
     */
    data: XOR<BlacklistedTokenUpdateManyMutationInput, BlacklistedTokenUncheckedUpdateManyInput>
    /**
     * Filter which BlacklistedTokens to update
     */
    where?: BlacklistedTokenWhereInput
    /**
     * Limit how many BlacklistedTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlacklistedToken upsert
   */
  export type BlacklistedTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the BlacklistedToken to update in case it exists.
     */
    where: BlacklistedTokenWhereUniqueInput
    /**
     * In case the BlacklistedToken found by the `where` argument doesn't exist, create a new BlacklistedToken with this data.
     */
    create: XOR<BlacklistedTokenCreateInput, BlacklistedTokenUncheckedCreateInput>
    /**
     * In case the BlacklistedToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlacklistedTokenUpdateInput, BlacklistedTokenUncheckedUpdateInput>
  }

  /**
   * BlacklistedToken delete
   */
  export type BlacklistedTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
    /**
     * Filter which BlacklistedToken to delete.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken deleteMany
   */
  export type BlacklistedTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistedTokens to delete
     */
    where?: BlacklistedTokenWhereInput
    /**
     * Limit how many BlacklistedTokens to delete.
     */
    limit?: number
  }

  /**
   * BlacklistedToken without action
   */
  export type BlacklistedTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistedTokenInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    details: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "details" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    idNumber: 'idNumber',
    name: 'name',
    nik: 'nik',
    dinas: 'dinas',
    password: 'password',
    photo: 'photo',
    hashAlgorithm: 'hashAlgorithm',
    roleId: 'roleId',
    participantId: 'participantId',
    verifiedAccount: 'verifiedAccount',
    accountVerificationToken: 'accountVerificationToken',
    verificationSentAt: 'verificationSentAt',
    passwordResetToken: 'passwordResetToken',
    updateEmailToken: 'updateEmailToken',
    loginAttempts: 'loginAttempts',
    lockUntil: 'lockUntil',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    oauthProvider: 'oauthProvider',
    oauthId: 'oauthId',
    oauthRefreshToken: 'oauthRefreshToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const OAuthStateScalarFieldEnum: {
    id: 'id',
    state: 'state',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    provider: 'provider'
  };

  export type OAuthStateScalarFieldEnum = (typeof OAuthStateScalarFieldEnum)[keyof typeof OAuthStateScalarFieldEnum]


  export const AppConfigScalarFieldEnum: {
    id: 'id',
    frontendUrl: 'frontendUrl',
    backendUrl: 'backendUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppConfigScalarFieldEnum = (typeof AppConfigScalarFieldEnum)[keyof typeof AppConfigScalarFieldEnum]


  export const FileMetadataScalarFieldEnum: {
    id: 'id',
    path: 'path',
    fileName: 'fileName',
    mimeType: 'mimeType',
    fileSize: 'fileSize',
    storageType: 'storageType',
    iv: 'iv',
    isSensitive: 'isSensitive',
    createdAt: 'createdAt',
    participantSimAId: 'participantSimAId',
    participantSimBId: 'participantSimBId',
    participantKtpId: 'participantKtpId',
    participantFotoId: 'participantFotoId',
    participantSuratSehatButaWarnaId: 'participantSuratSehatButaWarnaId',
    participantSuratBebasNarkobaId: 'participantSuratBebasNarkobaId',
    participantQrCodeId: 'participantQrCodeId'
  };

  export type FileMetadataScalarFieldEnum = (typeof FileMetadataScalarFieldEnum)[keyof typeof FileMetadataScalarFieldEnum]


  export const ParticipantScalarFieldEnum: {
    id: 'id',
    idNumber: 'idNumber',
    name: 'name',
    nik: 'nik',
    dinas: 'dinas',
    bidang: 'bidang',
    company: 'company',
    email: 'email',
    phoneNumber: 'phoneNumber',
    nationality: 'nationality',
    placeOfBirth: 'placeOfBirth',
    dateOfBirth: 'dateOfBirth',
    qrCodeLink: 'qrCodeLink',
    tglKeluarSuratSehatButaWarna: 'tglKeluarSuratSehatButaWarna',
    tglKeluarSuratBebasNarkoba: 'tglKeluarSuratBebasNarkoba',
    gmfNonGmf: 'gmfNonGmf',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParticipantScalarFieldEnum = (typeof ParticipantScalarFieldEnum)[keyof typeof ParticipantScalarFieldEnum]


  export const CapabilityScalarFieldEnum: {
    id: 'id',
    ratingCode: 'ratingCode',
    trainingCode: 'trainingCode',
    trainingName: 'trainingName',
    totalTheoryDurationRegGse: 'totalTheoryDurationRegGse',
    totalPracticeDurationRegGse: 'totalPracticeDurationRegGse',
    totalTheoryDurationCompetency: 'totalTheoryDurationCompetency',
    totalPracticeDurationCompetency: 'totalPracticeDurationCompetency',
    totalDuration: 'totalDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CapabilityScalarFieldEnum = (typeof CapabilityScalarFieldEnum)[keyof typeof CapabilityScalarFieldEnum]


  export const CurriculumSyllabusScalarFieldEnum: {
    id: 'id',
    capabilityId: 'capabilityId',
    name: 'name',
    theoryDuration: 'theoryDuration',
    practiceDuration: 'practiceDuration',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurriculumSyllabusScalarFieldEnum = (typeof CurriculumSyllabusScalarFieldEnum)[keyof typeof CurriculumSyllabusScalarFieldEnum]


  export const COTScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    trainingLocation: 'trainingLocation',
    theoryInstructorRegGse: 'theoryInstructorRegGse',
    theoryInstructorCompetency: 'theoryInstructorCompetency',
    practicalInstructor1: 'practicalInstructor1',
    practicalInstructor2: 'practicalInstructor2',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type COTScalarFieldEnum = (typeof COTScalarFieldEnum)[keyof typeof COTScalarFieldEnum]


  export const CapabilityCOTScalarFieldEnum: {
    capabilityId: 'capabilityId',
    cotId: 'cotId'
  };

  export type CapabilityCOTScalarFieldEnum = (typeof CapabilityCOTScalarFieldEnum)[keyof typeof CapabilityCOTScalarFieldEnum]


  export const ParticipantsCOTScalarFieldEnum: {
    id: 'id',
    participantId: 'participantId',
    cotId: 'cotId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParticipantsCOTScalarFieldEnum = (typeof ParticipantsCOTScalarFieldEnum)[keyof typeof ParticipantsCOTScalarFieldEnum]


  export const SignatureScalarFieldEnum: {
    id: 'id',
    idNumber: 'idNumber',
    role: 'role',
    name: 'name',
    eSignId: 'eSignId',
    signatureType: 'signatureType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SignatureScalarFieldEnum = (typeof SignatureScalarFieldEnum)[keyof typeof SignatureScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    cotId: 'cotId',
    signatureId: 'signatureId',
    participantId: 'participantId',
    issuedDate: 'issuedDate',
    certificateNumber: 'certificateNumber',
    attendance: 'attendance',
    theoryScore: 'theoryScore',
    practiceScore: 'practiceScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    sessionId: 'sessionId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const BlacklistedTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type BlacklistedTokenScalarFieldEnum = (typeof BlacklistedTokenScalarFieldEnum)[keyof typeof BlacklistedTokenScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OAuthProvider'
   */
  export type EnumOAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OAuthProvider'>
    


  /**
   * Reference to a field of type 'OAuthProvider[]'
   */
  export type ListEnumOAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OAuthProvider[]'>
    


  /**
   * Reference to a field of type 'SignatureType'
   */
  export type EnumSignatureTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignatureType'>
    


  /**
   * Reference to a field of type 'SignatureType[]'
   */
  export type ListEnumSignatureTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SignatureType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    idNumber?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    nik?: StringNullableFilter<"User"> | string | null
    dinas?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    hashAlgorithm?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    participantId?: StringNullableFilter<"User"> | string | null
    verifiedAccount?: BoolFilter<"User"> | boolean
    accountVerificationToken?: StringNullableFilter<"User"> | string | null
    verificationSentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    updateEmailToken?: StringNullableFilter<"User"> | string | null
    loginAttempts?: IntFilter<"User"> | number
    lockUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    oauthProvider?: EnumOAuthProviderNullableFilter<"User"> | $Enums.OAuthProvider | null
    oauthId?: StringNullableFilter<"User"> | string | null
    oauthRefreshToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    blacklistedTokens?: BlacklistedTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    idNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    nik?: SortOrderInput | SortOrder
    dinas?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    hashAlgorithm?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    verifiedAccount?: SortOrder
    accountVerificationToken?: SortOrderInput | SortOrder
    verificationSentAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    updateEmailToken?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockUntil?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    oauthProvider?: SortOrderInput | SortOrder
    oauthId?: SortOrderInput | SortOrder
    oauthRefreshToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    blacklistedTokens?: BlacklistedTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    idNumber?: string
    nik?: string
    participantId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    dinas?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    hashAlgorithm?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    verifiedAccount?: BoolFilter<"User"> | boolean
    accountVerificationToken?: StringNullableFilter<"User"> | string | null
    verificationSentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    updateEmailToken?: StringNullableFilter<"User"> | string | null
    loginAttempts?: IntFilter<"User"> | number
    lockUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    oauthProvider?: EnumOAuthProviderNullableFilter<"User"> | $Enums.OAuthProvider | null
    oauthId?: StringNullableFilter<"User"> | string | null
    oauthRefreshToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    blacklistedTokens?: BlacklistedTokenListRelationFilter
  }, "id" | "email" | "idNumber" | "nik" | "participantId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    idNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    nik?: SortOrderInput | SortOrder
    dinas?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    hashAlgorithm?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    verifiedAccount?: SortOrder
    accountVerificationToken?: SortOrderInput | SortOrder
    verificationSentAt?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    updateEmailToken?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockUntil?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    oauthProvider?: SortOrderInput | SortOrder
    oauthId?: SortOrderInput | SortOrder
    oauthRefreshToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    idNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    nik?: StringNullableWithAggregatesFilter<"User"> | string | null
    dinas?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    hashAlgorithm?: StringWithAggregatesFilter<"User"> | string
    roleId?: StringWithAggregatesFilter<"User"> | string
    participantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    verifiedAccount?: BoolWithAggregatesFilter<"User"> | boolean
    accountVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationSentAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    updateEmailToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    loginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    oauthProvider?: EnumOAuthProviderNullableWithAggregatesFilter<"User"> | $Enums.OAuthProvider | null
    oauthId?: StringNullableWithAggregatesFilter<"User"> | string | null
    oauthRefreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type OAuthStateWhereInput = {
    AND?: OAuthStateWhereInput | OAuthStateWhereInput[]
    OR?: OAuthStateWhereInput[]
    NOT?: OAuthStateWhereInput | OAuthStateWhereInput[]
    id?: StringFilter<"OAuthState"> | string
    state?: StringFilter<"OAuthState"> | string
    createdAt?: DateTimeFilter<"OAuthState"> | Date | string
    expiresAt?: DateTimeFilter<"OAuthState"> | Date | string
    provider?: StringFilter<"OAuthState"> | string
  }

  export type OAuthStateOrderByWithRelationInput = {
    id?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    provider?: SortOrder
  }

  export type OAuthStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    state?: string
    AND?: OAuthStateWhereInput | OAuthStateWhereInput[]
    OR?: OAuthStateWhereInput[]
    NOT?: OAuthStateWhereInput | OAuthStateWhereInput[]
    createdAt?: DateTimeFilter<"OAuthState"> | Date | string
    expiresAt?: DateTimeFilter<"OAuthState"> | Date | string
    provider?: StringFilter<"OAuthState"> | string
  }, "id" | "state">

  export type OAuthStateOrderByWithAggregationInput = {
    id?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    provider?: SortOrder
    _count?: OAuthStateCountOrderByAggregateInput
    _max?: OAuthStateMaxOrderByAggregateInput
    _min?: OAuthStateMinOrderByAggregateInput
  }

  export type OAuthStateScalarWhereWithAggregatesInput = {
    AND?: OAuthStateScalarWhereWithAggregatesInput | OAuthStateScalarWhereWithAggregatesInput[]
    OR?: OAuthStateScalarWhereWithAggregatesInput[]
    NOT?: OAuthStateScalarWhereWithAggregatesInput | OAuthStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthState"> | string
    state?: StringWithAggregatesFilter<"OAuthState"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OAuthState"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthState"> | Date | string
    provider?: StringWithAggregatesFilter<"OAuthState"> | string
  }

  export type AppConfigWhereInput = {
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    id?: StringFilter<"AppConfig"> | string
    frontendUrl?: StringFilter<"AppConfig"> | string
    backendUrl?: StringFilter<"AppConfig"> | string
    createdAt?: DateTimeFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
  }

  export type AppConfigOrderByWithRelationInput = {
    id?: SortOrder
    frontendUrl?: SortOrder
    backendUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    frontendUrl?: StringFilter<"AppConfig"> | string
    backendUrl?: StringFilter<"AppConfig"> | string
    createdAt?: DateTimeFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
  }, "id">

  export type AppConfigOrderByWithAggregationInput = {
    id?: SortOrder
    frontendUrl?: SortOrder
    backendUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppConfigCountOrderByAggregateInput
    _max?: AppConfigMaxOrderByAggregateInput
    _min?: AppConfigMinOrderByAggregateInput
  }

  export type AppConfigScalarWhereWithAggregatesInput = {
    AND?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    OR?: AppConfigScalarWhereWithAggregatesInput[]
    NOT?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppConfig"> | string
    frontendUrl?: StringWithAggregatesFilter<"AppConfig"> | string
    backendUrl?: StringWithAggregatesFilter<"AppConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppConfig"> | Date | string
  }

  export type FileMetadataWhereInput = {
    AND?: FileMetadataWhereInput | FileMetadataWhereInput[]
    OR?: FileMetadataWhereInput[]
    NOT?: FileMetadataWhereInput | FileMetadataWhereInput[]
    id?: IntFilter<"FileMetadata"> | number
    path?: StringFilter<"FileMetadata"> | string
    fileName?: StringNullableFilter<"FileMetadata"> | string | null
    mimeType?: StringFilter<"FileMetadata"> | string
    fileSize?: IntFilter<"FileMetadata"> | number
    storageType?: StringFilter<"FileMetadata"> | string
    iv?: StringNullableFilter<"FileMetadata"> | string | null
    isSensitive?: BoolFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeFilter<"FileMetadata"> | Date | string
    participantSimAId?: StringNullableFilter<"FileMetadata"> | string | null
    participantSimBId?: StringNullableFilter<"FileMetadata"> | string | null
    participantKtpId?: StringNullableFilter<"FileMetadata"> | string | null
    participantFotoId?: StringNullableFilter<"FileMetadata"> | string | null
    participantSuratSehatButaWarnaId?: StringNullableFilter<"FileMetadata"> | string | null
    participantSuratBebasNarkobaId?: StringNullableFilter<"FileMetadata"> | string | null
    participantQrCodeId?: StringNullableFilter<"FileMetadata"> | string | null
    participantSimA?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantSimB?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantKtp?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantFoto?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantSuratSehatButaWarna?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantSuratBebasNarkoba?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantQrCode?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    signatureESign?: XOR<SignatureNullableScalarRelationFilter, SignatureWhereInput> | null
  }

  export type FileMetadataOrderByWithRelationInput = {
    id?: SortOrder
    path?: SortOrder
    fileName?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageType?: SortOrder
    iv?: SortOrderInput | SortOrder
    isSensitive?: SortOrder
    createdAt?: SortOrder
    participantSimAId?: SortOrderInput | SortOrder
    participantSimBId?: SortOrderInput | SortOrder
    participantKtpId?: SortOrderInput | SortOrder
    participantFotoId?: SortOrderInput | SortOrder
    participantSuratSehatButaWarnaId?: SortOrderInput | SortOrder
    participantSuratBebasNarkobaId?: SortOrderInput | SortOrder
    participantQrCodeId?: SortOrderInput | SortOrder
    participantSimA?: ParticipantOrderByWithRelationInput
    participantSimB?: ParticipantOrderByWithRelationInput
    participantKtp?: ParticipantOrderByWithRelationInput
    participantFoto?: ParticipantOrderByWithRelationInput
    participantSuratSehatButaWarna?: ParticipantOrderByWithRelationInput
    participantSuratBebasNarkoba?: ParticipantOrderByWithRelationInput
    participantQrCode?: ParticipantOrderByWithRelationInput
    signatureESign?: SignatureOrderByWithRelationInput
  }

  export type FileMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    path?: string
    participantSimAId?: string
    participantSimBId?: string
    participantKtpId?: string
    participantFotoId?: string
    participantSuratSehatButaWarnaId?: string
    participantSuratBebasNarkobaId?: string
    participantQrCodeId?: string
    AND?: FileMetadataWhereInput | FileMetadataWhereInput[]
    OR?: FileMetadataWhereInput[]
    NOT?: FileMetadataWhereInput | FileMetadataWhereInput[]
    fileName?: StringNullableFilter<"FileMetadata"> | string | null
    mimeType?: StringFilter<"FileMetadata"> | string
    fileSize?: IntFilter<"FileMetadata"> | number
    storageType?: StringFilter<"FileMetadata"> | string
    iv?: StringNullableFilter<"FileMetadata"> | string | null
    isSensitive?: BoolFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeFilter<"FileMetadata"> | Date | string
    participantSimA?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantSimB?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantKtp?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantFoto?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantSuratSehatButaWarna?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantSuratBebasNarkoba?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    participantQrCode?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    signatureESign?: XOR<SignatureNullableScalarRelationFilter, SignatureWhereInput> | null
  }, "id" | "path" | "participantSimAId" | "participantSimBId" | "participantKtpId" | "participantFotoId" | "participantSuratSehatButaWarnaId" | "participantSuratBebasNarkobaId" | "participantQrCodeId">

  export type FileMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    fileName?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageType?: SortOrder
    iv?: SortOrderInput | SortOrder
    isSensitive?: SortOrder
    createdAt?: SortOrder
    participantSimAId?: SortOrderInput | SortOrder
    participantSimBId?: SortOrderInput | SortOrder
    participantKtpId?: SortOrderInput | SortOrder
    participantFotoId?: SortOrderInput | SortOrder
    participantSuratSehatButaWarnaId?: SortOrderInput | SortOrder
    participantSuratBebasNarkobaId?: SortOrderInput | SortOrder
    participantQrCodeId?: SortOrderInput | SortOrder
    _count?: FileMetadataCountOrderByAggregateInput
    _avg?: FileMetadataAvgOrderByAggregateInput
    _max?: FileMetadataMaxOrderByAggregateInput
    _min?: FileMetadataMinOrderByAggregateInput
    _sum?: FileMetadataSumOrderByAggregateInput
  }

  export type FileMetadataScalarWhereWithAggregatesInput = {
    AND?: FileMetadataScalarWhereWithAggregatesInput | FileMetadataScalarWhereWithAggregatesInput[]
    OR?: FileMetadataScalarWhereWithAggregatesInput[]
    NOT?: FileMetadataScalarWhereWithAggregatesInput | FileMetadataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FileMetadata"> | number
    path?: StringWithAggregatesFilter<"FileMetadata"> | string
    fileName?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    mimeType?: StringWithAggregatesFilter<"FileMetadata"> | string
    fileSize?: IntWithAggregatesFilter<"FileMetadata"> | number
    storageType?: StringWithAggregatesFilter<"FileMetadata"> | string
    iv?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    isSensitive?: BoolWithAggregatesFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FileMetadata"> | Date | string
    participantSimAId?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    participantSimBId?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    participantKtpId?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    participantFotoId?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    participantSuratSehatButaWarnaId?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    participantSuratBebasNarkobaId?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    participantQrCodeId?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
  }

  export type ParticipantWhereInput = {
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    id?: StringFilter<"Participant"> | string
    idNumber?: StringNullableFilter<"Participant"> | string | null
    name?: StringFilter<"Participant"> | string
    nik?: StringFilter<"Participant"> | string
    dinas?: StringNullableFilter<"Participant"> | string | null
    bidang?: StringNullableFilter<"Participant"> | string | null
    company?: StringNullableFilter<"Participant"> | string | null
    email?: StringFilter<"Participant"> | string
    phoneNumber?: StringNullableFilter<"Participant"> | string | null
    nationality?: StringNullableFilter<"Participant"> | string | null
    placeOfBirth?: StringNullableFilter<"Participant"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Participant"> | Date | string | null
    qrCodeLink?: StringNullableFilter<"Participant"> | string | null
    tglKeluarSuratSehatButaWarna?: DateTimeNullableFilter<"Participant"> | Date | string | null
    tglKeluarSuratBebasNarkoba?: DateTimeNullableFilter<"Participant"> | Date | string | null
    gmfNonGmf?: StringNullableFilter<"Participant"> | string | null
    createdAt?: DateTimeFilter<"Participant"> | Date | string
    updatedAt?: DateTimeFilter<"Participant"> | Date | string
    simA?: FileMetadataListRelationFilter
    simB?: FileMetadataListRelationFilter
    ktp?: FileMetadataListRelationFilter
    foto?: FileMetadataListRelationFilter
    suratSehatButaWarna?: FileMetadataListRelationFilter
    suratBebasNarkoba?: FileMetadataListRelationFilter
    qrCode?: FileMetadataListRelationFilter
    participantsCots?: ParticipantsCOTListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    certificates?: CertificateListRelationFilter
  }

  export type ParticipantOrderByWithRelationInput = {
    id?: SortOrder
    idNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrderInput | SortOrder
    bidang?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    placeOfBirth?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    qrCodeLink?: SortOrderInput | SortOrder
    tglKeluarSuratSehatButaWarna?: SortOrderInput | SortOrder
    tglKeluarSuratBebasNarkoba?: SortOrderInput | SortOrder
    gmfNonGmf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    simA?: FileMetadataOrderByRelationAggregateInput
    simB?: FileMetadataOrderByRelationAggregateInput
    ktp?: FileMetadataOrderByRelationAggregateInput
    foto?: FileMetadataOrderByRelationAggregateInput
    suratSehatButaWarna?: FileMetadataOrderByRelationAggregateInput
    suratBebasNarkoba?: FileMetadataOrderByRelationAggregateInput
    qrCode?: FileMetadataOrderByRelationAggregateInput
    participantsCots?: ParticipantsCOTOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type ParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idNumber?: string
    nik?: string
    email?: string
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    name?: StringFilter<"Participant"> | string
    dinas?: StringNullableFilter<"Participant"> | string | null
    bidang?: StringNullableFilter<"Participant"> | string | null
    company?: StringNullableFilter<"Participant"> | string | null
    phoneNumber?: StringNullableFilter<"Participant"> | string | null
    nationality?: StringNullableFilter<"Participant"> | string | null
    placeOfBirth?: StringNullableFilter<"Participant"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Participant"> | Date | string | null
    qrCodeLink?: StringNullableFilter<"Participant"> | string | null
    tglKeluarSuratSehatButaWarna?: DateTimeNullableFilter<"Participant"> | Date | string | null
    tglKeluarSuratBebasNarkoba?: DateTimeNullableFilter<"Participant"> | Date | string | null
    gmfNonGmf?: StringNullableFilter<"Participant"> | string | null
    createdAt?: DateTimeFilter<"Participant"> | Date | string
    updatedAt?: DateTimeFilter<"Participant"> | Date | string
    simA?: FileMetadataListRelationFilter
    simB?: FileMetadataListRelationFilter
    ktp?: FileMetadataListRelationFilter
    foto?: FileMetadataListRelationFilter
    suratSehatButaWarna?: FileMetadataListRelationFilter
    suratBebasNarkoba?: FileMetadataListRelationFilter
    qrCode?: FileMetadataListRelationFilter
    participantsCots?: ParticipantsCOTListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    certificates?: CertificateListRelationFilter
  }, "id" | "idNumber" | "nik" | "email">

  export type ParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    idNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrderInput | SortOrder
    bidang?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    placeOfBirth?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    qrCodeLink?: SortOrderInput | SortOrder
    tglKeluarSuratSehatButaWarna?: SortOrderInput | SortOrder
    tglKeluarSuratBebasNarkoba?: SortOrderInput | SortOrder
    gmfNonGmf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParticipantCountOrderByAggregateInput
    _max?: ParticipantMaxOrderByAggregateInput
    _min?: ParticipantMinOrderByAggregateInput
  }

  export type ParticipantScalarWhereWithAggregatesInput = {
    AND?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    OR?: ParticipantScalarWhereWithAggregatesInput[]
    NOT?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Participant"> | string
    idNumber?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    name?: StringWithAggregatesFilter<"Participant"> | string
    nik?: StringWithAggregatesFilter<"Participant"> | string
    dinas?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    bidang?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    company?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    email?: StringWithAggregatesFilter<"Participant"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    placeOfBirth?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Participant"> | Date | string | null
    qrCodeLink?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    tglKeluarSuratSehatButaWarna?: DateTimeNullableWithAggregatesFilter<"Participant"> | Date | string | null
    tglKeluarSuratBebasNarkoba?: DateTimeNullableWithAggregatesFilter<"Participant"> | Date | string | null
    gmfNonGmf?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Participant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Participant"> | Date | string
  }

  export type CapabilityWhereInput = {
    AND?: CapabilityWhereInput | CapabilityWhereInput[]
    OR?: CapabilityWhereInput[]
    NOT?: CapabilityWhereInput | CapabilityWhereInput[]
    id?: StringFilter<"Capability"> | string
    ratingCode?: StringFilter<"Capability"> | string
    trainingCode?: StringFilter<"Capability"> | string
    trainingName?: StringFilter<"Capability"> | string
    totalTheoryDurationRegGse?: IntNullableFilter<"Capability"> | number | null
    totalPracticeDurationRegGse?: IntNullableFilter<"Capability"> | number | null
    totalTheoryDurationCompetency?: IntNullableFilter<"Capability"> | number | null
    totalPracticeDurationCompetency?: IntNullableFilter<"Capability"> | number | null
    totalDuration?: IntNullableFilter<"Capability"> | number | null
    createdAt?: DateTimeFilter<"Capability"> | Date | string
    updatedAt?: DateTimeFilter<"Capability"> | Date | string
    curriculumSyllabus?: CurriculumSyllabusListRelationFilter
    capabilityCots?: CapabilityCOTListRelationFilter
  }

  export type CapabilityOrderByWithRelationInput = {
    id?: SortOrder
    ratingCode?: SortOrder
    trainingCode?: SortOrder
    trainingName?: SortOrder
    totalTheoryDurationRegGse?: SortOrderInput | SortOrder
    totalPracticeDurationRegGse?: SortOrderInput | SortOrder
    totalTheoryDurationCompetency?: SortOrderInput | SortOrder
    totalPracticeDurationCompetency?: SortOrderInput | SortOrder
    totalDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    curriculumSyllabus?: CurriculumSyllabusOrderByRelationAggregateInput
    capabilityCots?: CapabilityCOTOrderByRelationAggregateInput
  }

  export type CapabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CapabilityWhereInput | CapabilityWhereInput[]
    OR?: CapabilityWhereInput[]
    NOT?: CapabilityWhereInput | CapabilityWhereInput[]
    ratingCode?: StringFilter<"Capability"> | string
    trainingCode?: StringFilter<"Capability"> | string
    trainingName?: StringFilter<"Capability"> | string
    totalTheoryDurationRegGse?: IntNullableFilter<"Capability"> | number | null
    totalPracticeDurationRegGse?: IntNullableFilter<"Capability"> | number | null
    totalTheoryDurationCompetency?: IntNullableFilter<"Capability"> | number | null
    totalPracticeDurationCompetency?: IntNullableFilter<"Capability"> | number | null
    totalDuration?: IntNullableFilter<"Capability"> | number | null
    createdAt?: DateTimeFilter<"Capability"> | Date | string
    updatedAt?: DateTimeFilter<"Capability"> | Date | string
    curriculumSyllabus?: CurriculumSyllabusListRelationFilter
    capabilityCots?: CapabilityCOTListRelationFilter
  }, "id">

  export type CapabilityOrderByWithAggregationInput = {
    id?: SortOrder
    ratingCode?: SortOrder
    trainingCode?: SortOrder
    trainingName?: SortOrder
    totalTheoryDurationRegGse?: SortOrderInput | SortOrder
    totalPracticeDurationRegGse?: SortOrderInput | SortOrder
    totalTheoryDurationCompetency?: SortOrderInput | SortOrder
    totalPracticeDurationCompetency?: SortOrderInput | SortOrder
    totalDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CapabilityCountOrderByAggregateInput
    _avg?: CapabilityAvgOrderByAggregateInput
    _max?: CapabilityMaxOrderByAggregateInput
    _min?: CapabilityMinOrderByAggregateInput
    _sum?: CapabilitySumOrderByAggregateInput
  }

  export type CapabilityScalarWhereWithAggregatesInput = {
    AND?: CapabilityScalarWhereWithAggregatesInput | CapabilityScalarWhereWithAggregatesInput[]
    OR?: CapabilityScalarWhereWithAggregatesInput[]
    NOT?: CapabilityScalarWhereWithAggregatesInput | CapabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Capability"> | string
    ratingCode?: StringWithAggregatesFilter<"Capability"> | string
    trainingCode?: StringWithAggregatesFilter<"Capability"> | string
    trainingName?: StringWithAggregatesFilter<"Capability"> | string
    totalTheoryDurationRegGse?: IntNullableWithAggregatesFilter<"Capability"> | number | null
    totalPracticeDurationRegGse?: IntNullableWithAggregatesFilter<"Capability"> | number | null
    totalTheoryDurationCompetency?: IntNullableWithAggregatesFilter<"Capability"> | number | null
    totalPracticeDurationCompetency?: IntNullableWithAggregatesFilter<"Capability"> | number | null
    totalDuration?: IntNullableWithAggregatesFilter<"Capability"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Capability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Capability"> | Date | string
  }

  export type CurriculumSyllabusWhereInput = {
    AND?: CurriculumSyllabusWhereInput | CurriculumSyllabusWhereInput[]
    OR?: CurriculumSyllabusWhereInput[]
    NOT?: CurriculumSyllabusWhereInput | CurriculumSyllabusWhereInput[]
    id?: StringFilter<"CurriculumSyllabus"> | string
    capabilityId?: StringFilter<"CurriculumSyllabus"> | string
    name?: StringFilter<"CurriculumSyllabus"> | string
    theoryDuration?: IntFilter<"CurriculumSyllabus"> | number
    practiceDuration?: IntFilter<"CurriculumSyllabus"> | number
    type?: StringFilter<"CurriculumSyllabus"> | string
    createdAt?: DateTimeFilter<"CurriculumSyllabus"> | Date | string
    updatedAt?: DateTimeFilter<"CurriculumSyllabus"> | Date | string
    capability?: XOR<CapabilityScalarRelationFilter, CapabilityWhereInput>
  }

  export type CurriculumSyllabusOrderByWithRelationInput = {
    id?: SortOrder
    capabilityId?: SortOrder
    name?: SortOrder
    theoryDuration?: SortOrder
    practiceDuration?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capability?: CapabilityOrderByWithRelationInput
  }

  export type CurriculumSyllabusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CurriculumSyllabusWhereInput | CurriculumSyllabusWhereInput[]
    OR?: CurriculumSyllabusWhereInput[]
    NOT?: CurriculumSyllabusWhereInput | CurriculumSyllabusWhereInput[]
    capabilityId?: StringFilter<"CurriculumSyllabus"> | string
    name?: StringFilter<"CurriculumSyllabus"> | string
    theoryDuration?: IntFilter<"CurriculumSyllabus"> | number
    practiceDuration?: IntFilter<"CurriculumSyllabus"> | number
    type?: StringFilter<"CurriculumSyllabus"> | string
    createdAt?: DateTimeFilter<"CurriculumSyllabus"> | Date | string
    updatedAt?: DateTimeFilter<"CurriculumSyllabus"> | Date | string
    capability?: XOR<CapabilityScalarRelationFilter, CapabilityWhereInput>
  }, "id">

  export type CurriculumSyllabusOrderByWithAggregationInput = {
    id?: SortOrder
    capabilityId?: SortOrder
    name?: SortOrder
    theoryDuration?: SortOrder
    practiceDuration?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurriculumSyllabusCountOrderByAggregateInput
    _avg?: CurriculumSyllabusAvgOrderByAggregateInput
    _max?: CurriculumSyllabusMaxOrderByAggregateInput
    _min?: CurriculumSyllabusMinOrderByAggregateInput
    _sum?: CurriculumSyllabusSumOrderByAggregateInput
  }

  export type CurriculumSyllabusScalarWhereWithAggregatesInput = {
    AND?: CurriculumSyllabusScalarWhereWithAggregatesInput | CurriculumSyllabusScalarWhereWithAggregatesInput[]
    OR?: CurriculumSyllabusScalarWhereWithAggregatesInput[]
    NOT?: CurriculumSyllabusScalarWhereWithAggregatesInput | CurriculumSyllabusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CurriculumSyllabus"> | string
    capabilityId?: StringWithAggregatesFilter<"CurriculumSyllabus"> | string
    name?: StringWithAggregatesFilter<"CurriculumSyllabus"> | string
    theoryDuration?: IntWithAggregatesFilter<"CurriculumSyllabus"> | number
    practiceDuration?: IntWithAggregatesFilter<"CurriculumSyllabus"> | number
    type?: StringWithAggregatesFilter<"CurriculumSyllabus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CurriculumSyllabus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CurriculumSyllabus"> | Date | string
  }

  export type COTWhereInput = {
    AND?: COTWhereInput | COTWhereInput[]
    OR?: COTWhereInput[]
    NOT?: COTWhereInput | COTWhereInput[]
    id?: StringFilter<"COT"> | string
    startDate?: DateTimeFilter<"COT"> | Date | string
    endDate?: DateTimeFilter<"COT"> | Date | string
    trainingLocation?: StringFilter<"COT"> | string
    theoryInstructorRegGse?: StringFilter<"COT"> | string
    theoryInstructorCompetency?: StringFilter<"COT"> | string
    practicalInstructor1?: StringFilter<"COT"> | string
    practicalInstructor2?: StringFilter<"COT"> | string
    status?: StringFilter<"COT"> | string
    createdAt?: DateTimeFilter<"COT"> | Date | string
    updatedAt?: DateTimeFilter<"COT"> | Date | string
    capabilityCots?: CapabilityCOTListRelationFilter
    participantsCots?: ParticipantsCOTListRelationFilter
    certificates?: CertificateListRelationFilter
  }

  export type COTOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingLocation?: SortOrder
    theoryInstructorRegGse?: SortOrder
    theoryInstructorCompetency?: SortOrder
    practicalInstructor1?: SortOrder
    practicalInstructor2?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capabilityCots?: CapabilityCOTOrderByRelationAggregateInput
    participantsCots?: ParticipantsCOTOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type COTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: COTWhereInput | COTWhereInput[]
    OR?: COTWhereInput[]
    NOT?: COTWhereInput | COTWhereInput[]
    startDate?: DateTimeFilter<"COT"> | Date | string
    endDate?: DateTimeFilter<"COT"> | Date | string
    trainingLocation?: StringFilter<"COT"> | string
    theoryInstructorRegGse?: StringFilter<"COT"> | string
    theoryInstructorCompetency?: StringFilter<"COT"> | string
    practicalInstructor1?: StringFilter<"COT"> | string
    practicalInstructor2?: StringFilter<"COT"> | string
    status?: StringFilter<"COT"> | string
    createdAt?: DateTimeFilter<"COT"> | Date | string
    updatedAt?: DateTimeFilter<"COT"> | Date | string
    capabilityCots?: CapabilityCOTListRelationFilter
    participantsCots?: ParticipantsCOTListRelationFilter
    certificates?: CertificateListRelationFilter
  }, "id">

  export type COTOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingLocation?: SortOrder
    theoryInstructorRegGse?: SortOrder
    theoryInstructorCompetency?: SortOrder
    practicalInstructor1?: SortOrder
    practicalInstructor2?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: COTCountOrderByAggregateInput
    _max?: COTMaxOrderByAggregateInput
    _min?: COTMinOrderByAggregateInput
  }

  export type COTScalarWhereWithAggregatesInput = {
    AND?: COTScalarWhereWithAggregatesInput | COTScalarWhereWithAggregatesInput[]
    OR?: COTScalarWhereWithAggregatesInput[]
    NOT?: COTScalarWhereWithAggregatesInput | COTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"COT"> | string
    startDate?: DateTimeWithAggregatesFilter<"COT"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"COT"> | Date | string
    trainingLocation?: StringWithAggregatesFilter<"COT"> | string
    theoryInstructorRegGse?: StringWithAggregatesFilter<"COT"> | string
    theoryInstructorCompetency?: StringWithAggregatesFilter<"COT"> | string
    practicalInstructor1?: StringWithAggregatesFilter<"COT"> | string
    practicalInstructor2?: StringWithAggregatesFilter<"COT"> | string
    status?: StringWithAggregatesFilter<"COT"> | string
    createdAt?: DateTimeWithAggregatesFilter<"COT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"COT"> | Date | string
  }

  export type CapabilityCOTWhereInput = {
    AND?: CapabilityCOTWhereInput | CapabilityCOTWhereInput[]
    OR?: CapabilityCOTWhereInput[]
    NOT?: CapabilityCOTWhereInput | CapabilityCOTWhereInput[]
    capabilityId?: StringFilter<"CapabilityCOT"> | string
    cotId?: StringFilter<"CapabilityCOT"> | string
    capability?: XOR<CapabilityScalarRelationFilter, CapabilityWhereInput>
    cot?: XOR<COTScalarRelationFilter, COTWhereInput>
  }

  export type CapabilityCOTOrderByWithRelationInput = {
    capabilityId?: SortOrder
    cotId?: SortOrder
    capability?: CapabilityOrderByWithRelationInput
    cot?: COTOrderByWithRelationInput
  }

  export type CapabilityCOTWhereUniqueInput = Prisma.AtLeast<{
    capabilityId_cotId?: CapabilityCOTCapabilityIdCotIdCompoundUniqueInput
    AND?: CapabilityCOTWhereInput | CapabilityCOTWhereInput[]
    OR?: CapabilityCOTWhereInput[]
    NOT?: CapabilityCOTWhereInput | CapabilityCOTWhereInput[]
    capabilityId?: StringFilter<"CapabilityCOT"> | string
    cotId?: StringFilter<"CapabilityCOT"> | string
    capability?: XOR<CapabilityScalarRelationFilter, CapabilityWhereInput>
    cot?: XOR<COTScalarRelationFilter, COTWhereInput>
  }, "capabilityId_cotId">

  export type CapabilityCOTOrderByWithAggregationInput = {
    capabilityId?: SortOrder
    cotId?: SortOrder
    _count?: CapabilityCOTCountOrderByAggregateInput
    _max?: CapabilityCOTMaxOrderByAggregateInput
    _min?: CapabilityCOTMinOrderByAggregateInput
  }

  export type CapabilityCOTScalarWhereWithAggregatesInput = {
    AND?: CapabilityCOTScalarWhereWithAggregatesInput | CapabilityCOTScalarWhereWithAggregatesInput[]
    OR?: CapabilityCOTScalarWhereWithAggregatesInput[]
    NOT?: CapabilityCOTScalarWhereWithAggregatesInput | CapabilityCOTScalarWhereWithAggregatesInput[]
    capabilityId?: StringWithAggregatesFilter<"CapabilityCOT"> | string
    cotId?: StringWithAggregatesFilter<"CapabilityCOT"> | string
  }

  export type ParticipantsCOTWhereInput = {
    AND?: ParticipantsCOTWhereInput | ParticipantsCOTWhereInput[]
    OR?: ParticipantsCOTWhereInput[]
    NOT?: ParticipantsCOTWhereInput | ParticipantsCOTWhereInput[]
    id?: StringFilter<"ParticipantsCOT"> | string
    participantId?: StringNullableFilter<"ParticipantsCOT"> | string | null
    cotId?: StringFilter<"ParticipantsCOT"> | string
    createdAt?: DateTimeFilter<"ParticipantsCOT"> | Date | string
    updatedAt?: DateTimeFilter<"ParticipantsCOT"> | Date | string
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    cot?: XOR<COTScalarRelationFilter, COTWhereInput>
  }

  export type ParticipantsCOTOrderByWithRelationInput = {
    id?: SortOrder
    participantId?: SortOrderInput | SortOrder
    cotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participant?: ParticipantOrderByWithRelationInput
    cot?: COTOrderByWithRelationInput
  }

  export type ParticipantsCOTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParticipantsCOTWhereInput | ParticipantsCOTWhereInput[]
    OR?: ParticipantsCOTWhereInput[]
    NOT?: ParticipantsCOTWhereInput | ParticipantsCOTWhereInput[]
    participantId?: StringNullableFilter<"ParticipantsCOT"> | string | null
    cotId?: StringFilter<"ParticipantsCOT"> | string
    createdAt?: DateTimeFilter<"ParticipantsCOT"> | Date | string
    updatedAt?: DateTimeFilter<"ParticipantsCOT"> | Date | string
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
    cot?: XOR<COTScalarRelationFilter, COTWhereInput>
  }, "id">

  export type ParticipantsCOTOrderByWithAggregationInput = {
    id?: SortOrder
    participantId?: SortOrderInput | SortOrder
    cotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParticipantsCOTCountOrderByAggregateInput
    _max?: ParticipantsCOTMaxOrderByAggregateInput
    _min?: ParticipantsCOTMinOrderByAggregateInput
  }

  export type ParticipantsCOTScalarWhereWithAggregatesInput = {
    AND?: ParticipantsCOTScalarWhereWithAggregatesInput | ParticipantsCOTScalarWhereWithAggregatesInput[]
    OR?: ParticipantsCOTScalarWhereWithAggregatesInput[]
    NOT?: ParticipantsCOTScalarWhereWithAggregatesInput | ParticipantsCOTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParticipantsCOT"> | string
    participantId?: StringNullableWithAggregatesFilter<"ParticipantsCOT"> | string | null
    cotId?: StringWithAggregatesFilter<"ParticipantsCOT"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParticipantsCOT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParticipantsCOT"> | Date | string
  }

  export type SignatureWhereInput = {
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    id?: StringFilter<"Signature"> | string
    idNumber?: StringFilter<"Signature"> | string
    role?: StringFilter<"Signature"> | string
    name?: StringFilter<"Signature"> | string
    eSignId?: IntNullableFilter<"Signature"> | number | null
    signatureType?: EnumSignatureTypeFilter<"Signature"> | $Enums.SignatureType
    status?: BoolFilter<"Signature"> | boolean
    createdAt?: DateTimeFilter<"Signature"> | Date | string
    updatedAt?: DateTimeFilter<"Signature"> | Date | string
    eSign?: XOR<FileMetadataNullableScalarRelationFilter, FileMetadataWhereInput> | null
    certificates?: CertificateListRelationFilter
  }

  export type SignatureOrderByWithRelationInput = {
    id?: SortOrder
    idNumber?: SortOrder
    role?: SortOrder
    name?: SortOrder
    eSignId?: SortOrderInput | SortOrder
    signatureType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eSign?: FileMetadataOrderByWithRelationInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type SignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idNumber?: string
    eSignId?: number
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    role?: StringFilter<"Signature"> | string
    name?: StringFilter<"Signature"> | string
    signatureType?: EnumSignatureTypeFilter<"Signature"> | $Enums.SignatureType
    status?: BoolFilter<"Signature"> | boolean
    createdAt?: DateTimeFilter<"Signature"> | Date | string
    updatedAt?: DateTimeFilter<"Signature"> | Date | string
    eSign?: XOR<FileMetadataNullableScalarRelationFilter, FileMetadataWhereInput> | null
    certificates?: CertificateListRelationFilter
  }, "id" | "idNumber" | "eSignId">

  export type SignatureOrderByWithAggregationInput = {
    id?: SortOrder
    idNumber?: SortOrder
    role?: SortOrder
    name?: SortOrder
    eSignId?: SortOrderInput | SortOrder
    signatureType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SignatureCountOrderByAggregateInput
    _avg?: SignatureAvgOrderByAggregateInput
    _max?: SignatureMaxOrderByAggregateInput
    _min?: SignatureMinOrderByAggregateInput
    _sum?: SignatureSumOrderByAggregateInput
  }

  export type SignatureScalarWhereWithAggregatesInput = {
    AND?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    OR?: SignatureScalarWhereWithAggregatesInput[]
    NOT?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Signature"> | string
    idNumber?: StringWithAggregatesFilter<"Signature"> | string
    role?: StringWithAggregatesFilter<"Signature"> | string
    name?: StringWithAggregatesFilter<"Signature"> | string
    eSignId?: IntNullableWithAggregatesFilter<"Signature"> | number | null
    signatureType?: EnumSignatureTypeWithAggregatesFilter<"Signature"> | $Enums.SignatureType
    status?: BoolWithAggregatesFilter<"Signature"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Signature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Signature"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    cotId?: StringFilter<"Certificate"> | string
    signatureId?: StringFilter<"Certificate"> | string
    participantId?: StringFilter<"Certificate"> | string
    issuedDate?: DateTimeFilter<"Certificate"> | Date | string
    certificateNumber?: StringFilter<"Certificate"> | string
    attendance?: BoolFilter<"Certificate"> | boolean
    theoryScore?: FloatFilter<"Certificate"> | number
    practiceScore?: FloatFilter<"Certificate"> | number
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
    cot?: XOR<COTScalarRelationFilter, COTWhereInput>
    signature?: XOR<SignatureScalarRelationFilter, SignatureWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    cotId?: SortOrder
    signatureId?: SortOrder
    participantId?: SortOrder
    issuedDate?: SortOrder
    certificateNumber?: SortOrder
    attendance?: SortOrder
    theoryScore?: SortOrder
    practiceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cot?: COTOrderByWithRelationInput
    signature?: SignatureOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    cotId?: StringFilter<"Certificate"> | string
    signatureId?: StringFilter<"Certificate"> | string
    participantId?: StringFilter<"Certificate"> | string
    issuedDate?: DateTimeFilter<"Certificate"> | Date | string
    certificateNumber?: StringFilter<"Certificate"> | string
    attendance?: BoolFilter<"Certificate"> | boolean
    theoryScore?: FloatFilter<"Certificate"> | number
    practiceScore?: FloatFilter<"Certificate"> | number
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
    cot?: XOR<COTScalarRelationFilter, COTWhereInput>
    signature?: XOR<SignatureScalarRelationFilter, SignatureWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    cotId?: SortOrder
    signatureId?: SortOrder
    participantId?: SortOrder
    issuedDate?: SortOrder
    certificateNumber?: SortOrder
    attendance?: SortOrder
    theoryScore?: SortOrder
    practiceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    cotId?: StringWithAggregatesFilter<"Certificate"> | string
    signatureId?: StringWithAggregatesFilter<"Certificate"> | string
    participantId?: StringWithAggregatesFilter<"Certificate"> | string
    issuedDate?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    certificateNumber?: StringWithAggregatesFilter<"Certificate"> | string
    attendance?: BoolWithAggregatesFilter<"Certificate"> | boolean
    theoryScore?: FloatWithAggregatesFilter<"Certificate"> | number
    practiceScore?: FloatWithAggregatesFilter<"Certificate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    sessionId?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    sessionId?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "sessionId">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    sessionId?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type BlacklistedTokenWhereInput = {
    AND?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    OR?: BlacklistedTokenWhereInput[]
    NOT?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    id?: StringFilter<"BlacklistedToken"> | string
    token?: StringFilter<"BlacklistedToken"> | string
    userId?: StringFilter<"BlacklistedToken"> | string
    createdAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
    expiresAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlacklistedTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BlacklistedTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    OR?: BlacklistedTokenWhereInput[]
    NOT?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    userId?: StringFilter<"BlacklistedToken"> | string
    createdAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
    expiresAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type BlacklistedTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: BlacklistedTokenCountOrderByAggregateInput
    _max?: BlacklistedTokenMaxOrderByAggregateInput
    _min?: BlacklistedTokenMinOrderByAggregateInput
  }

  export type BlacklistedTokenScalarWhereWithAggregatesInput = {
    AND?: BlacklistedTokenScalarWhereWithAggregatesInput | BlacklistedTokenScalarWhereWithAggregatesInput[]
    OR?: BlacklistedTokenScalarWhereWithAggregatesInput[]
    NOT?: BlacklistedTokenScalarWhereWithAggregatesInput | BlacklistedTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlacklistedToken"> | string
    token?: StringWithAggregatesFilter<"BlacklistedToken"> | string
    userId?: StringWithAggregatesFilter<"BlacklistedToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlacklistedToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"BlacklistedToken"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    roleId: string
    participantId?: string | null
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    roleId: string
    participantId?: string | null
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthStateCreateInput = {
    id?: string
    state: string
    createdAt?: Date | string
    expiresAt: Date | string
    provider: string
  }

  export type OAuthStateUncheckedCreateInput = {
    id?: string
    state: string
    createdAt?: Date | string
    expiresAt: Date | string
    provider: string
  }

  export type OAuthStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type OAuthStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type OAuthStateCreateManyInput = {
    id?: string
    state: string
    createdAt?: Date | string
    expiresAt: Date | string
    provider: string
  }

  export type OAuthStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type OAuthStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type AppConfigCreateInput = {
    id?: string
    frontendUrl: string
    backendUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigUncheckedCreateInput = {
    id?: string
    frontendUrl: string
    backendUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontendUrl?: StringFieldUpdateOperationsInput | string
    backendUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontendUrl?: StringFieldUpdateOperationsInput | string
    backendUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigCreateManyInput = {
    id?: string
    frontendUrl: string
    backendUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontendUrl?: StringFieldUpdateOperationsInput | string
    backendUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    frontendUrl?: StringFieldUpdateOperationsInput | string
    backendUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMetadataCreateInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataCreateManyInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMetadataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParticipantCreateInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantCreateManyInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityCreateInput = {
    id?: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse?: number | null
    totalPracticeDurationRegGse?: number | null
    totalTheoryDurationCompetency?: number | null
    totalPracticeDurationCompetency?: number | null
    totalDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    curriculumSyllabus?: CurriculumSyllabusCreateNestedManyWithoutCapabilityInput
    capabilityCots?: CapabilityCOTCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUncheckedCreateInput = {
    id?: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse?: number | null
    totalPracticeDurationRegGse?: number | null
    totalTheoryDurationCompetency?: number | null
    totalPracticeDurationCompetency?: number | null
    totalDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    curriculumSyllabus?: CurriculumSyllabusUncheckedCreateNestedManyWithoutCapabilityInput
    capabilityCots?: CapabilityCOTUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    curriculumSyllabus?: CurriculumSyllabusUpdateManyWithoutCapabilityNestedInput
    capabilityCots?: CapabilityCOTUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    curriculumSyllabus?: CurriculumSyllabusUncheckedUpdateManyWithoutCapabilityNestedInput
    capabilityCots?: CapabilityCOTUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityCreateManyInput = {
    id?: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse?: number | null
    totalPracticeDurationRegGse?: number | null
    totalTheoryDurationCompetency?: number | null
    totalPracticeDurationCompetency?: number | null
    totalDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumSyllabusCreateInput = {
    id?: string
    name: string
    theoryDuration: number
    practiceDuration: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capability: CapabilityCreateNestedOneWithoutCurriculumSyllabusInput
  }

  export type CurriculumSyllabusUncheckedCreateInput = {
    id?: string
    capabilityId: string
    name: string
    theoryDuration: number
    practiceDuration: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumSyllabusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    theoryDuration?: IntFieldUpdateOperationsInput | number
    practiceDuration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capability?: CapabilityUpdateOneRequiredWithoutCurriculumSyllabusNestedInput
  }

  export type CurriculumSyllabusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    theoryDuration?: IntFieldUpdateOperationsInput | number
    practiceDuration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumSyllabusCreateManyInput = {
    id?: string
    capabilityId: string
    name: string
    theoryDuration: number
    practiceDuration: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumSyllabusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    theoryDuration?: IntFieldUpdateOperationsInput | number
    practiceDuration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumSyllabusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    capabilityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    theoryDuration?: IntFieldUpdateOperationsInput | number
    practiceDuration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type COTCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTCreateNestedManyWithoutCotInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutCotInput
    certificates?: CertificateCreateNestedManyWithoutCotInput
  }

  export type COTUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTUncheckedCreateNestedManyWithoutCotInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutCotInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCotInput
  }

  export type COTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUpdateManyWithoutCotNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutCotNestedInput
    certificates?: CertificateUpdateManyWithoutCotNestedInput
  }

  export type COTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUncheckedUpdateManyWithoutCotNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutCotNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCotNestedInput
  }

  export type COTCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type COTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type COTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityCOTCreateInput = {
    capability: CapabilityCreateNestedOneWithoutCapabilityCotsInput
    cot: COTCreateNestedOneWithoutCapabilityCotsInput
  }

  export type CapabilityCOTUncheckedCreateInput = {
    capabilityId: string
    cotId: string
  }

  export type CapabilityCOTUpdateInput = {
    capability?: CapabilityUpdateOneRequiredWithoutCapabilityCotsNestedInput
    cot?: COTUpdateOneRequiredWithoutCapabilityCotsNestedInput
  }

  export type CapabilityCOTUncheckedUpdateInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
  }

  export type CapabilityCOTCreateManyInput = {
    capabilityId: string
    cotId: string
  }

  export type CapabilityCOTUpdateManyMutationInput = {

  }

  export type CapabilityCOTUncheckedUpdateManyInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
  }

  export type ParticipantsCOTCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant?: ParticipantCreateNestedOneWithoutParticipantsCotsInput
    cot: COTCreateNestedOneWithoutParticipantsCotsInput
  }

  export type ParticipantsCOTUncheckedCreateInput = {
    id?: string
    participantId?: string | null
    cotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipantsCOTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ParticipantUpdateOneWithoutParticipantsCotsNestedInput
    cot?: COTUpdateOneRequiredWithoutParticipantsCotsNestedInput
  }

  export type ParticipantsCOTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    cotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantsCOTCreateManyInput = {
    id?: string
    participantId?: string | null
    cotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipantsCOTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantsCOTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    cotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureCreateInput = {
    id?: string
    idNumber: string
    role: string
    name: string
    signatureType: $Enums.SignatureType
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eSign?: FileMetadataCreateNestedOneWithoutSignatureESignInput
    certificates?: CertificateCreateNestedManyWithoutSignatureInput
  }

  export type SignatureUncheckedCreateInput = {
    id?: string
    idNumber: string
    role: string
    name: string
    eSignId?: number | null
    signatureType: $Enums.SignatureType
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateUncheckedCreateNestedManyWithoutSignatureInput
  }

  export type SignatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eSign?: FileMetadataUpdateOneWithoutSignatureESignNestedInput
    certificates?: CertificateUpdateManyWithoutSignatureNestedInput
  }

  export type SignatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    eSignId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateUncheckedUpdateManyWithoutSignatureNestedInput
  }

  export type SignatureCreateManyInput = {
    id?: string
    idNumber: string
    role: string
    name: string
    eSignId?: number | null
    signatureType: $Enums.SignatureType
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    eSignId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cot: COTCreateNestedOneWithoutCertificatesInput
    signature: SignatureCreateNestedOneWithoutCertificatesInput
    participant: ParticipantCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    cotId: string
    signatureId: string
    participantId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cot?: COTUpdateOneRequiredWithoutCertificatesNestedInput
    signature?: SignatureUpdateOneRequiredWithoutCertificatesNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    signatureId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManyInput = {
    id?: string
    cotId: string
    signatureId: string
    participantId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    signatureId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenCreateInput = {
    id?: string
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutBlacklistedTokensInput
  }

  export type BlacklistedTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type BlacklistedTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlacklistedTokensNestedInput
  }

  export type BlacklistedTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type BlacklistedTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumOAuthProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableFilter<$PrismaModel> | $Enums.OAuthProvider | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type ParticipantNullableScalarRelationFilter = {
    is?: ParticipantWhereInput | null
    isNot?: ParticipantWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type BlacklistedTokenListRelationFilter = {
    every?: BlacklistedTokenWhereInput
    some?: BlacklistedTokenWhereInput
    none?: BlacklistedTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlacklistedTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    idNumber?: SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrder
    password?: SortOrder
    photo?: SortOrder
    hashAlgorithm?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrder
    verifiedAccount?: SortOrder
    accountVerificationToken?: SortOrder
    verificationSentAt?: SortOrder
    passwordResetToken?: SortOrder
    updateEmailToken?: SortOrder
    loginAttempts?: SortOrder
    lockUntil?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    oauthRefreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    idNumber?: SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrder
    password?: SortOrder
    photo?: SortOrder
    hashAlgorithm?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrder
    verifiedAccount?: SortOrder
    accountVerificationToken?: SortOrder
    verificationSentAt?: SortOrder
    passwordResetToken?: SortOrder
    updateEmailToken?: SortOrder
    loginAttempts?: SortOrder
    lockUntil?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    oauthRefreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    idNumber?: SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrder
    password?: SortOrder
    photo?: SortOrder
    hashAlgorithm?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrder
    verifiedAccount?: SortOrder
    accountVerificationToken?: SortOrder
    verificationSentAt?: SortOrder
    passwordResetToken?: SortOrder
    updateEmailToken?: SortOrder
    loginAttempts?: SortOrder
    lockUntil?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    oauthRefreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.OAuthProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthStateCountOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    provider?: SortOrder
  }

  export type OAuthStateMaxOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    provider?: SortOrder
  }

  export type OAuthStateMinOrderByAggregateInput = {
    id?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    provider?: SortOrder
  }

  export type AppConfigCountOrderByAggregateInput = {
    id?: SortOrder
    frontendUrl?: SortOrder
    backendUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    frontendUrl?: SortOrder
    backendUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppConfigMinOrderByAggregateInput = {
    id?: SortOrder
    frontendUrl?: SortOrder
    backendUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignatureNullableScalarRelationFilter = {
    is?: SignatureWhereInput | null
    isNot?: SignatureWhereInput | null
  }

  export type FileMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageType?: SortOrder
    iv?: SortOrder
    isSensitive?: SortOrder
    createdAt?: SortOrder
    participantSimAId?: SortOrder
    participantSimBId?: SortOrder
    participantKtpId?: SortOrder
    participantFotoId?: SortOrder
    participantSuratSehatButaWarnaId?: SortOrder
    participantSuratBebasNarkobaId?: SortOrder
    participantQrCodeId?: SortOrder
  }

  export type FileMetadataAvgOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
  }

  export type FileMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageType?: SortOrder
    iv?: SortOrder
    isSensitive?: SortOrder
    createdAt?: SortOrder
    participantSimAId?: SortOrder
    participantSimBId?: SortOrder
    participantKtpId?: SortOrder
    participantFotoId?: SortOrder
    participantSuratSehatButaWarnaId?: SortOrder
    participantSuratBebasNarkobaId?: SortOrder
    participantQrCodeId?: SortOrder
  }

  export type FileMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    fileSize?: SortOrder
    storageType?: SortOrder
    iv?: SortOrder
    isSensitive?: SortOrder
    createdAt?: SortOrder
    participantSimAId?: SortOrder
    participantSimBId?: SortOrder
    participantKtpId?: SortOrder
    participantFotoId?: SortOrder
    participantSuratSehatButaWarnaId?: SortOrder
    participantSuratBebasNarkobaId?: SortOrder
    participantQrCodeId?: SortOrder
  }

  export type FileMetadataSumOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
  }

  export type FileMetadataListRelationFilter = {
    every?: FileMetadataWhereInput
    some?: FileMetadataWhereInput
    none?: FileMetadataWhereInput
  }

  export type ParticipantsCOTListRelationFilter = {
    every?: ParticipantsCOTWhereInput
    some?: ParticipantsCOTWhereInput
    none?: ParticipantsCOTWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type FileMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParticipantsCOTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    idNumber?: SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrder
    bidang?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    nationality?: SortOrder
    placeOfBirth?: SortOrder
    dateOfBirth?: SortOrder
    qrCodeLink?: SortOrder
    tglKeluarSuratSehatButaWarna?: SortOrder
    tglKeluarSuratBebasNarkoba?: SortOrder
    gmfNonGmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    idNumber?: SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrder
    bidang?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    nationality?: SortOrder
    placeOfBirth?: SortOrder
    dateOfBirth?: SortOrder
    qrCodeLink?: SortOrder
    tglKeluarSuratSehatButaWarna?: SortOrder
    tglKeluarSuratBebasNarkoba?: SortOrder
    gmfNonGmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    idNumber?: SortOrder
    name?: SortOrder
    nik?: SortOrder
    dinas?: SortOrder
    bidang?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    nationality?: SortOrder
    placeOfBirth?: SortOrder
    dateOfBirth?: SortOrder
    qrCodeLink?: SortOrder
    tglKeluarSuratSehatButaWarna?: SortOrder
    tglKeluarSuratBebasNarkoba?: SortOrder
    gmfNonGmf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CurriculumSyllabusListRelationFilter = {
    every?: CurriculumSyllabusWhereInput
    some?: CurriculumSyllabusWhereInput
    none?: CurriculumSyllabusWhereInput
  }

  export type CapabilityCOTListRelationFilter = {
    every?: CapabilityCOTWhereInput
    some?: CapabilityCOTWhereInput
    none?: CapabilityCOTWhereInput
  }

  export type CurriculumSyllabusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CapabilityCOTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CapabilityCountOrderByAggregateInput = {
    id?: SortOrder
    ratingCode?: SortOrder
    trainingCode?: SortOrder
    trainingName?: SortOrder
    totalTheoryDurationRegGse?: SortOrder
    totalPracticeDurationRegGse?: SortOrder
    totalTheoryDurationCompetency?: SortOrder
    totalPracticeDurationCompetency?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilityAvgOrderByAggregateInput = {
    totalTheoryDurationRegGse?: SortOrder
    totalPracticeDurationRegGse?: SortOrder
    totalTheoryDurationCompetency?: SortOrder
    totalPracticeDurationCompetency?: SortOrder
    totalDuration?: SortOrder
  }

  export type CapabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    ratingCode?: SortOrder
    trainingCode?: SortOrder
    trainingName?: SortOrder
    totalTheoryDurationRegGse?: SortOrder
    totalPracticeDurationRegGse?: SortOrder
    totalTheoryDurationCompetency?: SortOrder
    totalPracticeDurationCompetency?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilityMinOrderByAggregateInput = {
    id?: SortOrder
    ratingCode?: SortOrder
    trainingCode?: SortOrder
    trainingName?: SortOrder
    totalTheoryDurationRegGse?: SortOrder
    totalPracticeDurationRegGse?: SortOrder
    totalTheoryDurationCompetency?: SortOrder
    totalPracticeDurationCompetency?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapabilitySumOrderByAggregateInput = {
    totalTheoryDurationRegGse?: SortOrder
    totalPracticeDurationRegGse?: SortOrder
    totalTheoryDurationCompetency?: SortOrder
    totalPracticeDurationCompetency?: SortOrder
    totalDuration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CapabilityScalarRelationFilter = {
    is?: CapabilityWhereInput
    isNot?: CapabilityWhereInput
  }

  export type CurriculumSyllabusCountOrderByAggregateInput = {
    id?: SortOrder
    capabilityId?: SortOrder
    name?: SortOrder
    theoryDuration?: SortOrder
    practiceDuration?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurriculumSyllabusAvgOrderByAggregateInput = {
    theoryDuration?: SortOrder
    practiceDuration?: SortOrder
  }

  export type CurriculumSyllabusMaxOrderByAggregateInput = {
    id?: SortOrder
    capabilityId?: SortOrder
    name?: SortOrder
    theoryDuration?: SortOrder
    practiceDuration?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurriculumSyllabusMinOrderByAggregateInput = {
    id?: SortOrder
    capabilityId?: SortOrder
    name?: SortOrder
    theoryDuration?: SortOrder
    practiceDuration?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurriculumSyllabusSumOrderByAggregateInput = {
    theoryDuration?: SortOrder
    practiceDuration?: SortOrder
  }

  export type COTCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingLocation?: SortOrder
    theoryInstructorRegGse?: SortOrder
    theoryInstructorCompetency?: SortOrder
    practicalInstructor1?: SortOrder
    practicalInstructor2?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type COTMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingLocation?: SortOrder
    theoryInstructorRegGse?: SortOrder
    theoryInstructorCompetency?: SortOrder
    practicalInstructor1?: SortOrder
    practicalInstructor2?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type COTMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    trainingLocation?: SortOrder
    theoryInstructorRegGse?: SortOrder
    theoryInstructorCompetency?: SortOrder
    practicalInstructor1?: SortOrder
    practicalInstructor2?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type COTScalarRelationFilter = {
    is?: COTWhereInput
    isNot?: COTWhereInput
  }

  export type CapabilityCOTCapabilityIdCotIdCompoundUniqueInput = {
    capabilityId: string
    cotId: string
  }

  export type CapabilityCOTCountOrderByAggregateInput = {
    capabilityId?: SortOrder
    cotId?: SortOrder
  }

  export type CapabilityCOTMaxOrderByAggregateInput = {
    capabilityId?: SortOrder
    cotId?: SortOrder
  }

  export type CapabilityCOTMinOrderByAggregateInput = {
    capabilityId?: SortOrder
    cotId?: SortOrder
  }

  export type ParticipantsCOTCountOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    cotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipantsCOTMaxOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    cotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipantsCOTMinOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    cotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSignatureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SignatureType | EnumSignatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSignatureTypeFilter<$PrismaModel> | $Enums.SignatureType
  }

  export type FileMetadataNullableScalarRelationFilter = {
    is?: FileMetadataWhereInput | null
    isNot?: FileMetadataWhereInput | null
  }

  export type SignatureCountOrderByAggregateInput = {
    id?: SortOrder
    idNumber?: SortOrder
    role?: SortOrder
    name?: SortOrder
    eSignId?: SortOrder
    signatureType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignatureAvgOrderByAggregateInput = {
    eSignId?: SortOrder
  }

  export type SignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    idNumber?: SortOrder
    role?: SortOrder
    name?: SortOrder
    eSignId?: SortOrder
    signatureType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignatureMinOrderByAggregateInput = {
    id?: SortOrder
    idNumber?: SortOrder
    role?: SortOrder
    name?: SortOrder
    eSignId?: SortOrder
    signatureType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignatureSumOrderByAggregateInput = {
    eSignId?: SortOrder
  }

  export type EnumSignatureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignatureType | EnumSignatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSignatureTypeWithAggregatesFilter<$PrismaModel> | $Enums.SignatureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignatureTypeFilter<$PrismaModel>
    _max?: NestedEnumSignatureTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SignatureScalarRelationFilter = {
    is?: SignatureWhereInput
    isNot?: SignatureWhereInput
  }

  export type ParticipantScalarRelationFilter = {
    is?: ParticipantWhereInput
    isNot?: ParticipantWhereInput
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    cotId?: SortOrder
    signatureId?: SortOrder
    participantId?: SortOrder
    issuedDate?: SortOrder
    certificateNumber?: SortOrder
    attendance?: SortOrder
    theoryScore?: SortOrder
    practiceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    theoryScore?: SortOrder
    practiceScore?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    cotId?: SortOrder
    signatureId?: SortOrder
    participantId?: SortOrder
    issuedDate?: SortOrder
    certificateNumber?: SortOrder
    attendance?: SortOrder
    theoryScore?: SortOrder
    practiceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    cotId?: SortOrder
    signatureId?: SortOrder
    participantId?: SortOrder
    issuedDate?: SortOrder
    certificateNumber?: SortOrder
    attendance?: SortOrder
    theoryScore?: SortOrder
    practiceScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    theoryScore?: SortOrder
    practiceScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlacklistedTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type BlacklistedTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type BlacklistedTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutUserInput = {
    create?: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutUserInput
    connect?: ParticipantWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BlacklistedTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<BlacklistedTokenCreateWithoutUserInput, BlacklistedTokenUncheckedCreateWithoutUserInput> | BlacklistedTokenCreateWithoutUserInput[] | BlacklistedTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistedTokenCreateOrConnectWithoutUserInput | BlacklistedTokenCreateOrConnectWithoutUserInput[]
    createMany?: BlacklistedTokenCreateManyUserInputEnvelope
    connect?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BlacklistedTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlacklistedTokenCreateWithoutUserInput, BlacklistedTokenUncheckedCreateWithoutUserInput> | BlacklistedTokenCreateWithoutUserInput[] | BlacklistedTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistedTokenCreateOrConnectWithoutUserInput | BlacklistedTokenCreateOrConnectWithoutUserInput[]
    createMany?: BlacklistedTokenCreateManyUserInputEnvelope
    connect?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumOAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.OAuthProvider | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type ParticipantUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutUserInput
    upsert?: ParticipantUpsertWithoutUserInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutUserInput, ParticipantUpdateWithoutUserInput>, ParticipantUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BlacklistedTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlacklistedTokenCreateWithoutUserInput, BlacklistedTokenUncheckedCreateWithoutUserInput> | BlacklistedTokenCreateWithoutUserInput[] | BlacklistedTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistedTokenCreateOrConnectWithoutUserInput | BlacklistedTokenCreateOrConnectWithoutUserInput[]
    upsert?: BlacklistedTokenUpsertWithWhereUniqueWithoutUserInput | BlacklistedTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlacklistedTokenCreateManyUserInputEnvelope
    set?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    disconnect?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    delete?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    connect?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    update?: BlacklistedTokenUpdateWithWhereUniqueWithoutUserInput | BlacklistedTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlacklistedTokenUpdateManyWithWhereWithoutUserInput | BlacklistedTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlacklistedTokenScalarWhereInput | BlacklistedTokenScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BlacklistedTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlacklistedTokenCreateWithoutUserInput, BlacklistedTokenUncheckedCreateWithoutUserInput> | BlacklistedTokenCreateWithoutUserInput[] | BlacklistedTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistedTokenCreateOrConnectWithoutUserInput | BlacklistedTokenCreateOrConnectWithoutUserInput[]
    upsert?: BlacklistedTokenUpsertWithWhereUniqueWithoutUserInput | BlacklistedTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlacklistedTokenCreateManyUserInputEnvelope
    set?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    disconnect?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    delete?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    connect?: BlacklistedTokenWhereUniqueInput | BlacklistedTokenWhereUniqueInput[]
    update?: BlacklistedTokenUpdateWithWhereUniqueWithoutUserInput | BlacklistedTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlacklistedTokenUpdateManyWithWhereWithoutUserInput | BlacklistedTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlacklistedTokenScalarWhereInput | BlacklistedTokenScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ParticipantCreateNestedOneWithoutSimAInput = {
    create?: XOR<ParticipantCreateWithoutSimAInput, ParticipantUncheckedCreateWithoutSimAInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSimAInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutSimBInput = {
    create?: XOR<ParticipantCreateWithoutSimBInput, ParticipantUncheckedCreateWithoutSimBInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSimBInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutKtpInput = {
    create?: XOR<ParticipantCreateWithoutKtpInput, ParticipantUncheckedCreateWithoutKtpInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutKtpInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutFotoInput = {
    create?: XOR<ParticipantCreateWithoutFotoInput, ParticipantUncheckedCreateWithoutFotoInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutFotoInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput = {
    create?: XOR<ParticipantCreateWithoutSuratSehatButaWarnaInput, ParticipantUncheckedCreateWithoutSuratSehatButaWarnaInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSuratSehatButaWarnaInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput = {
    create?: XOR<ParticipantCreateWithoutSuratBebasNarkobaInput, ParticipantUncheckedCreateWithoutSuratBebasNarkobaInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSuratBebasNarkobaInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutQrCodeInput = {
    create?: XOR<ParticipantCreateWithoutQrCodeInput, ParticipantUncheckedCreateWithoutQrCodeInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutQrCodeInput
    connect?: ParticipantWhereUniqueInput
  }

  export type SignatureCreateNestedOneWithoutESignInput = {
    create?: XOR<SignatureCreateWithoutESignInput, SignatureUncheckedCreateWithoutESignInput>
    connectOrCreate?: SignatureCreateOrConnectWithoutESignInput
    connect?: SignatureWhereUniqueInput
  }

  export type SignatureUncheckedCreateNestedOneWithoutESignInput = {
    create?: XOR<SignatureCreateWithoutESignInput, SignatureUncheckedCreateWithoutESignInput>
    connectOrCreate?: SignatureCreateOrConnectWithoutESignInput
    connect?: SignatureWhereUniqueInput
  }

  export type ParticipantUpdateOneWithoutSimANestedInput = {
    create?: XOR<ParticipantCreateWithoutSimAInput, ParticipantUncheckedCreateWithoutSimAInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSimAInput
    upsert?: ParticipantUpsertWithoutSimAInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutSimAInput, ParticipantUpdateWithoutSimAInput>, ParticipantUncheckedUpdateWithoutSimAInput>
  }

  export type ParticipantUpdateOneWithoutSimBNestedInput = {
    create?: XOR<ParticipantCreateWithoutSimBInput, ParticipantUncheckedCreateWithoutSimBInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSimBInput
    upsert?: ParticipantUpsertWithoutSimBInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutSimBInput, ParticipantUpdateWithoutSimBInput>, ParticipantUncheckedUpdateWithoutSimBInput>
  }

  export type ParticipantUpdateOneWithoutKtpNestedInput = {
    create?: XOR<ParticipantCreateWithoutKtpInput, ParticipantUncheckedCreateWithoutKtpInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutKtpInput
    upsert?: ParticipantUpsertWithoutKtpInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutKtpInput, ParticipantUpdateWithoutKtpInput>, ParticipantUncheckedUpdateWithoutKtpInput>
  }

  export type ParticipantUpdateOneWithoutFotoNestedInput = {
    create?: XOR<ParticipantCreateWithoutFotoInput, ParticipantUncheckedCreateWithoutFotoInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutFotoInput
    upsert?: ParticipantUpsertWithoutFotoInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutFotoInput, ParticipantUpdateWithoutFotoInput>, ParticipantUncheckedUpdateWithoutFotoInput>
  }

  export type ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput = {
    create?: XOR<ParticipantCreateWithoutSuratSehatButaWarnaInput, ParticipantUncheckedCreateWithoutSuratSehatButaWarnaInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSuratSehatButaWarnaInput
    upsert?: ParticipantUpsertWithoutSuratSehatButaWarnaInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutSuratSehatButaWarnaInput, ParticipantUpdateWithoutSuratSehatButaWarnaInput>, ParticipantUncheckedUpdateWithoutSuratSehatButaWarnaInput>
  }

  export type ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput = {
    create?: XOR<ParticipantCreateWithoutSuratBebasNarkobaInput, ParticipantUncheckedCreateWithoutSuratBebasNarkobaInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutSuratBebasNarkobaInput
    upsert?: ParticipantUpsertWithoutSuratBebasNarkobaInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutSuratBebasNarkobaInput, ParticipantUpdateWithoutSuratBebasNarkobaInput>, ParticipantUncheckedUpdateWithoutSuratBebasNarkobaInput>
  }

  export type ParticipantUpdateOneWithoutQrCodeNestedInput = {
    create?: XOR<ParticipantCreateWithoutQrCodeInput, ParticipantUncheckedCreateWithoutQrCodeInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutQrCodeInput
    upsert?: ParticipantUpsertWithoutQrCodeInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutQrCodeInput, ParticipantUpdateWithoutQrCodeInput>, ParticipantUncheckedUpdateWithoutQrCodeInput>
  }

  export type SignatureUpdateOneWithoutESignNestedInput = {
    create?: XOR<SignatureCreateWithoutESignInput, SignatureUncheckedCreateWithoutESignInput>
    connectOrCreate?: SignatureCreateOrConnectWithoutESignInput
    upsert?: SignatureUpsertWithoutESignInput
    disconnect?: SignatureWhereInput | boolean
    delete?: SignatureWhereInput | boolean
    connect?: SignatureWhereUniqueInput
    update?: XOR<XOR<SignatureUpdateToOneWithWhereWithoutESignInput, SignatureUpdateWithoutESignInput>, SignatureUncheckedUpdateWithoutESignInput>
  }

  export type SignatureUncheckedUpdateOneWithoutESignNestedInput = {
    create?: XOR<SignatureCreateWithoutESignInput, SignatureUncheckedCreateWithoutESignInput>
    connectOrCreate?: SignatureCreateOrConnectWithoutESignInput
    upsert?: SignatureUpsertWithoutESignInput
    disconnect?: SignatureWhereInput | boolean
    delete?: SignatureWhereInput | boolean
    connect?: SignatureWhereUniqueInput
    update?: XOR<XOR<SignatureUpdateToOneWithWhereWithoutESignInput, SignatureUpdateWithoutESignInput>, SignatureUncheckedUpdateWithoutESignInput>
  }

  export type FileMetadataCreateNestedManyWithoutParticipantSimAInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimAInput, FileMetadataUncheckedCreateWithoutParticipantSimAInput> | FileMetadataCreateWithoutParticipantSimAInput[] | FileMetadataUncheckedCreateWithoutParticipantSimAInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimAInput | FileMetadataCreateOrConnectWithoutParticipantSimAInput[]
    createMany?: FileMetadataCreateManyParticipantSimAInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutParticipantSimBInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimBInput, FileMetadataUncheckedCreateWithoutParticipantSimBInput> | FileMetadataCreateWithoutParticipantSimBInput[] | FileMetadataUncheckedCreateWithoutParticipantSimBInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimBInput | FileMetadataCreateOrConnectWithoutParticipantSimBInput[]
    createMany?: FileMetadataCreateManyParticipantSimBInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutParticipantKtpInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantKtpInput, FileMetadataUncheckedCreateWithoutParticipantKtpInput> | FileMetadataCreateWithoutParticipantKtpInput[] | FileMetadataUncheckedCreateWithoutParticipantKtpInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantKtpInput | FileMetadataCreateOrConnectWithoutParticipantKtpInput[]
    createMany?: FileMetadataCreateManyParticipantKtpInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutParticipantFotoInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantFotoInput, FileMetadataUncheckedCreateWithoutParticipantFotoInput> | FileMetadataCreateWithoutParticipantFotoInput[] | FileMetadataUncheckedCreateWithoutParticipantFotoInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantFotoInput | FileMetadataCreateOrConnectWithoutParticipantFotoInput[]
    createMany?: FileMetadataCreateManyParticipantFotoInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput> | FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput | FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratSehatButaWarnaInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput> | FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput | FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratBebasNarkobaInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutParticipantQrCodeInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantQrCodeInput, FileMetadataUncheckedCreateWithoutParticipantQrCodeInput> | FileMetadataCreateWithoutParticipantQrCodeInput[] | FileMetadataUncheckedCreateWithoutParticipantQrCodeInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantQrCodeInput | FileMetadataCreateOrConnectWithoutParticipantQrCodeInput[]
    createMany?: FileMetadataCreateManyParticipantQrCodeInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type ParticipantsCOTCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ParticipantsCOTCreateWithoutParticipantInput, ParticipantsCOTUncheckedCreateWithoutParticipantInput> | ParticipantsCOTCreateWithoutParticipantInput[] | ParticipantsCOTUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutParticipantInput | ParticipantsCOTCreateOrConnectWithoutParticipantInput[]
    createMany?: ParticipantsCOTCreateManyParticipantInputEnvelope
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutParticipantInput = {
    create?: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type CertificateCreateNestedManyWithoutParticipantInput = {
    create?: XOR<CertificateCreateWithoutParticipantInput, CertificateUncheckedCreateWithoutParticipantInput> | CertificateCreateWithoutParticipantInput[] | CertificateUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutParticipantInput | CertificateCreateOrConnectWithoutParticipantInput[]
    createMany?: CertificateCreateManyParticipantInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimAInput, FileMetadataUncheckedCreateWithoutParticipantSimAInput> | FileMetadataCreateWithoutParticipantSimAInput[] | FileMetadataUncheckedCreateWithoutParticipantSimAInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimAInput | FileMetadataCreateOrConnectWithoutParticipantSimAInput[]
    createMany?: FileMetadataCreateManyParticipantSimAInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimBInput, FileMetadataUncheckedCreateWithoutParticipantSimBInput> | FileMetadataCreateWithoutParticipantSimBInput[] | FileMetadataUncheckedCreateWithoutParticipantSimBInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimBInput | FileMetadataCreateOrConnectWithoutParticipantSimBInput[]
    createMany?: FileMetadataCreateManyParticipantSimBInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantKtpInput, FileMetadataUncheckedCreateWithoutParticipantKtpInput> | FileMetadataCreateWithoutParticipantKtpInput[] | FileMetadataUncheckedCreateWithoutParticipantKtpInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantKtpInput | FileMetadataCreateOrConnectWithoutParticipantKtpInput[]
    createMany?: FileMetadataCreateManyParticipantKtpInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantFotoInput, FileMetadataUncheckedCreateWithoutParticipantFotoInput> | FileMetadataCreateWithoutParticipantFotoInput[] | FileMetadataUncheckedCreateWithoutParticipantFotoInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantFotoInput | FileMetadataCreateOrConnectWithoutParticipantFotoInput[]
    createMany?: FileMetadataCreateManyParticipantFotoInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput> | FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput | FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratSehatButaWarnaInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput> | FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput | FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratBebasNarkobaInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantQrCodeInput, FileMetadataUncheckedCreateWithoutParticipantQrCodeInput> | FileMetadataCreateWithoutParticipantQrCodeInput[] | FileMetadataUncheckedCreateWithoutParticipantQrCodeInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantQrCodeInput | FileMetadataCreateOrConnectWithoutParticipantQrCodeInput[]
    createMany?: FileMetadataCreateManyParticipantQrCodeInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ParticipantsCOTCreateWithoutParticipantInput, ParticipantsCOTUncheckedCreateWithoutParticipantInput> | ParticipantsCOTCreateWithoutParticipantInput[] | ParticipantsCOTUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutParticipantInput | ParticipantsCOTCreateOrConnectWithoutParticipantInput[]
    createMany?: ParticipantsCOTCreateManyParticipantInputEnvelope
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutParticipantInput = {
    create?: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type CertificateUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<CertificateCreateWithoutParticipantInput, CertificateUncheckedCreateWithoutParticipantInput> | CertificateCreateWithoutParticipantInput[] | CertificateUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutParticipantInput | CertificateCreateOrConnectWithoutParticipantInput[]
    createMany?: CertificateCreateManyParticipantInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FileMetadataUpdateManyWithoutParticipantSimANestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimAInput, FileMetadataUncheckedCreateWithoutParticipantSimAInput> | FileMetadataCreateWithoutParticipantSimAInput[] | FileMetadataUncheckedCreateWithoutParticipantSimAInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimAInput | FileMetadataCreateOrConnectWithoutParticipantSimAInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSimAInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSimAInput[]
    createMany?: FileMetadataCreateManyParticipantSimAInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSimAInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSimAInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSimAInput | FileMetadataUpdateManyWithWhereWithoutParticipantSimAInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutParticipantSimBNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimBInput, FileMetadataUncheckedCreateWithoutParticipantSimBInput> | FileMetadataCreateWithoutParticipantSimBInput[] | FileMetadataUncheckedCreateWithoutParticipantSimBInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimBInput | FileMetadataCreateOrConnectWithoutParticipantSimBInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSimBInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSimBInput[]
    createMany?: FileMetadataCreateManyParticipantSimBInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSimBInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSimBInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSimBInput | FileMetadataUpdateManyWithWhereWithoutParticipantSimBInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutParticipantKtpNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantKtpInput, FileMetadataUncheckedCreateWithoutParticipantKtpInput> | FileMetadataCreateWithoutParticipantKtpInput[] | FileMetadataUncheckedCreateWithoutParticipantKtpInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantKtpInput | FileMetadataCreateOrConnectWithoutParticipantKtpInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantKtpInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantKtpInput[]
    createMany?: FileMetadataCreateManyParticipantKtpInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantKtpInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantKtpInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantKtpInput | FileMetadataUpdateManyWithWhereWithoutParticipantKtpInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutParticipantFotoNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantFotoInput, FileMetadataUncheckedCreateWithoutParticipantFotoInput> | FileMetadataCreateWithoutParticipantFotoInput[] | FileMetadataUncheckedCreateWithoutParticipantFotoInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantFotoInput | FileMetadataCreateOrConnectWithoutParticipantFotoInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantFotoInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantFotoInput[]
    createMany?: FileMetadataCreateManyParticipantFotoInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantFotoInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantFotoInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantFotoInput | FileMetadataUpdateManyWithWhereWithoutParticipantFotoInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput> | FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput | FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratSehatButaWarnaInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSuratSehatButaWarnaInput | FileMetadataUpdateManyWithWhereWithoutParticipantSuratSehatButaWarnaInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput> | FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput | FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratBebasNarkobaInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSuratBebasNarkobaInput | FileMetadataUpdateManyWithWhereWithoutParticipantSuratBebasNarkobaInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantQrCodeInput, FileMetadataUncheckedCreateWithoutParticipantQrCodeInput> | FileMetadataCreateWithoutParticipantQrCodeInput[] | FileMetadataUncheckedCreateWithoutParticipantQrCodeInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantQrCodeInput | FileMetadataCreateOrConnectWithoutParticipantQrCodeInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantQrCodeInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantQrCodeInput[]
    createMany?: FileMetadataCreateManyParticipantQrCodeInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantQrCodeInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantQrCodeInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantQrCodeInput | FileMetadataUpdateManyWithWhereWithoutParticipantQrCodeInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type ParticipantsCOTUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ParticipantsCOTCreateWithoutParticipantInput, ParticipantsCOTUncheckedCreateWithoutParticipantInput> | ParticipantsCOTCreateWithoutParticipantInput[] | ParticipantsCOTUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutParticipantInput | ParticipantsCOTCreateOrConnectWithoutParticipantInput[]
    upsert?: ParticipantsCOTUpsertWithWhereUniqueWithoutParticipantInput | ParticipantsCOTUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ParticipantsCOTCreateManyParticipantInputEnvelope
    set?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    disconnect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    delete?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    update?: ParticipantsCOTUpdateWithWhereUniqueWithoutParticipantInput | ParticipantsCOTUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ParticipantsCOTUpdateManyWithWhereWithoutParticipantInput | ParticipantsCOTUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ParticipantsCOTScalarWhereInput | ParticipantsCOTScalarWhereInput[]
  }

  export type UserUpdateOneWithoutParticipantNestedInput = {
    create?: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipantInput
    upsert?: UserUpsertWithoutParticipantInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParticipantInput, UserUpdateWithoutParticipantInput>, UserUncheckedUpdateWithoutParticipantInput>
  }

  export type CertificateUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<CertificateCreateWithoutParticipantInput, CertificateUncheckedCreateWithoutParticipantInput> | CertificateCreateWithoutParticipantInput[] | CertificateUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutParticipantInput | CertificateCreateOrConnectWithoutParticipantInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutParticipantInput | CertificateUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: CertificateCreateManyParticipantInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutParticipantInput | CertificateUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutParticipantInput | CertificateUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimAInput, FileMetadataUncheckedCreateWithoutParticipantSimAInput> | FileMetadataCreateWithoutParticipantSimAInput[] | FileMetadataUncheckedCreateWithoutParticipantSimAInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimAInput | FileMetadataCreateOrConnectWithoutParticipantSimAInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSimAInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSimAInput[]
    createMany?: FileMetadataCreateManyParticipantSimAInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSimAInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSimAInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSimAInput | FileMetadataUpdateManyWithWhereWithoutParticipantSimAInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSimBInput, FileMetadataUncheckedCreateWithoutParticipantSimBInput> | FileMetadataCreateWithoutParticipantSimBInput[] | FileMetadataUncheckedCreateWithoutParticipantSimBInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSimBInput | FileMetadataCreateOrConnectWithoutParticipantSimBInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSimBInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSimBInput[]
    createMany?: FileMetadataCreateManyParticipantSimBInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSimBInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSimBInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSimBInput | FileMetadataUpdateManyWithWhereWithoutParticipantSimBInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantKtpInput, FileMetadataUncheckedCreateWithoutParticipantKtpInput> | FileMetadataCreateWithoutParticipantKtpInput[] | FileMetadataUncheckedCreateWithoutParticipantKtpInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantKtpInput | FileMetadataCreateOrConnectWithoutParticipantKtpInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantKtpInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantKtpInput[]
    createMany?: FileMetadataCreateManyParticipantKtpInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantKtpInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantKtpInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantKtpInput | FileMetadataUpdateManyWithWhereWithoutParticipantKtpInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantFotoInput, FileMetadataUncheckedCreateWithoutParticipantFotoInput> | FileMetadataCreateWithoutParticipantFotoInput[] | FileMetadataUncheckedCreateWithoutParticipantFotoInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantFotoInput | FileMetadataCreateOrConnectWithoutParticipantFotoInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantFotoInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantFotoInput[]
    createMany?: FileMetadataCreateManyParticipantFotoInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantFotoInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantFotoInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantFotoInput | FileMetadataUpdateManyWithWhereWithoutParticipantFotoInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput> | FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput | FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratSehatButaWarnaInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSuratSehatButaWarnaInput | FileMetadataUpdateManyWithWhereWithoutParticipantSuratSehatButaWarnaInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput> | FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput[] | FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput | FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput[]
    createMany?: FileMetadataCreateManyParticipantSuratBebasNarkobaInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantSuratBebasNarkobaInput | FileMetadataUpdateManyWithWhereWithoutParticipantSuratBebasNarkobaInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput = {
    create?: XOR<FileMetadataCreateWithoutParticipantQrCodeInput, FileMetadataUncheckedCreateWithoutParticipantQrCodeInput> | FileMetadataCreateWithoutParticipantQrCodeInput[] | FileMetadataUncheckedCreateWithoutParticipantQrCodeInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutParticipantQrCodeInput | FileMetadataCreateOrConnectWithoutParticipantQrCodeInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutParticipantQrCodeInput | FileMetadataUpsertWithWhereUniqueWithoutParticipantQrCodeInput[]
    createMany?: FileMetadataCreateManyParticipantQrCodeInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutParticipantQrCodeInput | FileMetadataUpdateWithWhereUniqueWithoutParticipantQrCodeInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutParticipantQrCodeInput | FileMetadataUpdateManyWithWhereWithoutParticipantQrCodeInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ParticipantsCOTCreateWithoutParticipantInput, ParticipantsCOTUncheckedCreateWithoutParticipantInput> | ParticipantsCOTCreateWithoutParticipantInput[] | ParticipantsCOTUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutParticipantInput | ParticipantsCOTCreateOrConnectWithoutParticipantInput[]
    upsert?: ParticipantsCOTUpsertWithWhereUniqueWithoutParticipantInput | ParticipantsCOTUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ParticipantsCOTCreateManyParticipantInputEnvelope
    set?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    disconnect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    delete?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    update?: ParticipantsCOTUpdateWithWhereUniqueWithoutParticipantInput | ParticipantsCOTUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ParticipantsCOTUpdateManyWithWhereWithoutParticipantInput | ParticipantsCOTUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ParticipantsCOTScalarWhereInput | ParticipantsCOTScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutParticipantNestedInput = {
    create?: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipantInput
    upsert?: UserUpsertWithoutParticipantInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParticipantInput, UserUpdateWithoutParticipantInput>, UserUncheckedUpdateWithoutParticipantInput>
  }

  export type CertificateUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<CertificateCreateWithoutParticipantInput, CertificateUncheckedCreateWithoutParticipantInput> | CertificateCreateWithoutParticipantInput[] | CertificateUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutParticipantInput | CertificateCreateOrConnectWithoutParticipantInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutParticipantInput | CertificateUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: CertificateCreateManyParticipantInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutParticipantInput | CertificateUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutParticipantInput | CertificateUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CurriculumSyllabusCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<CurriculumSyllabusCreateWithoutCapabilityInput, CurriculumSyllabusUncheckedCreateWithoutCapabilityInput> | CurriculumSyllabusCreateWithoutCapabilityInput[] | CurriculumSyllabusUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CurriculumSyllabusCreateOrConnectWithoutCapabilityInput | CurriculumSyllabusCreateOrConnectWithoutCapabilityInput[]
    createMany?: CurriculumSyllabusCreateManyCapabilityInputEnvelope
    connect?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
  }

  export type CapabilityCOTCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<CapabilityCOTCreateWithoutCapabilityInput, CapabilityCOTUncheckedCreateWithoutCapabilityInput> | CapabilityCOTCreateWithoutCapabilityInput[] | CapabilityCOTUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCapabilityInput | CapabilityCOTCreateOrConnectWithoutCapabilityInput[]
    createMany?: CapabilityCOTCreateManyCapabilityInputEnvelope
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
  }

  export type CurriculumSyllabusUncheckedCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<CurriculumSyllabusCreateWithoutCapabilityInput, CurriculumSyllabusUncheckedCreateWithoutCapabilityInput> | CurriculumSyllabusCreateWithoutCapabilityInput[] | CurriculumSyllabusUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CurriculumSyllabusCreateOrConnectWithoutCapabilityInput | CurriculumSyllabusCreateOrConnectWithoutCapabilityInput[]
    createMany?: CurriculumSyllabusCreateManyCapabilityInputEnvelope
    connect?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
  }

  export type CapabilityCOTUncheckedCreateNestedManyWithoutCapabilityInput = {
    create?: XOR<CapabilityCOTCreateWithoutCapabilityInput, CapabilityCOTUncheckedCreateWithoutCapabilityInput> | CapabilityCOTCreateWithoutCapabilityInput[] | CapabilityCOTUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCapabilityInput | CapabilityCOTCreateOrConnectWithoutCapabilityInput[]
    createMany?: CapabilityCOTCreateManyCapabilityInputEnvelope
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CurriculumSyllabusUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<CurriculumSyllabusCreateWithoutCapabilityInput, CurriculumSyllabusUncheckedCreateWithoutCapabilityInput> | CurriculumSyllabusCreateWithoutCapabilityInput[] | CurriculumSyllabusUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CurriculumSyllabusCreateOrConnectWithoutCapabilityInput | CurriculumSyllabusCreateOrConnectWithoutCapabilityInput[]
    upsert?: CurriculumSyllabusUpsertWithWhereUniqueWithoutCapabilityInput | CurriculumSyllabusUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: CurriculumSyllabusCreateManyCapabilityInputEnvelope
    set?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    disconnect?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    delete?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    connect?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    update?: CurriculumSyllabusUpdateWithWhereUniqueWithoutCapabilityInput | CurriculumSyllabusUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: CurriculumSyllabusUpdateManyWithWhereWithoutCapabilityInput | CurriculumSyllabusUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: CurriculumSyllabusScalarWhereInput | CurriculumSyllabusScalarWhereInput[]
  }

  export type CapabilityCOTUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<CapabilityCOTCreateWithoutCapabilityInput, CapabilityCOTUncheckedCreateWithoutCapabilityInput> | CapabilityCOTCreateWithoutCapabilityInput[] | CapabilityCOTUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCapabilityInput | CapabilityCOTCreateOrConnectWithoutCapabilityInput[]
    upsert?: CapabilityCOTUpsertWithWhereUniqueWithoutCapabilityInput | CapabilityCOTUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: CapabilityCOTCreateManyCapabilityInputEnvelope
    set?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    disconnect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    delete?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    update?: CapabilityCOTUpdateWithWhereUniqueWithoutCapabilityInput | CapabilityCOTUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: CapabilityCOTUpdateManyWithWhereWithoutCapabilityInput | CapabilityCOTUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: CapabilityCOTScalarWhereInput | CapabilityCOTScalarWhereInput[]
  }

  export type CurriculumSyllabusUncheckedUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<CurriculumSyllabusCreateWithoutCapabilityInput, CurriculumSyllabusUncheckedCreateWithoutCapabilityInput> | CurriculumSyllabusCreateWithoutCapabilityInput[] | CurriculumSyllabusUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CurriculumSyllabusCreateOrConnectWithoutCapabilityInput | CurriculumSyllabusCreateOrConnectWithoutCapabilityInput[]
    upsert?: CurriculumSyllabusUpsertWithWhereUniqueWithoutCapabilityInput | CurriculumSyllabusUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: CurriculumSyllabusCreateManyCapabilityInputEnvelope
    set?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    disconnect?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    delete?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    connect?: CurriculumSyllabusWhereUniqueInput | CurriculumSyllabusWhereUniqueInput[]
    update?: CurriculumSyllabusUpdateWithWhereUniqueWithoutCapabilityInput | CurriculumSyllabusUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: CurriculumSyllabusUpdateManyWithWhereWithoutCapabilityInput | CurriculumSyllabusUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: CurriculumSyllabusScalarWhereInput | CurriculumSyllabusScalarWhereInput[]
  }

  export type CapabilityCOTUncheckedUpdateManyWithoutCapabilityNestedInput = {
    create?: XOR<CapabilityCOTCreateWithoutCapabilityInput, CapabilityCOTUncheckedCreateWithoutCapabilityInput> | CapabilityCOTCreateWithoutCapabilityInput[] | CapabilityCOTUncheckedCreateWithoutCapabilityInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCapabilityInput | CapabilityCOTCreateOrConnectWithoutCapabilityInput[]
    upsert?: CapabilityCOTUpsertWithWhereUniqueWithoutCapabilityInput | CapabilityCOTUpsertWithWhereUniqueWithoutCapabilityInput[]
    createMany?: CapabilityCOTCreateManyCapabilityInputEnvelope
    set?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    disconnect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    delete?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    update?: CapabilityCOTUpdateWithWhereUniqueWithoutCapabilityInput | CapabilityCOTUpdateWithWhereUniqueWithoutCapabilityInput[]
    updateMany?: CapabilityCOTUpdateManyWithWhereWithoutCapabilityInput | CapabilityCOTUpdateManyWithWhereWithoutCapabilityInput[]
    deleteMany?: CapabilityCOTScalarWhereInput | CapabilityCOTScalarWhereInput[]
  }

  export type CapabilityCreateNestedOneWithoutCurriculumSyllabusInput = {
    create?: XOR<CapabilityCreateWithoutCurriculumSyllabusInput, CapabilityUncheckedCreateWithoutCurriculumSyllabusInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutCurriculumSyllabusInput
    connect?: CapabilityWhereUniqueInput
  }

  export type CapabilityUpdateOneRequiredWithoutCurriculumSyllabusNestedInput = {
    create?: XOR<CapabilityCreateWithoutCurriculumSyllabusInput, CapabilityUncheckedCreateWithoutCurriculumSyllabusInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutCurriculumSyllabusInput
    upsert?: CapabilityUpsertWithoutCurriculumSyllabusInput
    connect?: CapabilityWhereUniqueInput
    update?: XOR<XOR<CapabilityUpdateToOneWithWhereWithoutCurriculumSyllabusInput, CapabilityUpdateWithoutCurriculumSyllabusInput>, CapabilityUncheckedUpdateWithoutCurriculumSyllabusInput>
  }

  export type CapabilityCOTCreateNestedManyWithoutCotInput = {
    create?: XOR<CapabilityCOTCreateWithoutCotInput, CapabilityCOTUncheckedCreateWithoutCotInput> | CapabilityCOTCreateWithoutCotInput[] | CapabilityCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCotInput | CapabilityCOTCreateOrConnectWithoutCotInput[]
    createMany?: CapabilityCOTCreateManyCotInputEnvelope
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
  }

  export type ParticipantsCOTCreateNestedManyWithoutCotInput = {
    create?: XOR<ParticipantsCOTCreateWithoutCotInput, ParticipantsCOTUncheckedCreateWithoutCotInput> | ParticipantsCOTCreateWithoutCotInput[] | ParticipantsCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutCotInput | ParticipantsCOTCreateOrConnectWithoutCotInput[]
    createMany?: ParticipantsCOTCreateManyCotInputEnvelope
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutCotInput = {
    create?: XOR<CertificateCreateWithoutCotInput, CertificateUncheckedCreateWithoutCotInput> | CertificateCreateWithoutCotInput[] | CertificateUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCotInput | CertificateCreateOrConnectWithoutCotInput[]
    createMany?: CertificateCreateManyCotInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CapabilityCOTUncheckedCreateNestedManyWithoutCotInput = {
    create?: XOR<CapabilityCOTCreateWithoutCotInput, CapabilityCOTUncheckedCreateWithoutCotInput> | CapabilityCOTCreateWithoutCotInput[] | CapabilityCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCotInput | CapabilityCOTCreateOrConnectWithoutCotInput[]
    createMany?: CapabilityCOTCreateManyCotInputEnvelope
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
  }

  export type ParticipantsCOTUncheckedCreateNestedManyWithoutCotInput = {
    create?: XOR<ParticipantsCOTCreateWithoutCotInput, ParticipantsCOTUncheckedCreateWithoutCotInput> | ParticipantsCOTCreateWithoutCotInput[] | ParticipantsCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutCotInput | ParticipantsCOTCreateOrConnectWithoutCotInput[]
    createMany?: ParticipantsCOTCreateManyCotInputEnvelope
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutCotInput = {
    create?: XOR<CertificateCreateWithoutCotInput, CertificateUncheckedCreateWithoutCotInput> | CertificateCreateWithoutCotInput[] | CertificateUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCotInput | CertificateCreateOrConnectWithoutCotInput[]
    createMany?: CertificateCreateManyCotInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CapabilityCOTUpdateManyWithoutCotNestedInput = {
    create?: XOR<CapabilityCOTCreateWithoutCotInput, CapabilityCOTUncheckedCreateWithoutCotInput> | CapabilityCOTCreateWithoutCotInput[] | CapabilityCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCotInput | CapabilityCOTCreateOrConnectWithoutCotInput[]
    upsert?: CapabilityCOTUpsertWithWhereUniqueWithoutCotInput | CapabilityCOTUpsertWithWhereUniqueWithoutCotInput[]
    createMany?: CapabilityCOTCreateManyCotInputEnvelope
    set?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    disconnect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    delete?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    update?: CapabilityCOTUpdateWithWhereUniqueWithoutCotInput | CapabilityCOTUpdateWithWhereUniqueWithoutCotInput[]
    updateMany?: CapabilityCOTUpdateManyWithWhereWithoutCotInput | CapabilityCOTUpdateManyWithWhereWithoutCotInput[]
    deleteMany?: CapabilityCOTScalarWhereInput | CapabilityCOTScalarWhereInput[]
  }

  export type ParticipantsCOTUpdateManyWithoutCotNestedInput = {
    create?: XOR<ParticipantsCOTCreateWithoutCotInput, ParticipantsCOTUncheckedCreateWithoutCotInput> | ParticipantsCOTCreateWithoutCotInput[] | ParticipantsCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutCotInput | ParticipantsCOTCreateOrConnectWithoutCotInput[]
    upsert?: ParticipantsCOTUpsertWithWhereUniqueWithoutCotInput | ParticipantsCOTUpsertWithWhereUniqueWithoutCotInput[]
    createMany?: ParticipantsCOTCreateManyCotInputEnvelope
    set?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    disconnect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    delete?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    update?: ParticipantsCOTUpdateWithWhereUniqueWithoutCotInput | ParticipantsCOTUpdateWithWhereUniqueWithoutCotInput[]
    updateMany?: ParticipantsCOTUpdateManyWithWhereWithoutCotInput | ParticipantsCOTUpdateManyWithWhereWithoutCotInput[]
    deleteMany?: ParticipantsCOTScalarWhereInput | ParticipantsCOTScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutCotNestedInput = {
    create?: XOR<CertificateCreateWithoutCotInput, CertificateUncheckedCreateWithoutCotInput> | CertificateCreateWithoutCotInput[] | CertificateUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCotInput | CertificateCreateOrConnectWithoutCotInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCotInput | CertificateUpsertWithWhereUniqueWithoutCotInput[]
    createMany?: CertificateCreateManyCotInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCotInput | CertificateUpdateWithWhereUniqueWithoutCotInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCotInput | CertificateUpdateManyWithWhereWithoutCotInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CapabilityCOTUncheckedUpdateManyWithoutCotNestedInput = {
    create?: XOR<CapabilityCOTCreateWithoutCotInput, CapabilityCOTUncheckedCreateWithoutCotInput> | CapabilityCOTCreateWithoutCotInput[] | CapabilityCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CapabilityCOTCreateOrConnectWithoutCotInput | CapabilityCOTCreateOrConnectWithoutCotInput[]
    upsert?: CapabilityCOTUpsertWithWhereUniqueWithoutCotInput | CapabilityCOTUpsertWithWhereUniqueWithoutCotInput[]
    createMany?: CapabilityCOTCreateManyCotInputEnvelope
    set?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    disconnect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    delete?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    connect?: CapabilityCOTWhereUniqueInput | CapabilityCOTWhereUniqueInput[]
    update?: CapabilityCOTUpdateWithWhereUniqueWithoutCotInput | CapabilityCOTUpdateWithWhereUniqueWithoutCotInput[]
    updateMany?: CapabilityCOTUpdateManyWithWhereWithoutCotInput | CapabilityCOTUpdateManyWithWhereWithoutCotInput[]
    deleteMany?: CapabilityCOTScalarWhereInput | CapabilityCOTScalarWhereInput[]
  }

  export type ParticipantsCOTUncheckedUpdateManyWithoutCotNestedInput = {
    create?: XOR<ParticipantsCOTCreateWithoutCotInput, ParticipantsCOTUncheckedCreateWithoutCotInput> | ParticipantsCOTCreateWithoutCotInput[] | ParticipantsCOTUncheckedCreateWithoutCotInput[]
    connectOrCreate?: ParticipantsCOTCreateOrConnectWithoutCotInput | ParticipantsCOTCreateOrConnectWithoutCotInput[]
    upsert?: ParticipantsCOTUpsertWithWhereUniqueWithoutCotInput | ParticipantsCOTUpsertWithWhereUniqueWithoutCotInput[]
    createMany?: ParticipantsCOTCreateManyCotInputEnvelope
    set?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    disconnect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    delete?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    connect?: ParticipantsCOTWhereUniqueInput | ParticipantsCOTWhereUniqueInput[]
    update?: ParticipantsCOTUpdateWithWhereUniqueWithoutCotInput | ParticipantsCOTUpdateWithWhereUniqueWithoutCotInput[]
    updateMany?: ParticipantsCOTUpdateManyWithWhereWithoutCotInput | ParticipantsCOTUpdateManyWithWhereWithoutCotInput[]
    deleteMany?: ParticipantsCOTScalarWhereInput | ParticipantsCOTScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutCotNestedInput = {
    create?: XOR<CertificateCreateWithoutCotInput, CertificateUncheckedCreateWithoutCotInput> | CertificateCreateWithoutCotInput[] | CertificateUncheckedCreateWithoutCotInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCotInput | CertificateCreateOrConnectWithoutCotInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCotInput | CertificateUpsertWithWhereUniqueWithoutCotInput[]
    createMany?: CertificateCreateManyCotInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCotInput | CertificateUpdateWithWhereUniqueWithoutCotInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCotInput | CertificateUpdateManyWithWhereWithoutCotInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CapabilityCreateNestedOneWithoutCapabilityCotsInput = {
    create?: XOR<CapabilityCreateWithoutCapabilityCotsInput, CapabilityUncheckedCreateWithoutCapabilityCotsInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutCapabilityCotsInput
    connect?: CapabilityWhereUniqueInput
  }

  export type COTCreateNestedOneWithoutCapabilityCotsInput = {
    create?: XOR<COTCreateWithoutCapabilityCotsInput, COTUncheckedCreateWithoutCapabilityCotsInput>
    connectOrCreate?: COTCreateOrConnectWithoutCapabilityCotsInput
    connect?: COTWhereUniqueInput
  }

  export type CapabilityUpdateOneRequiredWithoutCapabilityCotsNestedInput = {
    create?: XOR<CapabilityCreateWithoutCapabilityCotsInput, CapabilityUncheckedCreateWithoutCapabilityCotsInput>
    connectOrCreate?: CapabilityCreateOrConnectWithoutCapabilityCotsInput
    upsert?: CapabilityUpsertWithoutCapabilityCotsInput
    connect?: CapabilityWhereUniqueInput
    update?: XOR<XOR<CapabilityUpdateToOneWithWhereWithoutCapabilityCotsInput, CapabilityUpdateWithoutCapabilityCotsInput>, CapabilityUncheckedUpdateWithoutCapabilityCotsInput>
  }

  export type COTUpdateOneRequiredWithoutCapabilityCotsNestedInput = {
    create?: XOR<COTCreateWithoutCapabilityCotsInput, COTUncheckedCreateWithoutCapabilityCotsInput>
    connectOrCreate?: COTCreateOrConnectWithoutCapabilityCotsInput
    upsert?: COTUpsertWithoutCapabilityCotsInput
    connect?: COTWhereUniqueInput
    update?: XOR<XOR<COTUpdateToOneWithWhereWithoutCapabilityCotsInput, COTUpdateWithoutCapabilityCotsInput>, COTUncheckedUpdateWithoutCapabilityCotsInput>
  }

  export type ParticipantCreateNestedOneWithoutParticipantsCotsInput = {
    create?: XOR<ParticipantCreateWithoutParticipantsCotsInput, ParticipantUncheckedCreateWithoutParticipantsCotsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutParticipantsCotsInput
    connect?: ParticipantWhereUniqueInput
  }

  export type COTCreateNestedOneWithoutParticipantsCotsInput = {
    create?: XOR<COTCreateWithoutParticipantsCotsInput, COTUncheckedCreateWithoutParticipantsCotsInput>
    connectOrCreate?: COTCreateOrConnectWithoutParticipantsCotsInput
    connect?: COTWhereUniqueInput
  }

  export type ParticipantUpdateOneWithoutParticipantsCotsNestedInput = {
    create?: XOR<ParticipantCreateWithoutParticipantsCotsInput, ParticipantUncheckedCreateWithoutParticipantsCotsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutParticipantsCotsInput
    upsert?: ParticipantUpsertWithoutParticipantsCotsInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutParticipantsCotsInput, ParticipantUpdateWithoutParticipantsCotsInput>, ParticipantUncheckedUpdateWithoutParticipantsCotsInput>
  }

  export type COTUpdateOneRequiredWithoutParticipantsCotsNestedInput = {
    create?: XOR<COTCreateWithoutParticipantsCotsInput, COTUncheckedCreateWithoutParticipantsCotsInput>
    connectOrCreate?: COTCreateOrConnectWithoutParticipantsCotsInput
    upsert?: COTUpsertWithoutParticipantsCotsInput
    connect?: COTWhereUniqueInput
    update?: XOR<XOR<COTUpdateToOneWithWhereWithoutParticipantsCotsInput, COTUpdateWithoutParticipantsCotsInput>, COTUncheckedUpdateWithoutParticipantsCotsInput>
  }

  export type FileMetadataCreateNestedOneWithoutSignatureESignInput = {
    create?: XOR<FileMetadataCreateWithoutSignatureESignInput, FileMetadataUncheckedCreateWithoutSignatureESignInput>
    connectOrCreate?: FileMetadataCreateOrConnectWithoutSignatureESignInput
    connect?: FileMetadataWhereUniqueInput
  }

  export type CertificateCreateNestedManyWithoutSignatureInput = {
    create?: XOR<CertificateCreateWithoutSignatureInput, CertificateUncheckedCreateWithoutSignatureInput> | CertificateCreateWithoutSignatureInput[] | CertificateUncheckedCreateWithoutSignatureInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSignatureInput | CertificateCreateOrConnectWithoutSignatureInput[]
    createMany?: CertificateCreateManySignatureInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutSignatureInput = {
    create?: XOR<CertificateCreateWithoutSignatureInput, CertificateUncheckedCreateWithoutSignatureInput> | CertificateCreateWithoutSignatureInput[] | CertificateUncheckedCreateWithoutSignatureInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSignatureInput | CertificateCreateOrConnectWithoutSignatureInput[]
    createMany?: CertificateCreateManySignatureInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type EnumSignatureTypeFieldUpdateOperationsInput = {
    set?: $Enums.SignatureType
  }

  export type FileMetadataUpdateOneWithoutSignatureESignNestedInput = {
    create?: XOR<FileMetadataCreateWithoutSignatureESignInput, FileMetadataUncheckedCreateWithoutSignatureESignInput>
    connectOrCreate?: FileMetadataCreateOrConnectWithoutSignatureESignInput
    upsert?: FileMetadataUpsertWithoutSignatureESignInput
    disconnect?: FileMetadataWhereInput | boolean
    delete?: FileMetadataWhereInput | boolean
    connect?: FileMetadataWhereUniqueInput
    update?: XOR<XOR<FileMetadataUpdateToOneWithWhereWithoutSignatureESignInput, FileMetadataUpdateWithoutSignatureESignInput>, FileMetadataUncheckedUpdateWithoutSignatureESignInput>
  }

  export type CertificateUpdateManyWithoutSignatureNestedInput = {
    create?: XOR<CertificateCreateWithoutSignatureInput, CertificateUncheckedCreateWithoutSignatureInput> | CertificateCreateWithoutSignatureInput[] | CertificateUncheckedCreateWithoutSignatureInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSignatureInput | CertificateCreateOrConnectWithoutSignatureInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutSignatureInput | CertificateUpsertWithWhereUniqueWithoutSignatureInput[]
    createMany?: CertificateCreateManySignatureInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutSignatureInput | CertificateUpdateWithWhereUniqueWithoutSignatureInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutSignatureInput | CertificateUpdateManyWithWhereWithoutSignatureInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutSignatureNestedInput = {
    create?: XOR<CertificateCreateWithoutSignatureInput, CertificateUncheckedCreateWithoutSignatureInput> | CertificateCreateWithoutSignatureInput[] | CertificateUncheckedCreateWithoutSignatureInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutSignatureInput | CertificateCreateOrConnectWithoutSignatureInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutSignatureInput | CertificateUpsertWithWhereUniqueWithoutSignatureInput[]
    createMany?: CertificateCreateManySignatureInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutSignatureInput | CertificateUpdateWithWhereUniqueWithoutSignatureInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutSignatureInput | CertificateUpdateManyWithWhereWithoutSignatureInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type COTCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<COTCreateWithoutCertificatesInput, COTUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: COTCreateOrConnectWithoutCertificatesInput
    connect?: COTWhereUniqueInput
  }

  export type SignatureCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<SignatureCreateWithoutCertificatesInput, SignatureUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: SignatureCreateOrConnectWithoutCertificatesInput
    connect?: SignatureWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<ParticipantCreateWithoutCertificatesInput, ParticipantUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutCertificatesInput
    connect?: ParticipantWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type COTUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<COTCreateWithoutCertificatesInput, COTUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: COTCreateOrConnectWithoutCertificatesInput
    upsert?: COTUpsertWithoutCertificatesInput
    connect?: COTWhereUniqueInput
    update?: XOR<XOR<COTUpdateToOneWithWhereWithoutCertificatesInput, COTUpdateWithoutCertificatesInput>, COTUncheckedUpdateWithoutCertificatesInput>
  }

  export type SignatureUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<SignatureCreateWithoutCertificatesInput, SignatureUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: SignatureCreateOrConnectWithoutCertificatesInput
    upsert?: SignatureUpsertWithoutCertificatesInput
    connect?: SignatureWhereUniqueInput
    update?: XOR<XOR<SignatureUpdateToOneWithWhereWithoutCertificatesInput, SignatureUpdateWithoutCertificatesInput>, SignatureUncheckedUpdateWithoutCertificatesInput>
  }

  export type ParticipantUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<ParticipantCreateWithoutCertificatesInput, ParticipantUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutCertificatesInput
    upsert?: ParticipantUpsertWithoutCertificatesInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutCertificatesInput, ParticipantUpdateWithoutCertificatesInput>, ParticipantUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutBlacklistedTokensInput = {
    create?: XOR<UserCreateWithoutBlacklistedTokensInput, UserUncheckedCreateWithoutBlacklistedTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlacklistedTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlacklistedTokensNestedInput = {
    create?: XOR<UserCreateWithoutBlacklistedTokensInput, UserUncheckedCreateWithoutBlacklistedTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlacklistedTokensInput
    upsert?: UserUpsertWithoutBlacklistedTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlacklistedTokensInput, UserUpdateWithoutBlacklistedTokensInput>, UserUncheckedUpdateWithoutBlacklistedTokensInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumOAuthProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableFilter<$PrismaModel> | $Enums.OAuthProvider | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OAuthProvider[] | ListEnumOAuthProviderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOAuthProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.OAuthProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumOAuthProviderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSignatureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SignatureType | EnumSignatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSignatureTypeFilter<$PrismaModel> | $Enums.SignatureType
  }

  export type NestedEnumSignatureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SignatureType | EnumSignatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SignatureType[] | ListEnumSignatureTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSignatureTypeWithAggregatesFilter<$PrismaModel> | $Enums.SignatureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSignatureTypeFilter<$PrismaModel>
    _max?: NestedEnumSignatureTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ParticipantCreateWithoutUserInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutUserInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlacklistedTokenCreateWithoutUserInput = {
    id?: string
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type BlacklistedTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type BlacklistedTokenCreateOrConnectWithoutUserInput = {
    where: BlacklistedTokenWhereUniqueInput
    create: XOR<BlacklistedTokenCreateWithoutUserInput, BlacklistedTokenUncheckedCreateWithoutUserInput>
  }

  export type BlacklistedTokenCreateManyUserInputEnvelope = {
    data: BlacklistedTokenCreateManyUserInput | BlacklistedTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantUpsertWithoutUserInput = {
    update: XOR<ParticipantUpdateWithoutUserInput, ParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutUserInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutUserInput, ParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    sessionId?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BlacklistedTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: BlacklistedTokenWhereUniqueInput
    update: XOR<BlacklistedTokenUpdateWithoutUserInput, BlacklistedTokenUncheckedUpdateWithoutUserInput>
    create: XOR<BlacklistedTokenCreateWithoutUserInput, BlacklistedTokenUncheckedCreateWithoutUserInput>
  }

  export type BlacklistedTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: BlacklistedTokenWhereUniqueInput
    data: XOR<BlacklistedTokenUpdateWithoutUserInput, BlacklistedTokenUncheckedUpdateWithoutUserInput>
  }

  export type BlacklistedTokenUpdateManyWithWhereWithoutUserInput = {
    where: BlacklistedTokenScalarWhereInput
    data: XOR<BlacklistedTokenUpdateManyMutationInput, BlacklistedTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type BlacklistedTokenScalarWhereInput = {
    AND?: BlacklistedTokenScalarWhereInput | BlacklistedTokenScalarWhereInput[]
    OR?: BlacklistedTokenScalarWhereInput[]
    NOT?: BlacklistedTokenScalarWhereInput | BlacklistedTokenScalarWhereInput[]
    id?: StringFilter<"BlacklistedToken"> | string
    token?: StringFilter<"BlacklistedToken"> | string
    userId?: StringFilter<"BlacklistedToken"> | string
    createdAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
    expiresAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant?: ParticipantCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    participantId?: string | null
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    idNumber?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    nik?: StringNullableFilter<"User"> | string | null
    dinas?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    hashAlgorithm?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    participantId?: StringNullableFilter<"User"> | string | null
    verifiedAccount?: BoolFilter<"User"> | boolean
    accountVerificationToken?: StringNullableFilter<"User"> | string | null
    verificationSentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    updateEmailToken?: StringNullableFilter<"User"> | string | null
    loginAttempts?: IntFilter<"User"> | number
    lockUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    oauthProvider?: EnumOAuthProviderNullableFilter<"User"> | $Enums.OAuthProvider | null
    oauthId?: StringNullableFilter<"User"> | string | null
    oauthRefreshToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ParticipantCreateWithoutSimAInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutSimAInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutSimAInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutSimAInput, ParticipantUncheckedCreateWithoutSimAInput>
  }

  export type ParticipantCreateWithoutSimBInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutSimBInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutSimBInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutSimBInput, ParticipantUncheckedCreateWithoutSimBInput>
  }

  export type ParticipantCreateWithoutKtpInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutKtpInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutKtpInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutKtpInput, ParticipantUncheckedCreateWithoutKtpInput>
  }

  export type ParticipantCreateWithoutFotoInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutFotoInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutFotoInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutFotoInput, ParticipantUncheckedCreateWithoutFotoInput>
  }

  export type ParticipantCreateWithoutSuratSehatButaWarnaInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutSuratSehatButaWarnaInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutSuratSehatButaWarnaInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutSuratSehatButaWarnaInput, ParticipantUncheckedCreateWithoutSuratSehatButaWarnaInput>
  }

  export type ParticipantCreateWithoutSuratBebasNarkobaInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutSuratBebasNarkobaInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutSuratBebasNarkobaInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutSuratBebasNarkobaInput, ParticipantUncheckedCreateWithoutSuratBebasNarkobaInput>
  }

  export type ParticipantCreateWithoutQrCodeInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutQrCodeInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutQrCodeInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutQrCodeInput, ParticipantUncheckedCreateWithoutQrCodeInput>
  }

  export type SignatureCreateWithoutESignInput = {
    id?: string
    idNumber: string
    role: string
    name: string
    signatureType: $Enums.SignatureType
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateCreateNestedManyWithoutSignatureInput
  }

  export type SignatureUncheckedCreateWithoutESignInput = {
    id?: string
    idNumber: string
    role: string
    name: string
    signatureType: $Enums.SignatureType
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateUncheckedCreateNestedManyWithoutSignatureInput
  }

  export type SignatureCreateOrConnectWithoutESignInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutESignInput, SignatureUncheckedCreateWithoutESignInput>
  }

  export type ParticipantUpsertWithoutSimAInput = {
    update: XOR<ParticipantUpdateWithoutSimAInput, ParticipantUncheckedUpdateWithoutSimAInput>
    create: XOR<ParticipantCreateWithoutSimAInput, ParticipantUncheckedCreateWithoutSimAInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutSimAInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutSimAInput, ParticipantUncheckedUpdateWithoutSimAInput>
  }

  export type ParticipantUpdateWithoutSimAInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutSimAInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUpsertWithoutSimBInput = {
    update: XOR<ParticipantUpdateWithoutSimBInput, ParticipantUncheckedUpdateWithoutSimBInput>
    create: XOR<ParticipantCreateWithoutSimBInput, ParticipantUncheckedCreateWithoutSimBInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutSimBInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutSimBInput, ParticipantUncheckedUpdateWithoutSimBInput>
  }

  export type ParticipantUpdateWithoutSimBInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutSimBInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUpsertWithoutKtpInput = {
    update: XOR<ParticipantUpdateWithoutKtpInput, ParticipantUncheckedUpdateWithoutKtpInput>
    create: XOR<ParticipantCreateWithoutKtpInput, ParticipantUncheckedCreateWithoutKtpInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutKtpInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutKtpInput, ParticipantUncheckedUpdateWithoutKtpInput>
  }

  export type ParticipantUpdateWithoutKtpInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutKtpInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUpsertWithoutFotoInput = {
    update: XOR<ParticipantUpdateWithoutFotoInput, ParticipantUncheckedUpdateWithoutFotoInput>
    create: XOR<ParticipantCreateWithoutFotoInput, ParticipantUncheckedCreateWithoutFotoInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutFotoInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutFotoInput, ParticipantUncheckedUpdateWithoutFotoInput>
  }

  export type ParticipantUpdateWithoutFotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutFotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUpsertWithoutSuratSehatButaWarnaInput = {
    update: XOR<ParticipantUpdateWithoutSuratSehatButaWarnaInput, ParticipantUncheckedUpdateWithoutSuratSehatButaWarnaInput>
    create: XOR<ParticipantCreateWithoutSuratSehatButaWarnaInput, ParticipantUncheckedCreateWithoutSuratSehatButaWarnaInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutSuratSehatButaWarnaInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutSuratSehatButaWarnaInput, ParticipantUncheckedUpdateWithoutSuratSehatButaWarnaInput>
  }

  export type ParticipantUpdateWithoutSuratSehatButaWarnaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutSuratSehatButaWarnaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUpsertWithoutSuratBebasNarkobaInput = {
    update: XOR<ParticipantUpdateWithoutSuratBebasNarkobaInput, ParticipantUncheckedUpdateWithoutSuratBebasNarkobaInput>
    create: XOR<ParticipantCreateWithoutSuratBebasNarkobaInput, ParticipantUncheckedCreateWithoutSuratBebasNarkobaInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutSuratBebasNarkobaInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutSuratBebasNarkobaInput, ParticipantUncheckedUpdateWithoutSuratBebasNarkobaInput>
  }

  export type ParticipantUpdateWithoutSuratBebasNarkobaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutSuratBebasNarkobaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUpsertWithoutQrCodeInput = {
    update: XOR<ParticipantUpdateWithoutQrCodeInput, ParticipantUncheckedUpdateWithoutQrCodeInput>
    create: XOR<ParticipantCreateWithoutQrCodeInput, ParticipantUncheckedCreateWithoutQrCodeInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutQrCodeInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutQrCodeInput, ParticipantUncheckedUpdateWithoutQrCodeInput>
  }

  export type ParticipantUpdateWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutQrCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type SignatureUpsertWithoutESignInput = {
    update: XOR<SignatureUpdateWithoutESignInput, SignatureUncheckedUpdateWithoutESignInput>
    create: XOR<SignatureCreateWithoutESignInput, SignatureUncheckedCreateWithoutESignInput>
    where?: SignatureWhereInput
  }

  export type SignatureUpdateToOneWithWhereWithoutESignInput = {
    where?: SignatureWhereInput
    data: XOR<SignatureUpdateWithoutESignInput, SignatureUncheckedUpdateWithoutESignInput>
  }

  export type SignatureUpdateWithoutESignInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateUpdateManyWithoutSignatureNestedInput
  }

  export type SignatureUncheckedUpdateWithoutESignInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateUncheckedUpdateManyWithoutSignatureNestedInput
  }

  export type FileMetadataCreateWithoutParticipantSimAInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateWithoutParticipantSimAInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataCreateOrConnectWithoutParticipantSimAInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutParticipantSimAInput, FileMetadataUncheckedCreateWithoutParticipantSimAInput>
  }

  export type FileMetadataCreateManyParticipantSimAInputEnvelope = {
    data: FileMetadataCreateManyParticipantSimAInput | FileMetadataCreateManyParticipantSimAInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutParticipantSimBInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateWithoutParticipantSimBInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataCreateOrConnectWithoutParticipantSimBInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutParticipantSimBInput, FileMetadataUncheckedCreateWithoutParticipantSimBInput>
  }

  export type FileMetadataCreateManyParticipantSimBInputEnvelope = {
    data: FileMetadataCreateManyParticipantSimBInput | FileMetadataCreateManyParticipantSimBInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutParticipantKtpInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateWithoutParticipantKtpInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataCreateOrConnectWithoutParticipantKtpInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutParticipantKtpInput, FileMetadataUncheckedCreateWithoutParticipantKtpInput>
  }

  export type FileMetadataCreateManyParticipantKtpInputEnvelope = {
    data: FileMetadataCreateManyParticipantKtpInput | FileMetadataCreateManyParticipantKtpInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutParticipantFotoInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateWithoutParticipantFotoInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataCreateOrConnectWithoutParticipantFotoInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutParticipantFotoInput, FileMetadataUncheckedCreateWithoutParticipantFotoInput>
  }

  export type FileMetadataCreateManyParticipantFotoInputEnvelope = {
    data: FileMetadataCreateManyParticipantFotoInput | FileMetadataCreateManyParticipantFotoInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataCreateOrConnectWithoutParticipantSuratSehatButaWarnaInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput>
  }

  export type FileMetadataCreateManyParticipantSuratSehatButaWarnaInputEnvelope = {
    data: FileMetadataCreateManyParticipantSuratSehatButaWarnaInput | FileMetadataCreateManyParticipantSuratSehatButaWarnaInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantQrCodeId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataCreateOrConnectWithoutParticipantSuratBebasNarkobaInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput>
  }

  export type FileMetadataCreateManyParticipantSuratBebasNarkobaInputEnvelope = {
    data: FileMetadataCreateManyParticipantSuratBebasNarkobaInput | FileMetadataCreateManyParticipantSuratBebasNarkobaInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutParticipantQrCodeInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    signatureESign?: SignatureCreateNestedOneWithoutESignInput
  }

  export type FileMetadataUncheckedCreateWithoutParticipantQrCodeInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    signatureESign?: SignatureUncheckedCreateNestedOneWithoutESignInput
  }

  export type FileMetadataCreateOrConnectWithoutParticipantQrCodeInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutParticipantQrCodeInput, FileMetadataUncheckedCreateWithoutParticipantQrCodeInput>
  }

  export type FileMetadataCreateManyParticipantQrCodeInputEnvelope = {
    data: FileMetadataCreateManyParticipantQrCodeInput | FileMetadataCreateManyParticipantQrCodeInput[]
    skipDuplicates?: boolean
  }

  export type ParticipantsCOTCreateWithoutParticipantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cot: COTCreateNestedOneWithoutParticipantsCotsInput
  }

  export type ParticipantsCOTUncheckedCreateWithoutParticipantInput = {
    id?: string
    cotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipantsCOTCreateOrConnectWithoutParticipantInput = {
    where: ParticipantsCOTWhereUniqueInput
    create: XOR<ParticipantsCOTCreateWithoutParticipantInput, ParticipantsCOTUncheckedCreateWithoutParticipantInput>
  }

  export type ParticipantsCOTCreateManyParticipantInputEnvelope = {
    data: ParticipantsCOTCreateManyParticipantInput | ParticipantsCOTCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutParticipantInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParticipantInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    roleId: string
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
  }

  export type CertificateCreateWithoutParticipantInput = {
    id?: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cot: COTCreateNestedOneWithoutCertificatesInput
    signature: SignatureCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutParticipantInput = {
    id?: string
    cotId: string
    signatureId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutParticipantInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutParticipantInput, CertificateUncheckedCreateWithoutParticipantInput>
  }

  export type CertificateCreateManyParticipantInputEnvelope = {
    data: CertificateCreateManyParticipantInput | CertificateCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutParticipantSimAInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutParticipantSimAInput, FileMetadataUncheckedUpdateWithoutParticipantSimAInput>
    create: XOR<FileMetadataCreateWithoutParticipantSimAInput, FileMetadataUncheckedCreateWithoutParticipantSimAInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutParticipantSimAInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutParticipantSimAInput, FileMetadataUncheckedUpdateWithoutParticipantSimAInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutParticipantSimAInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutParticipantSimAInput>
  }

  export type FileMetadataScalarWhereInput = {
    AND?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
    OR?: FileMetadataScalarWhereInput[]
    NOT?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
    id?: IntFilter<"FileMetadata"> | number
    path?: StringFilter<"FileMetadata"> | string
    fileName?: StringNullableFilter<"FileMetadata"> | string | null
    mimeType?: StringFilter<"FileMetadata"> | string
    fileSize?: IntFilter<"FileMetadata"> | number
    storageType?: StringFilter<"FileMetadata"> | string
    iv?: StringNullableFilter<"FileMetadata"> | string | null
    isSensitive?: BoolFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeFilter<"FileMetadata"> | Date | string
    participantSimAId?: StringNullableFilter<"FileMetadata"> | string | null
    participantSimBId?: StringNullableFilter<"FileMetadata"> | string | null
    participantKtpId?: StringNullableFilter<"FileMetadata"> | string | null
    participantFotoId?: StringNullableFilter<"FileMetadata"> | string | null
    participantSuratSehatButaWarnaId?: StringNullableFilter<"FileMetadata"> | string | null
    participantSuratBebasNarkobaId?: StringNullableFilter<"FileMetadata"> | string | null
    participantQrCodeId?: StringNullableFilter<"FileMetadata"> | string | null
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutParticipantSimBInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutParticipantSimBInput, FileMetadataUncheckedUpdateWithoutParticipantSimBInput>
    create: XOR<FileMetadataCreateWithoutParticipantSimBInput, FileMetadataUncheckedCreateWithoutParticipantSimBInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutParticipantSimBInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutParticipantSimBInput, FileMetadataUncheckedUpdateWithoutParticipantSimBInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutParticipantSimBInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutParticipantSimBInput>
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutParticipantKtpInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutParticipantKtpInput, FileMetadataUncheckedUpdateWithoutParticipantKtpInput>
    create: XOR<FileMetadataCreateWithoutParticipantKtpInput, FileMetadataUncheckedCreateWithoutParticipantKtpInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutParticipantKtpInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutParticipantKtpInput, FileMetadataUncheckedUpdateWithoutParticipantKtpInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutParticipantKtpInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutParticipantKtpInput>
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutParticipantFotoInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutParticipantFotoInput, FileMetadataUncheckedUpdateWithoutParticipantFotoInput>
    create: XOR<FileMetadataCreateWithoutParticipantFotoInput, FileMetadataUncheckedCreateWithoutParticipantFotoInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutParticipantFotoInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutParticipantFotoInput, FileMetadataUncheckedUpdateWithoutParticipantFotoInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutParticipantFotoInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutParticipantFotoInput>
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedUpdateWithoutParticipantSuratSehatButaWarnaInput>
    create: XOR<FileMetadataCreateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedCreateWithoutParticipantSuratSehatButaWarnaInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratSehatButaWarnaInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutParticipantSuratSehatButaWarnaInput, FileMetadataUncheckedUpdateWithoutParticipantSuratSehatButaWarnaInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutParticipantSuratSehatButaWarnaInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaInput>
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedUpdateWithoutParticipantSuratBebasNarkobaInput>
    create: XOR<FileMetadataCreateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedCreateWithoutParticipantSuratBebasNarkobaInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutParticipantSuratBebasNarkobaInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutParticipantSuratBebasNarkobaInput, FileMetadataUncheckedUpdateWithoutParticipantSuratBebasNarkobaInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutParticipantSuratBebasNarkobaInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaInput>
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutParticipantQrCodeInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutParticipantQrCodeInput, FileMetadataUncheckedUpdateWithoutParticipantQrCodeInput>
    create: XOR<FileMetadataCreateWithoutParticipantQrCodeInput, FileMetadataUncheckedCreateWithoutParticipantQrCodeInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutParticipantQrCodeInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutParticipantQrCodeInput, FileMetadataUncheckedUpdateWithoutParticipantQrCodeInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutParticipantQrCodeInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeInput>
  }

  export type ParticipantsCOTUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ParticipantsCOTWhereUniqueInput
    update: XOR<ParticipantsCOTUpdateWithoutParticipantInput, ParticipantsCOTUncheckedUpdateWithoutParticipantInput>
    create: XOR<ParticipantsCOTCreateWithoutParticipantInput, ParticipantsCOTUncheckedCreateWithoutParticipantInput>
  }

  export type ParticipantsCOTUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ParticipantsCOTWhereUniqueInput
    data: XOR<ParticipantsCOTUpdateWithoutParticipantInput, ParticipantsCOTUncheckedUpdateWithoutParticipantInput>
  }

  export type ParticipantsCOTUpdateManyWithWhereWithoutParticipantInput = {
    where: ParticipantsCOTScalarWhereInput
    data: XOR<ParticipantsCOTUpdateManyMutationInput, ParticipantsCOTUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ParticipantsCOTScalarWhereInput = {
    AND?: ParticipantsCOTScalarWhereInput | ParticipantsCOTScalarWhereInput[]
    OR?: ParticipantsCOTScalarWhereInput[]
    NOT?: ParticipantsCOTScalarWhereInput | ParticipantsCOTScalarWhereInput[]
    id?: StringFilter<"ParticipantsCOT"> | string
    participantId?: StringNullableFilter<"ParticipantsCOT"> | string | null
    cotId?: StringFilter<"ParticipantsCOT"> | string
    createdAt?: DateTimeFilter<"ParticipantsCOT"> | Date | string
    updatedAt?: DateTimeFilter<"ParticipantsCOT"> | Date | string
  }

  export type UserUpsertWithoutParticipantInput = {
    update: XOR<UserUpdateWithoutParticipantInput, UserUncheckedUpdateWithoutParticipantInput>
    create: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParticipantInput, UserUncheckedUpdateWithoutParticipantInput>
  }

  export type UserUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CertificateUpsertWithWhereUniqueWithoutParticipantInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutParticipantInput, CertificateUncheckedUpdateWithoutParticipantInput>
    create: XOR<CertificateCreateWithoutParticipantInput, CertificateUncheckedCreateWithoutParticipantInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutParticipantInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutParticipantInput, CertificateUncheckedUpdateWithoutParticipantInput>
  }

  export type CertificateUpdateManyWithWhereWithoutParticipantInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutParticipantInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    cotId?: StringFilter<"Certificate"> | string
    signatureId?: StringFilter<"Certificate"> | string
    participantId?: StringFilter<"Certificate"> | string
    issuedDate?: DateTimeFilter<"Certificate"> | Date | string
    certificateNumber?: StringFilter<"Certificate"> | string
    attendance?: BoolFilter<"Certificate"> | boolean
    theoryScore?: FloatFilter<"Certificate"> | number
    practiceScore?: FloatFilter<"Certificate"> | number
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type CurriculumSyllabusCreateWithoutCapabilityInput = {
    id?: string
    name: string
    theoryDuration: number
    practiceDuration: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumSyllabusUncheckedCreateWithoutCapabilityInput = {
    id?: string
    name: string
    theoryDuration: number
    practiceDuration: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumSyllabusCreateOrConnectWithoutCapabilityInput = {
    where: CurriculumSyllabusWhereUniqueInput
    create: XOR<CurriculumSyllabusCreateWithoutCapabilityInput, CurriculumSyllabusUncheckedCreateWithoutCapabilityInput>
  }

  export type CurriculumSyllabusCreateManyCapabilityInputEnvelope = {
    data: CurriculumSyllabusCreateManyCapabilityInput | CurriculumSyllabusCreateManyCapabilityInput[]
    skipDuplicates?: boolean
  }

  export type CapabilityCOTCreateWithoutCapabilityInput = {
    cot: COTCreateNestedOneWithoutCapabilityCotsInput
  }

  export type CapabilityCOTUncheckedCreateWithoutCapabilityInput = {
    cotId: string
  }

  export type CapabilityCOTCreateOrConnectWithoutCapabilityInput = {
    where: CapabilityCOTWhereUniqueInput
    create: XOR<CapabilityCOTCreateWithoutCapabilityInput, CapabilityCOTUncheckedCreateWithoutCapabilityInput>
  }

  export type CapabilityCOTCreateManyCapabilityInputEnvelope = {
    data: CapabilityCOTCreateManyCapabilityInput | CapabilityCOTCreateManyCapabilityInput[]
    skipDuplicates?: boolean
  }

  export type CurriculumSyllabusUpsertWithWhereUniqueWithoutCapabilityInput = {
    where: CurriculumSyllabusWhereUniqueInput
    update: XOR<CurriculumSyllabusUpdateWithoutCapabilityInput, CurriculumSyllabusUncheckedUpdateWithoutCapabilityInput>
    create: XOR<CurriculumSyllabusCreateWithoutCapabilityInput, CurriculumSyllabusUncheckedCreateWithoutCapabilityInput>
  }

  export type CurriculumSyllabusUpdateWithWhereUniqueWithoutCapabilityInput = {
    where: CurriculumSyllabusWhereUniqueInput
    data: XOR<CurriculumSyllabusUpdateWithoutCapabilityInput, CurriculumSyllabusUncheckedUpdateWithoutCapabilityInput>
  }

  export type CurriculumSyllabusUpdateManyWithWhereWithoutCapabilityInput = {
    where: CurriculumSyllabusScalarWhereInput
    data: XOR<CurriculumSyllabusUpdateManyMutationInput, CurriculumSyllabusUncheckedUpdateManyWithoutCapabilityInput>
  }

  export type CurriculumSyllabusScalarWhereInput = {
    AND?: CurriculumSyllabusScalarWhereInput | CurriculumSyllabusScalarWhereInput[]
    OR?: CurriculumSyllabusScalarWhereInput[]
    NOT?: CurriculumSyllabusScalarWhereInput | CurriculumSyllabusScalarWhereInput[]
    id?: StringFilter<"CurriculumSyllabus"> | string
    capabilityId?: StringFilter<"CurriculumSyllabus"> | string
    name?: StringFilter<"CurriculumSyllabus"> | string
    theoryDuration?: IntFilter<"CurriculumSyllabus"> | number
    practiceDuration?: IntFilter<"CurriculumSyllabus"> | number
    type?: StringFilter<"CurriculumSyllabus"> | string
    createdAt?: DateTimeFilter<"CurriculumSyllabus"> | Date | string
    updatedAt?: DateTimeFilter<"CurriculumSyllabus"> | Date | string
  }

  export type CapabilityCOTUpsertWithWhereUniqueWithoutCapabilityInput = {
    where: CapabilityCOTWhereUniqueInput
    update: XOR<CapabilityCOTUpdateWithoutCapabilityInput, CapabilityCOTUncheckedUpdateWithoutCapabilityInput>
    create: XOR<CapabilityCOTCreateWithoutCapabilityInput, CapabilityCOTUncheckedCreateWithoutCapabilityInput>
  }

  export type CapabilityCOTUpdateWithWhereUniqueWithoutCapabilityInput = {
    where: CapabilityCOTWhereUniqueInput
    data: XOR<CapabilityCOTUpdateWithoutCapabilityInput, CapabilityCOTUncheckedUpdateWithoutCapabilityInput>
  }

  export type CapabilityCOTUpdateManyWithWhereWithoutCapabilityInput = {
    where: CapabilityCOTScalarWhereInput
    data: XOR<CapabilityCOTUpdateManyMutationInput, CapabilityCOTUncheckedUpdateManyWithoutCapabilityInput>
  }

  export type CapabilityCOTScalarWhereInput = {
    AND?: CapabilityCOTScalarWhereInput | CapabilityCOTScalarWhereInput[]
    OR?: CapabilityCOTScalarWhereInput[]
    NOT?: CapabilityCOTScalarWhereInput | CapabilityCOTScalarWhereInput[]
    capabilityId?: StringFilter<"CapabilityCOT"> | string
    cotId?: StringFilter<"CapabilityCOT"> | string
  }

  export type CapabilityCreateWithoutCurriculumSyllabusInput = {
    id?: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse?: number | null
    totalPracticeDurationRegGse?: number | null
    totalTheoryDurationCompetency?: number | null
    totalPracticeDurationCompetency?: number | null
    totalDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUncheckedCreateWithoutCurriculumSyllabusInput = {
    id?: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse?: number | null
    totalPracticeDurationRegGse?: number | null
    totalTheoryDurationCompetency?: number | null
    totalPracticeDurationCompetency?: number | null
    totalDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityCreateOrConnectWithoutCurriculumSyllabusInput = {
    where: CapabilityWhereUniqueInput
    create: XOR<CapabilityCreateWithoutCurriculumSyllabusInput, CapabilityUncheckedCreateWithoutCurriculumSyllabusInput>
  }

  export type CapabilityUpsertWithoutCurriculumSyllabusInput = {
    update: XOR<CapabilityUpdateWithoutCurriculumSyllabusInput, CapabilityUncheckedUpdateWithoutCurriculumSyllabusInput>
    create: XOR<CapabilityCreateWithoutCurriculumSyllabusInput, CapabilityUncheckedCreateWithoutCurriculumSyllabusInput>
    where?: CapabilityWhereInput
  }

  export type CapabilityUpdateToOneWithWhereWithoutCurriculumSyllabusInput = {
    where?: CapabilityWhereInput
    data: XOR<CapabilityUpdateWithoutCurriculumSyllabusInput, CapabilityUncheckedUpdateWithoutCurriculumSyllabusInput>
  }

  export type CapabilityUpdateWithoutCurriculumSyllabusInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityUncheckedUpdateWithoutCurriculumSyllabusInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityCOTCreateWithoutCotInput = {
    capability: CapabilityCreateNestedOneWithoutCapabilityCotsInput
  }

  export type CapabilityCOTUncheckedCreateWithoutCotInput = {
    capabilityId: string
  }

  export type CapabilityCOTCreateOrConnectWithoutCotInput = {
    where: CapabilityCOTWhereUniqueInput
    create: XOR<CapabilityCOTCreateWithoutCotInput, CapabilityCOTUncheckedCreateWithoutCotInput>
  }

  export type CapabilityCOTCreateManyCotInputEnvelope = {
    data: CapabilityCOTCreateManyCotInput | CapabilityCOTCreateManyCotInput[]
    skipDuplicates?: boolean
  }

  export type ParticipantsCOTCreateWithoutCotInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant?: ParticipantCreateNestedOneWithoutParticipantsCotsInput
  }

  export type ParticipantsCOTUncheckedCreateWithoutCotInput = {
    id?: string
    participantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipantsCOTCreateOrConnectWithoutCotInput = {
    where: ParticipantsCOTWhereUniqueInput
    create: XOR<ParticipantsCOTCreateWithoutCotInput, ParticipantsCOTUncheckedCreateWithoutCotInput>
  }

  export type ParticipantsCOTCreateManyCotInputEnvelope = {
    data: ParticipantsCOTCreateManyCotInput | ParticipantsCOTCreateManyCotInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutCotInput = {
    id?: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    signature: SignatureCreateNestedOneWithoutCertificatesInput
    participant: ParticipantCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutCotInput = {
    id?: string
    signatureId: string
    participantId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutCotInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutCotInput, CertificateUncheckedCreateWithoutCotInput>
  }

  export type CertificateCreateManyCotInputEnvelope = {
    data: CertificateCreateManyCotInput | CertificateCreateManyCotInput[]
    skipDuplicates?: boolean
  }

  export type CapabilityCOTUpsertWithWhereUniqueWithoutCotInput = {
    where: CapabilityCOTWhereUniqueInput
    update: XOR<CapabilityCOTUpdateWithoutCotInput, CapabilityCOTUncheckedUpdateWithoutCotInput>
    create: XOR<CapabilityCOTCreateWithoutCotInput, CapabilityCOTUncheckedCreateWithoutCotInput>
  }

  export type CapabilityCOTUpdateWithWhereUniqueWithoutCotInput = {
    where: CapabilityCOTWhereUniqueInput
    data: XOR<CapabilityCOTUpdateWithoutCotInput, CapabilityCOTUncheckedUpdateWithoutCotInput>
  }

  export type CapabilityCOTUpdateManyWithWhereWithoutCotInput = {
    where: CapabilityCOTScalarWhereInput
    data: XOR<CapabilityCOTUpdateManyMutationInput, CapabilityCOTUncheckedUpdateManyWithoutCotInput>
  }

  export type ParticipantsCOTUpsertWithWhereUniqueWithoutCotInput = {
    where: ParticipantsCOTWhereUniqueInput
    update: XOR<ParticipantsCOTUpdateWithoutCotInput, ParticipantsCOTUncheckedUpdateWithoutCotInput>
    create: XOR<ParticipantsCOTCreateWithoutCotInput, ParticipantsCOTUncheckedCreateWithoutCotInput>
  }

  export type ParticipantsCOTUpdateWithWhereUniqueWithoutCotInput = {
    where: ParticipantsCOTWhereUniqueInput
    data: XOR<ParticipantsCOTUpdateWithoutCotInput, ParticipantsCOTUncheckedUpdateWithoutCotInput>
  }

  export type ParticipantsCOTUpdateManyWithWhereWithoutCotInput = {
    where: ParticipantsCOTScalarWhereInput
    data: XOR<ParticipantsCOTUpdateManyMutationInput, ParticipantsCOTUncheckedUpdateManyWithoutCotInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutCotInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutCotInput, CertificateUncheckedUpdateWithoutCotInput>
    create: XOR<CertificateCreateWithoutCotInput, CertificateUncheckedCreateWithoutCotInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutCotInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutCotInput, CertificateUncheckedUpdateWithoutCotInput>
  }

  export type CertificateUpdateManyWithWhereWithoutCotInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutCotInput>
  }

  export type CapabilityCreateWithoutCapabilityCotsInput = {
    id?: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse?: number | null
    totalPracticeDurationRegGse?: number | null
    totalTheoryDurationCompetency?: number | null
    totalPracticeDurationCompetency?: number | null
    totalDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    curriculumSyllabus?: CurriculumSyllabusCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityUncheckedCreateWithoutCapabilityCotsInput = {
    id?: string
    ratingCode: string
    trainingCode: string
    trainingName: string
    totalTheoryDurationRegGse?: number | null
    totalPracticeDurationRegGse?: number | null
    totalTheoryDurationCompetency?: number | null
    totalPracticeDurationCompetency?: number | null
    totalDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    curriculumSyllabus?: CurriculumSyllabusUncheckedCreateNestedManyWithoutCapabilityInput
  }

  export type CapabilityCreateOrConnectWithoutCapabilityCotsInput = {
    where: CapabilityWhereUniqueInput
    create: XOR<CapabilityCreateWithoutCapabilityCotsInput, CapabilityUncheckedCreateWithoutCapabilityCotsInput>
  }

  export type COTCreateWithoutCapabilityCotsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutCotInput
    certificates?: CertificateCreateNestedManyWithoutCotInput
  }

  export type COTUncheckedCreateWithoutCapabilityCotsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutCotInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCotInput
  }

  export type COTCreateOrConnectWithoutCapabilityCotsInput = {
    where: COTWhereUniqueInput
    create: XOR<COTCreateWithoutCapabilityCotsInput, COTUncheckedCreateWithoutCapabilityCotsInput>
  }

  export type CapabilityUpsertWithoutCapabilityCotsInput = {
    update: XOR<CapabilityUpdateWithoutCapabilityCotsInput, CapabilityUncheckedUpdateWithoutCapabilityCotsInput>
    create: XOR<CapabilityCreateWithoutCapabilityCotsInput, CapabilityUncheckedCreateWithoutCapabilityCotsInput>
    where?: CapabilityWhereInput
  }

  export type CapabilityUpdateToOneWithWhereWithoutCapabilityCotsInput = {
    where?: CapabilityWhereInput
    data: XOR<CapabilityUpdateWithoutCapabilityCotsInput, CapabilityUncheckedUpdateWithoutCapabilityCotsInput>
  }

  export type CapabilityUpdateWithoutCapabilityCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    curriculumSyllabus?: CurriculumSyllabusUpdateManyWithoutCapabilityNestedInput
  }

  export type CapabilityUncheckedUpdateWithoutCapabilityCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratingCode?: StringFieldUpdateOperationsInput | string
    trainingCode?: StringFieldUpdateOperationsInput | string
    trainingName?: StringFieldUpdateOperationsInput | string
    totalTheoryDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationRegGse?: NullableIntFieldUpdateOperationsInput | number | null
    totalTheoryDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalPracticeDurationCompetency?: NullableIntFieldUpdateOperationsInput | number | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    curriculumSyllabus?: CurriculumSyllabusUncheckedUpdateManyWithoutCapabilityNestedInput
  }

  export type COTUpsertWithoutCapabilityCotsInput = {
    update: XOR<COTUpdateWithoutCapabilityCotsInput, COTUncheckedUpdateWithoutCapabilityCotsInput>
    create: XOR<COTCreateWithoutCapabilityCotsInput, COTUncheckedCreateWithoutCapabilityCotsInput>
    where?: COTWhereInput
  }

  export type COTUpdateToOneWithWhereWithoutCapabilityCotsInput = {
    where?: COTWhereInput
    data: XOR<COTUpdateWithoutCapabilityCotsInput, COTUncheckedUpdateWithoutCapabilityCotsInput>
  }

  export type COTUpdateWithoutCapabilityCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsCots?: ParticipantsCOTUpdateManyWithoutCotNestedInput
    certificates?: CertificateUpdateManyWithoutCotNestedInput
  }

  export type COTUncheckedUpdateWithoutCapabilityCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutCotNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCotNestedInput
  }

  export type ParticipantCreateWithoutParticipantsCotsInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    user?: UserCreateNestedOneWithoutParticipantInput
    certificates?: CertificateCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutParticipantsCotsInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutParticipantsCotsInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutParticipantsCotsInput, ParticipantUncheckedCreateWithoutParticipantsCotsInput>
  }

  export type COTCreateWithoutParticipantsCotsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTCreateNestedManyWithoutCotInput
    certificates?: CertificateCreateNestedManyWithoutCotInput
  }

  export type COTUncheckedCreateWithoutParticipantsCotsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTUncheckedCreateNestedManyWithoutCotInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCotInput
  }

  export type COTCreateOrConnectWithoutParticipantsCotsInput = {
    where: COTWhereUniqueInput
    create: XOR<COTCreateWithoutParticipantsCotsInput, COTUncheckedCreateWithoutParticipantsCotsInput>
  }

  export type ParticipantUpsertWithoutParticipantsCotsInput = {
    update: XOR<ParticipantUpdateWithoutParticipantsCotsInput, ParticipantUncheckedUpdateWithoutParticipantsCotsInput>
    create: XOR<ParticipantCreateWithoutParticipantsCotsInput, ParticipantUncheckedCreateWithoutParticipantsCotsInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutParticipantsCotsInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutParticipantsCotsInput, ParticipantUncheckedUpdateWithoutParticipantsCotsInput>
  }

  export type ParticipantUpdateWithoutParticipantsCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutParticipantsCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type COTUpsertWithoutParticipantsCotsInput = {
    update: XOR<COTUpdateWithoutParticipantsCotsInput, COTUncheckedUpdateWithoutParticipantsCotsInput>
    create: XOR<COTCreateWithoutParticipantsCotsInput, COTUncheckedCreateWithoutParticipantsCotsInput>
    where?: COTWhereInput
  }

  export type COTUpdateToOneWithWhereWithoutParticipantsCotsInput = {
    where?: COTWhereInput
    data: XOR<COTUpdateWithoutParticipantsCotsInput, COTUncheckedUpdateWithoutParticipantsCotsInput>
  }

  export type COTUpdateWithoutParticipantsCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUpdateManyWithoutCotNestedInput
    certificates?: CertificateUpdateManyWithoutCotNestedInput
  }

  export type COTUncheckedUpdateWithoutParticipantsCotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUncheckedUpdateManyWithoutCotNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCotNestedInput
  }

  export type FileMetadataCreateWithoutSignatureESignInput = {
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimA?: ParticipantCreateNestedOneWithoutSimAInput
    participantSimB?: ParticipantCreateNestedOneWithoutSimBInput
    participantKtp?: ParticipantCreateNestedOneWithoutKtpInput
    participantFoto?: ParticipantCreateNestedOneWithoutFotoInput
    participantSuratSehatButaWarna?: ParticipantCreateNestedOneWithoutSuratSehatButaWarnaInput
    participantSuratBebasNarkoba?: ParticipantCreateNestedOneWithoutSuratBebasNarkobaInput
    participantQrCode?: ParticipantCreateNestedOneWithoutQrCodeInput
  }

  export type FileMetadataUncheckedCreateWithoutSignatureESignInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataCreateOrConnectWithoutSignatureESignInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutSignatureESignInput, FileMetadataUncheckedCreateWithoutSignatureESignInput>
  }

  export type CertificateCreateWithoutSignatureInput = {
    id?: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cot: COTCreateNestedOneWithoutCertificatesInput
    participant: ParticipantCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutSignatureInput = {
    id?: string
    cotId: string
    participantId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutSignatureInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutSignatureInput, CertificateUncheckedCreateWithoutSignatureInput>
  }

  export type CertificateCreateManySignatureInputEnvelope = {
    data: CertificateCreateManySignatureInput | CertificateCreateManySignatureInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataUpsertWithoutSignatureESignInput = {
    update: XOR<FileMetadataUpdateWithoutSignatureESignInput, FileMetadataUncheckedUpdateWithoutSignatureESignInput>
    create: XOR<FileMetadataCreateWithoutSignatureESignInput, FileMetadataUncheckedCreateWithoutSignatureESignInput>
    where?: FileMetadataWhereInput
  }

  export type FileMetadataUpdateToOneWithWhereWithoutSignatureESignInput = {
    where?: FileMetadataWhereInput
    data: XOR<FileMetadataUpdateWithoutSignatureESignInput, FileMetadataUncheckedUpdateWithoutSignatureESignInput>
  }

  export type FileMetadataUpdateWithoutSignatureESignInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutSignatureESignInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUpsertWithWhereUniqueWithoutSignatureInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutSignatureInput, CertificateUncheckedUpdateWithoutSignatureInput>
    create: XOR<CertificateCreateWithoutSignatureInput, CertificateUncheckedCreateWithoutSignatureInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutSignatureInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutSignatureInput, CertificateUncheckedUpdateWithoutSignatureInput>
  }

  export type CertificateUpdateManyWithWhereWithoutSignatureInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutSignatureInput>
  }

  export type COTCreateWithoutCertificatesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTCreateNestedManyWithoutCotInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutCotInput
  }

  export type COTUncheckedCreateWithoutCertificatesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    trainingLocation: string
    theoryInstructorRegGse: string
    theoryInstructorCompetency: string
    practicalInstructor1: string
    practicalInstructor2: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilityCots?: CapabilityCOTUncheckedCreateNestedManyWithoutCotInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutCotInput
  }

  export type COTCreateOrConnectWithoutCertificatesInput = {
    where: COTWhereUniqueInput
    create: XOR<COTCreateWithoutCertificatesInput, COTUncheckedCreateWithoutCertificatesInput>
  }

  export type SignatureCreateWithoutCertificatesInput = {
    id?: string
    idNumber: string
    role: string
    name: string
    signatureType: $Enums.SignatureType
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eSign?: FileMetadataCreateNestedOneWithoutSignatureESignInput
  }

  export type SignatureUncheckedCreateWithoutCertificatesInput = {
    id?: string
    idNumber: string
    role: string
    name: string
    eSignId?: number | null
    signatureType: $Enums.SignatureType
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignatureCreateOrConnectWithoutCertificatesInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutCertificatesInput, SignatureUncheckedCreateWithoutCertificatesInput>
  }

  export type ParticipantCreateWithoutCertificatesInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTCreateNestedManyWithoutParticipantInput
    user?: UserCreateNestedOneWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutCertificatesInput = {
    id?: string
    idNumber?: string | null
    name: string
    nik: string
    dinas?: string | null
    bidang?: string | null
    company?: string | null
    email: string
    phoneNumber?: string | null
    nationality?: string | null
    placeOfBirth?: string | null
    dateOfBirth?: Date | string | null
    qrCodeLink?: string | null
    tglKeluarSuratSehatButaWarna?: Date | string | null
    tglKeluarSuratBebasNarkoba?: Date | string | null
    gmfNonGmf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    simA?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimAInput
    simB?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSimBInput
    ktp?: FileMetadataUncheckedCreateNestedManyWithoutParticipantKtpInput
    foto?: FileMetadataUncheckedCreateNestedManyWithoutParticipantFotoInput
    suratSehatButaWarna?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratSehatButaWarnaInput
    suratBebasNarkoba?: FileMetadataUncheckedCreateNestedManyWithoutParticipantSuratBebasNarkobaInput
    qrCode?: FileMetadataUncheckedCreateNestedManyWithoutParticipantQrCodeInput
    participantsCots?: ParticipantsCOTUncheckedCreateNestedManyWithoutParticipantInput
    user?: UserUncheckedCreateNestedOneWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutCertificatesInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutCertificatesInput, ParticipantUncheckedCreateWithoutCertificatesInput>
  }

  export type COTUpsertWithoutCertificatesInput = {
    update: XOR<COTUpdateWithoutCertificatesInput, COTUncheckedUpdateWithoutCertificatesInput>
    create: XOR<COTCreateWithoutCertificatesInput, COTUncheckedCreateWithoutCertificatesInput>
    where?: COTWhereInput
  }

  export type COTUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: COTWhereInput
    data: XOR<COTUpdateWithoutCertificatesInput, COTUncheckedUpdateWithoutCertificatesInput>
  }

  export type COTUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUpdateManyWithoutCotNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutCotNestedInput
  }

  export type COTUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingLocation?: StringFieldUpdateOperationsInput | string
    theoryInstructorRegGse?: StringFieldUpdateOperationsInput | string
    theoryInstructorCompetency?: StringFieldUpdateOperationsInput | string
    practicalInstructor1?: StringFieldUpdateOperationsInput | string
    practicalInstructor2?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilityCots?: CapabilityCOTUncheckedUpdateManyWithoutCotNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutCotNestedInput
  }

  export type SignatureUpsertWithoutCertificatesInput = {
    update: XOR<SignatureUpdateWithoutCertificatesInput, SignatureUncheckedUpdateWithoutCertificatesInput>
    create: XOR<SignatureCreateWithoutCertificatesInput, SignatureUncheckedCreateWithoutCertificatesInput>
    where?: SignatureWhereInput
  }

  export type SignatureUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: SignatureWhereInput
    data: XOR<SignatureUpdateWithoutCertificatesInput, SignatureUncheckedUpdateWithoutCertificatesInput>
  }

  export type SignatureUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eSign?: FileMetadataUpdateOneWithoutSignatureESignNestedInput
  }

  export type SignatureUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    eSignId?: NullableIntFieldUpdateOperationsInput | number | null
    signatureType?: EnumSignatureTypeFieldUpdateOperationsInput | $Enums.SignatureType
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantUpsertWithoutCertificatesInput = {
    update: XOR<ParticipantUpdateWithoutCertificatesInput, ParticipantUncheckedUpdateWithoutCertificatesInput>
    create: XOR<ParticipantCreateWithoutCertificatesInput, ParticipantUncheckedCreateWithoutCertificatesInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutCertificatesInput, ParticipantUncheckedUpdateWithoutCertificatesInput>
  }

  export type ParticipantUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUpdateManyWithoutParticipantNestedInput
    user?: UserUpdateOneWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: StringFieldUpdateOperationsInput | string
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    bidang?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    placeOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeLink?: NullableStringFieldUpdateOperationsInput | string | null
    tglKeluarSuratSehatButaWarna?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tglKeluarSuratBebasNarkoba?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gmfNonGmf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simA?: FileMetadataUncheckedUpdateManyWithoutParticipantSimANestedInput
    simB?: FileMetadataUncheckedUpdateManyWithoutParticipantSimBNestedInput
    ktp?: FileMetadataUncheckedUpdateManyWithoutParticipantKtpNestedInput
    foto?: FileMetadataUncheckedUpdateManyWithoutParticipantFotoNestedInput
    suratSehatButaWarna?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaNestedInput
    suratBebasNarkoba?: FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaNestedInput
    qrCode?: FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeNestedInput
    participantsCots?: ParticipantsCOTUncheckedUpdateManyWithoutParticipantNestedInput
    user?: UserUncheckedUpdateOneWithoutParticipantNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    roleId: string
    participantId?: string | null
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBlacklistedTokensInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlacklistedTokensInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    roleId: string
    participantId?: string | null
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlacklistedTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlacklistedTokensInput, UserUncheckedCreateWithoutBlacklistedTokensInput>
  }

  export type UserUpsertWithoutBlacklistedTokensInput = {
    update: XOR<UserUpdateWithoutBlacklistedTokensInput, UserUncheckedUpdateWithoutBlacklistedTokensInput>
    create: XOR<UserCreateWithoutBlacklistedTokensInput, UserUncheckedCreateWithoutBlacklistedTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlacklistedTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlacklistedTokensInput, UserUncheckedUpdateWithoutBlacklistedTokensInput>
  }

  export type UserUpdateWithoutBlacklistedTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlacklistedTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    roleId: string
    participantId?: string | null
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    blacklistedTokens?: BlacklistedTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    sessionId?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type BlacklistedTokenCreateManyUserInput = {
    id?: string
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    idNumber?: string | null
    name: string
    nik?: string | null
    dinas?: string | null
    password?: string | null
    photo?: string | null
    hashAlgorithm?: string
    participantId?: string | null
    verifiedAccount?: boolean
    accountVerificationToken?: string | null
    verificationSentAt?: Date | string | null
    passwordResetToken?: string | null
    updateEmailToken?: string | null
    loginAttempts?: number
    lockUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    oauthProvider?: $Enums.OAuthProvider | null
    oauthId?: string | null
    oauthRefreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    blacklistedTokens?: BlacklistedTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    dinas?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    hashAlgorithm?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAccount?: BoolFieldUpdateOperationsInput | boolean
    accountVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    updateEmailToken?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableEnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    oauthRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMetadataCreateManyParticipantSimAInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataCreateManyParticipantSimBInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataCreateManyParticipantKtpInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataCreateManyParticipantFotoInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataCreateManyParticipantSuratSehatButaWarnaInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratBebasNarkobaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataCreateManyParticipantSuratBebasNarkobaInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantQrCodeId?: string | null
  }

  export type FileMetadataCreateManyParticipantQrCodeInput = {
    id?: number
    path: string
    fileName?: string | null
    mimeType: string
    fileSize: number
    storageType: string
    iv?: string | null
    isSensitive?: boolean
    createdAt?: Date | string
    participantSimAId?: string | null
    participantSimBId?: string | null
    participantKtpId?: string | null
    participantFotoId?: string | null
    participantSuratSehatButaWarnaId?: string | null
    participantSuratBebasNarkobaId?: string | null
  }

  export type ParticipantsCOTCreateManyParticipantInput = {
    id?: string
    cotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateManyParticipantInput = {
    id?: string
    cotId: string
    signatureId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileMetadataUpdateWithoutParticipantSimAInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutParticipantSimAInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSimAInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileMetadataUpdateWithoutParticipantSimBInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutParticipantSimBInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSimBInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileMetadataUpdateWithoutParticipantKtpInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutParticipantKtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantKtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileMetadataUpdateWithoutParticipantFotoInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutParticipantFotoInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantFotoInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileMetadataUpdateWithoutParticipantSuratSehatButaWarnaInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutParticipantSuratSehatButaWarnaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSuratSehatButaWarnaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileMetadataUpdateWithoutParticipantSuratBebasNarkobaInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantQrCode?: ParticipantUpdateOneWithoutQrCodeNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutParticipantSuratBebasNarkobaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantSuratBebasNarkobaInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantQrCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileMetadataUpdateWithoutParticipantQrCodeInput = {
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimA?: ParticipantUpdateOneWithoutSimANestedInput
    participantSimB?: ParticipantUpdateOneWithoutSimBNestedInput
    participantKtp?: ParticipantUpdateOneWithoutKtpNestedInput
    participantFoto?: ParticipantUpdateOneWithoutFotoNestedInput
    participantSuratSehatButaWarna?: ParticipantUpdateOneWithoutSuratSehatButaWarnaNestedInput
    participantSuratBebasNarkoba?: ParticipantUpdateOneWithoutSuratBebasNarkobaNestedInput
    signatureESign?: SignatureUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutParticipantQrCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureESign?: SignatureUncheckedUpdateOneWithoutESignNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutParticipantQrCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storageType?: StringFieldUpdateOperationsInput | string
    iv?: NullableStringFieldUpdateOperationsInput | string | null
    isSensitive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantSimAId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSimBId?: NullableStringFieldUpdateOperationsInput | string | null
    participantKtpId?: NullableStringFieldUpdateOperationsInput | string | null
    participantFotoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratSehatButaWarnaId?: NullableStringFieldUpdateOperationsInput | string | null
    participantSuratBebasNarkobaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParticipantsCOTUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cot?: COTUpdateOneRequiredWithoutParticipantsCotsNestedInput
  }

  export type ParticipantsCOTUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantsCOTUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cot?: COTUpdateOneRequiredWithoutCertificatesNestedInput
    signature?: SignatureUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    signatureId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    signatureId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumSyllabusCreateManyCapabilityInput = {
    id?: string
    name: string
    theoryDuration: number
    practiceDuration: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapabilityCOTCreateManyCapabilityInput = {
    cotId: string
  }

  export type CurriculumSyllabusUpdateWithoutCapabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    theoryDuration?: IntFieldUpdateOperationsInput | number
    practiceDuration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumSyllabusUncheckedUpdateWithoutCapabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    theoryDuration?: IntFieldUpdateOperationsInput | number
    practiceDuration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumSyllabusUncheckedUpdateManyWithoutCapabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    theoryDuration?: IntFieldUpdateOperationsInput | number
    practiceDuration?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapabilityCOTUpdateWithoutCapabilityInput = {
    cot?: COTUpdateOneRequiredWithoutCapabilityCotsNestedInput
  }

  export type CapabilityCOTUncheckedUpdateWithoutCapabilityInput = {
    cotId?: StringFieldUpdateOperationsInput | string
  }

  export type CapabilityCOTUncheckedUpdateManyWithoutCapabilityInput = {
    cotId?: StringFieldUpdateOperationsInput | string
  }

  export type CapabilityCOTCreateManyCotInput = {
    capabilityId: string
  }

  export type ParticipantsCOTCreateManyCotInput = {
    id?: string
    participantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateManyCotInput = {
    id?: string
    signatureId: string
    participantId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapabilityCOTUpdateWithoutCotInput = {
    capability?: CapabilityUpdateOneRequiredWithoutCapabilityCotsNestedInput
  }

  export type CapabilityCOTUncheckedUpdateWithoutCotInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
  }

  export type CapabilityCOTUncheckedUpdateManyWithoutCotInput = {
    capabilityId?: StringFieldUpdateOperationsInput | string
  }

  export type ParticipantsCOTUpdateWithoutCotInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ParticipantUpdateOneWithoutParticipantsCotsNestedInput
  }

  export type ParticipantsCOTUncheckedUpdateWithoutCotInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantsCOTUncheckedUpdateManyWithoutCotInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutCotInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: SignatureUpdateOneRequiredWithoutCertificatesNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutCotInput = {
    id?: StringFieldUpdateOperationsInput | string
    signatureId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutCotInput = {
    id?: StringFieldUpdateOperationsInput | string
    signatureId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManySignatureInput = {
    id?: string
    cotId: string
    participantId: string
    issuedDate?: Date | string
    certificateNumber: string
    attendance: boolean
    theoryScore: number
    practiceScore: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateWithoutSignatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cot?: COTUpdateOneRequiredWithoutCertificatesNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutSignatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutSignatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    cotId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    issuedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    attendance?: BoolFieldUpdateOperationsInput | boolean
    theoryScore?: FloatFieldUpdateOperationsInput | number
    practiceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}